<!DOCTYPE html><html lang="de"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Closures - Aramís Concepción Durán</title><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://nojs.de/closures/"><link rel="alternate" type="application/atom+xml" href="https://nojs.de/feed.xml" title="Aramís Concepción Durán - RSS"><link rel="alternate" type="application/json" href="https://nojs.de/feed.json" title="Aramís Concepción Durán - JSON"><meta property="og:title" content="Closures"><meta property="og:site_name" content="Aramís Concepción Durán"><meta property="og:description" content=""><meta property="og:url" content="https://nojs.de/closures/"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://nojs.de/media/website/59de3f1dd701ffa954c008012966b9d97d6911b5.png" type="image/x-icon"><link rel="stylesheet" href="https://nojs.de/assets/css/style.css?v=11bee19e86e8eda2cf9a60efd975666d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://nojs.de/closures/"},"headline":"Closures","datePublished":"2023-01-18T12:39+01:00","dateModified":"2025-04-07T06:53+02:00","description":"","author":{"@type":"Person","name":"Aramís Concepción Durán","url":"https://nojs.de/authors/aramis-concepcion-duran/"},"publisher":{"@type":"Organization","name":"Aramís Concepción Durán"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://nojs.de/">Aramís Concepción Durán</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Closures</h1><div class="feed__meta content__meta"><time datetime="2023-01-18T12:39" class="feed__date">2023-01-18</time></div></div></header></div><div class="entry-wrapper content__entry"><p>Ich spiele gerade ein bisschen mit Go herum, weil ich mich aus meiner funktionalen Ecke heraustrauen und etwas mehr mit imperativen, C-artigen Sprachen befassen möchte. Rust hätte mich auch interessiert, scheint aber ein Fass ohne Boden zu sein. Go ist modern, trotzdem stabil, recht kompakt und weitverbreitet. Die Liste der großen und populären Softwareprojekte, die auf Go setzen, ist beachtlich.</p><p>In der <a href="https://go.dev/tour/">Go-Tour</a> gibt es einen Abschnitt zu Closures. Ich nutze die Gelegenheit, um für mich zu klären was Closures sind. Ich hab den Begriff bisher nie wirklich verstanden.</p><p>Eine Closure (i.e. ein Funktionsabschluss) ist eine Funkion, die Referenzen auf ihren Erstellungskontext enthält, wobei dieser Kontext außerhalb der Funktion nicht mehr sichtbar und nicht mehr referenzierbar ist.</p><p>Ein Beisiel aus dem Haskell Wiki:</p><pre><code>&gt; f x = \ y -&gt; x + y
&gt; g = f 3
&gt; g 4
7
</code></pre><p>Wenn wir <code>g</code> definieren, wird der Wert <code>3</code> an den Parameter <code>x</code> gebunden, so dass <code>g = \ y -&gt; 3 + y</code> gilt. Auf den Kontext, in dem die Bindung <code>x = 3</code> vorliegt, können wir aber nicht mehr zugreifen, obwohl er weiter existiert solange <code>g</code> existiert. Eine Closure liegt vor weil die Bindung <code>x = 3</code> im Kontext des Lambda-Ausdrucks erfolgt aber innerhalb des Lambda-Ausdrucks verwendet wird. Dadurch lebt der Kontext über die Definition hinaus weiter, weil er für die Auswertung benötigt wird.</p><p>Ich verstehe das, aber was ich nicht verstehe ist, warum man dieser Sache einen gesonderten Namen gibt und sie als eine spezielle Programmiertechnik behandelt. Statt <code>f x = \ y -&gt; x + y</code> könnte man auch schreiben: <code>f x y = x + y</code>. Das ist die normalste Sache der Welt und ich verstehe überhaupt nicht, wie es anders sein könnte, also was es bedeuten soll, ohne Closures zu programmieren.</p><p>Beim Schreiben kommt mir der Verdacht, dass es irgendwie damit zusammenhängen muss, dass Sprachen wie C keine First Class Functions haben. Wenn man es nicht gewohnt ist, kann das Herumreichen von Funktionen als Argumente und Rückgabewerte mit allen Möglichkeiten, die sich daraus ergeben, vielleicht wie ein besonderer Hokuspokus erscheinen, der erst mal in einen Begriff zu bringen ist: Closure — eine Funktion, die auf freien Variablen operiert.</p><p>Das Gegenteil wäre ein Combinator — eine Funktion ohne freie Variable.</p><p><strong>Update</strong></p><p>Ok, ich hab’s! Der eigentliche Effekt, an dem man offenbar bei der imperativen Programmierung mit Closures interessiert ist, tritt bei der rein funktionalen Programmierung gar nicht auf. Eine Closure ist in diesem Fall eine Prozedur mit einem inneren Zustand, der über mehrere Aufrufe hinweg fortbesteht und veränderbar ist. Hier ein angepasstes Beispiel aus der Go Tour:</p><pre><code>func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}
func main() {
    f := adder()
    fmt.Println(f(0)) // 0
    fmt.Println(f(1)) // 1
    fmt.Println(f(2)) // 3
    fmt.Println(f(3)) // 6
    fmt.Println(f(4)) // 10
    fmt.Println(f(5)) // 15
}
</code></pre><p>Was passiert hier? Die Prozedur <code>f</code> hat einen inneren Zustand, der mit <code>sum := 0</code> initialisiert wird, bei jedem Aufruf von <code>f</code> verändert wird und nur indirekt über den Rückgabewert observierbar ist. Daraus könnte man ein Objektsystem stricken.</p><p>Nicht alle imperativen Sprachen unterstützen Closures. Wenn sie es nicht tun, wird <code>f</code> im obigen Beispiel zur Identitätsfunktion, weil <code>f(n)</code> stets zu <code>0 + n</code> auswertet.</p></div><footer class="content__footer"><div class="entry-wrapper"><div class="content__actions"></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://nojs.de/trial-beim-mc-post-leipzig/" class="content__nav-link" rel="prev"><div><span>Previous</span> Trial beim MC Post Leipzig</div></a></div><div class="content__nav-next"><a href="https://nojs.de/negation-in-haskell-und-purescript/" class="content__nav-link" rel="next"><div><span>Next</span> Negation in Haskell und Purescript</div></a></div></div></div></nav></footer></article></main><footer class="footer"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://nojs.de/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://nojs.de/assets/js/scripts.min.js?v=ffcbea6c02c8178d10092962b235a5b0"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>