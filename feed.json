{
    "version": "https://jsonfeed.org/version/1",
    "title": "Aram√≠s Concepci√≥n Dur√°n",
    "description": "",
    "home_page_url": "https://nojs.de",
    "feed_url": "https://nojs.de/feed.json",
    "user_comment": "",
    "author": {
        "name": "Aram√≠s Concepci√≥n Dur√°n"
    },
    "items": [
        {
            "id": "https://nojs.de/json-serialisierung-von-linq-expressions/",
            "url": "https://nojs.de/json-serialisierung-von-linq-expressions/",
            "title": "JSON-Serialisierung von LINQ-Expressions",
            "content_html": "<p>Ich sehe hin und wieder C# Code, der via <a href=\"https://www.nuget.org/packages/mongodb.driver\">MongoDB.Driver</a> Daten aus MongoDB-Collections aggregiert, aufgerufen √ºber eine Web-API und eine vorgeschaltete Connector-Klasse mit statischen Wrapper-Methoden f√ºr die Bedienung der API-Endpunkte.</p><p>Wenn die Daten nicht nur paginiert sondern auch gefiltert werden sollen, stellt sich nat√ºrlich die Frage, wie man auf dem Hinweg das Filterkriterium kodiert und serialisiert.  Bisher habe ich die folgende Antwort gesehen: ad-hoc ein DTO zusammenstricken, das jeweils eine Property enth√§lt f√ºr die konkreten Filteroptionen, die jetzt (oder vielleicht sp√§ter) ben√∂tigt werden.  Ein Gedanke dabei ist sicherlich, dass man dieses Datentransferobjekt im Nachhinein erweitern kann sobald neue Filteranforderungen auftauchen.</p><p>F√ºr die Posts in einem Blog k√∂nnte das so aussehen:</p><pre><code>Class PostsRequest\n{\n    string? Author { get; set; }\n    DateTime? MinCreated { get; set; }\n    List&lt;string&gt;? Tags { get; set; }\n}\n</code></pre>\n<p>Der Controller-Code nimmt dieses Objekt entgegen und konstruiert daraus einen Filter f√ºr die Aggregation der Daten:</p><ol>\n<li>Erzeuge einen leeren Filter.</li>\n<li>Wenn <code>r.Author is not null</code>, f√ºge <code>x =&gt; x.Author == r.Author</code> hinzu.</li>\n<li>Wenn <code>r.MinCreated is not null</code>, f√ºge <code>x =&gt; x.Created &gt;= r.MinCreated</code> hinzu.</li>\n<li>Wenn <code>r.Tags.IsNotNullOrEmpty()</code>, f√ºge <code>x.Tags.Contains(r.Tags)</code> hinzu (oder so √§hnlich).</li>\n</ol>\n<p>Aber was ist wenn ich mehrere Authoren angeben m√∂chte?  Dann muss <code>PostsRequest</code> entsprechend angepasst und <code>Author</code> von <code>string?</code> auf <code>List&lt;string&gt;?</code> umgestellt werden.  Der Server-Code, der den eigentlichen Filter konstruiert, muss daf√ºr ebenfalls angepasst werden.  Bekomme ich dann die Posts jeweils aller angegebenen Authoren?  Oder nur die Posts, die von allen angegebenen Authoren gemeinsam verfasst wurden?  Oder beides?  Hoffentlich ist <code>PostsRequest</code> entsprechend dokumentiert.  Hoffentlich passt die Dokumentation zur tats√§chlichen Implementierung des Filters.  Hoffentlich hat niemand im Nachhinein den Filter ver√§ndert und dabei vergessen, auch die Dokumentation anzupassen.  Was ist wenn ich alle obigen F√§lle ben√∂tige?  F√ºge ich dann Properties f√ºr alle F√§lle zu <code>PostsRequest</code> hinzu?  Oder eine Art Steuer-Property, die festlegt, wie <code>r.Author</code> vom Server-Code zu interpretieren ist?  Was ist wenn ich <code>MaxCreated</code> ben√∂tige?  Oder <code>MinCreated</code> aber nicht inklusiv sondern exklusiv?  Was ist wenn ich ein noch komplexeres Filterkriterium ben√∂tige?</p><p>Dieser Ansatz ist die reine H√∂lle.  Er verkompliziert und verengt eine Sache, die eigentlich eine sehr simple und allgemeine L√∂sung haben sollte: ich gebe der Connector-Methode ein Pr√§dikat <code>Func&lt;Post, bool&gt;</code> und sie holt mir Eintr√§ge vom Typ <code>Post</code> aus der Datenbank, die auf dieses Pr√§dikat passen!</p><p>Damit verschwindet die ganze Sperrigkeit des <code>PostsRequest</code> Ansatzes, weil ich als Aufrufer der Connector-Methode selbst mein Filterpr√§dikat angebe, und zwar in der allgemeinen Form <code>Func&lt;Post,bool&gt;</code>, ohne durch die unpassende Struktur und Semantik eines Request-Datentyps eingeschr√§nkt zu sein; ohne raten zu m√ºssen, was der eigentliche Filter-Code macht, der sich hinter der API auf dem Server versteckt; ohne dass der serverseitige Filter-Code immer wieder angepasst werden muss.</p><p>Die Sache hat nat√ºrlich einen Haken, der wahrscheinlich auch der Grund daf√ºr sein wird, dass ich stattdessen Request-DTOs sehe: Wie serialisiert man eigentlich eine <code>Func&lt;Post, bool&gt;</code> um sie via HTTP an eine Web-API zu √ºbertragen und auf der Gegenseite korrekt wieder zu deserialisieren? ü§î</p><p>Es gibt daf√ºr tats√§chlich eine L√∂sung.  Die <code>FilterDefinitionBuilder</code> Klasse in <code>MongoDB.Driver</code> exponiert eine <code>Where</code> Methode:</p><pre><code>public FilterDefinition&lt;T&gt; Where(Expression&lt;Func&lt;T, bool&gt;&gt; expression)\n</code></pre>\n<p>Damit k√∂nnen wir aus einer <code>Expression&lt;Func&lt;Post, bool&gt;&gt;</code> eine <code>FilterDefinition&lt;Post&gt;</code> erzeugen, die der MongoDB-Treiber in seiner Aggregation verwenden kann.  Dabei repr√§sentiert <code>Expression&lt;Func&lt;Post, bool&gt;&gt;</code> einen AST f√ºr den unkompilierten Code einer Funktion <code>Func&lt;Post, bool&gt;</code>.  Ein AST bringt uns der Serialisierung schon ein ganzes St√ºck n√§her.  Allerdings kommt das ASP.NET Model Binding mit diesem Datentyp nicht zurecht.</p><p>Immerhin m√ºssen wir den Serializer nicht selbst schreiben.  Sascha Kiefer war so freundlich, daf√ºr das NuGet-Paket <a href=\"https://www.nuget.org/packages/Serialize.Linq\">Serialize.Linq</a> bereitzustellen.  Wir m√ºssen lediglich im Connector-Code unsere Expression serialisieren bevor wie sie √ºbertragen, bzw. im Controller-Code h√§ndisch den <code>Request.Body</code> auslesen und deserialisieren:</p><pre><code>// Connector\n\nExpression&lt;Func&lt;T, bool&gt;&gt; expression = x =&gt; pred(x);\n\nExpressionSerializer expressionSerializer =\n    new Serialize.Linq.Serializers.ExpressionSerializer(\n        new Serialize.Linq.Serializers.JsonSerializer()\n    );\n\nvar expressionPayload =\n    expressionSerializer.SerializeText(expression);\n\n// Controller\n\nstring expressionPayload =\n    await new StreamReader(Request.Body).ReadToEndAsync();\n\nExpressionSerializer expressionSerializer =\n    new Serialize.Linq.Serializers.ExpressionSerializer(\n        new Serialize.Linq.Serializers.JsonSerializer()\n    );\n\nvar expression =\n    (Expression&lt;Func&lt;T, bool&gt;&gt;)\n    expressionSerializer.DeserializeText(expressionPayload);\n</code></pre>\n<p>Damit spart man sich einen gro√üen Haufen sperrigen Behelfs-Boilerplate-Code f√ºr DTOs und serverseitige Filterkonstruktion.  Gleichzeitig beh√§lt man alle Freiheitsgrade eines allgemeinen logischen Pr√§dikates.</p><p>Allerdings muss man dabei ein bisschen aufpassen: der MongoDB-Treiber unterst√ºtzt keine beliebigen Expressions.  Er unterst√ºtzt alle Logik, die man braucht, um ein Filterpr√§dikat zu formulieren, aber keinen beliebigen C#-Code, der sich prinzipiell nicht nach MongoDB √ºbersetzen l√§sst, wie z.B. <code>DateTime.Now</code> oder Guid.NewGuid()` oder Inline-Funktionen.</p>",
            "author": {
                "name": "Aram√≠s Concepci√≥n Dur√°n"
            },
            "tags": [
            ],
            "date_published": "2025-05-11T10:35:46+02:00",
            "date_modified": "2025-05-11T10:35:46+02:00"
        },
        {
            "id": "https://nojs.de/tschuessi-mc-post/",
            "url": "https://nojs.de/tschuessi-mc-post/",
            "title": "Tsch√ºssi, MC Post!",
            "content_html": "<figure class=\"post__image\"><img loading=\"lazy\" src=\"../media/files/808fa6fa1a890f20da764515f6b9f6019dcd2131.jpg\" alt=\"\"  data-is-external-image=\"true\"></figure><p>Ich bin nicht mehr im MC Post aktiv.</p><p>Als Trial-Sparte haben wir ‚Äì w√§hrend meiner aktiven Zeit im Verein ‚Äì zwei L√§ufe zur Ostdeutschen Meisterschaft im Motorrad-Trial veranstaltet.  Ich hab gelernt, dass es Freude macht, Sportveranstaltungen zu planen und durchzuf√ºhren.  Wenn am Veranstaltungstag alles l√§uft, ist das wirklich ein sch√∂nes Gef√ºhl.  Ich h√§tte mir gew√ºnscht, Motorrad-Trial im Verein weiter auszubauen, daneben auch Fahrrad-Trial zu etablieren und eine Jugendsportgruppe daf√ºr aufzubauen.</p><p>Leider war nichts davon m√∂glich.</p><p>Der Verein hat massive Probleme, die viel mit informellen Beziehungs- und Machtstrukturen zu tun haben.  Der feste Kern des Vereins funktioniert wie eine Schulhofclique und ist ein sozialpsychologisches Lehrbuchbeispiel f√ºr Eigengruppenbevorzugung und Fremdgruppenabwertung.  Ich muss an der Stelle wirklich beherzt auf die Bremse treten, um das nicht weiter auszuf√ºhren.  Es gab von Anfang an starke Signale in diese Richtung und aus der Reihe der Trial-Fahrer explizite Warnungen, die ich mit meinem naiven Optimismus √ºberdeckt habe.</p><p>Aber nach zwei Jahren bin ich auch zu dem Schluss gekommen, dass es keinen Zweck hat.  Der Verein ist in einer Art Pattsituation.  Er kann nicht wachsen.  Er kann seinen Mitgliederstamm nicht verj√ºngern.  Er kann seine Bekanntheit in der Stadt nicht steigern.  In Leipzig leben √ºber 600.000 Menschen, nicht wenige davon motorsportbegeistert, aber niemand wei√ü, dass mitten in der Stadt Motorradrennsport betrieben wird.  Mit etwas Geschick m√ºsste es m√∂glich sein, zu einem Speedway-Rennen 10.000 Leipziger als Zuschauer ins Motodrom zu locken, aber jede Initiative in diese Richtung wird vom Verein durch Selbstsabotage vereitelt.  Stattdessen begn√ºgt man sich mit mittleren dreistelligen Besucherzahlen und erkl√§rt das damit, dass die Kids heute nur noch Youtube schauen oder Computerspiele zocken.  Es ist absurd!</p><p>Es w√ºrde mich √ºberraschen, wenn es den Verein in 3, 4, 5 Jahren √ºberhaupt noch gibt.  H√∂chstwahrscheinlich wird dann RB Leipzig auf dem Gebiet des ehemaligen Motodroms aktiv sein oder selbiges als Ausgleichsfl√§che wiederaufforsten.  Wer den kommunalpolitischen Buschfunk verfolgt, wei√ü, dass das intern schon l√§ngst wieder diskutiert und projektiert wird. Um das noch mal zu verhindern, h√§tte man in den letzten Jahren aus dem Knick kommen m√ºssen.</p><p>Aber das macht alles nix!  Ich hab aus der Zeit beim MC Post wertvolle Erfahrungen und Bekanntschaften/Freundschaften mitgenommen.  Und wer wei√ü: vielleicht mache ich demn√§chst auch mal als Teilnehmer bei einem Motorrad-Trial-Wettbewerb mit.</p>",
            "author": {
                "name": "Aram√≠s Concepci√≥n Dur√°n"
            },
            "tags": [
            ],
            "date_published": "2025-04-06T12:44:24+02:00",
            "date_modified": "2025-04-07T06:54:16+02:00"
        },
        {
            "id": "https://nojs.de/adts-gadts-typklassen/",
            "url": "https://nojs.de/adts-gadts-typklassen/",
            "title": "ADTs, GADTs, Typklassen",
            "content_html": "<p>Ich habe vor Kurzem <em>funktionale Abh√§ngigkeiten</em> kennengelernt und\nhatte gleich den Impuls, dar√ºber zu schreiben.  Das ist eine gute\nGelegenheit, um etwas ausf√ºhrlicher auf Konzepte der Typebene\nin Sprachen wie Haskell, Purescript, Elm und Ocaml einzugehen.</p><h2 id=\"einfache-datentypen\">Einfache Datentypen</h2>\n<p>Die meisten Sprachen bringen einen Vorrat an einfachen Datentypen\nmit: numerische Datentypen f√ºr ganze Zahlen und Gleitkommazahlen,\nDatentypen f√ºr einzelne Buchstaben und andere Schriftzeichen,\neinen Datentyp mit den zwei Wahrheitswerten ‚Äúfalsch‚Äù und ‚Äúwahr‚Äù.</p><p>In den Details gibt es gro√üe Unterschiede zwischen den Sprachen,\nje nachdem, wo sie ihre Schwerpunkte setzen und welche Form der\nProgrammierung sie unterst√ºtzen.  Beispielsweise hat C keinen\nspeziellen Datentyp f√ºr Wahrheitswerte, Python und Javascript\nunterscheiden nicht streng zwischen einzelnen Schriftzeichen und\nZeichenketten, Javascript unterscheidet nicht zwischen ganzen Zahlen\nund Gleitkommazahlen, TCL kennt nur Zeichenketten, ‚Ä¶</p><p>Ein paar einfache Datentypen in Haskell:</p><ul>\n<li><code>Int</code>: ganze Zahlen wie <code>-3</code>, <code>0</code>, <code>123</code>, <code>999999999</code>, ‚Ä¶</li>\n<li><code>Float</code>: Gleitkommazahlen wie <code>-123.45</code>, <code>1.0</code>, <code>3.141592653</code>, ‚Ä¶</li>\n<li><code>Char</code>: Zeichen wie <code>&#39;a&#39;</code>, <code>&#39;Œ≤&#39;</code>, <code>&#39;7&#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;?&#39;</code>, <code>&#39;üôÇ&#39;</code>, ‚Ä¶</li>\n<li><code>Bool</code>: die Wahrheitswerte <code>True</code> und <code>False</code>.</li>\n</ul>\n<h2 id=\"die-gr√∂√üe-einfacher-datentypen\">Die Gr√∂√üe einfacher Datentypen</h2>\n<p>Man kann einen Datentyp auffassen als die Menge seiner Werte.\nHier als Beispiel der Datentyp <code>Bool</code> in Mengenschreibweise:</p><pre><code>Bool = { False , True }\n</code></pre>\n<p>Die Gr√∂√üe eines Datentyps ist die Anzahl seiner Werte.\nDer Datentyp <code>Bool</code> enth√§lt genau zwei Werte.  Damit ist seine\nGr√∂√üe 2.</p><p>Das gleiche Spiel kann man mit allen einfachen Datentypen spielen.\nDer kleinste <code>Int</code> Wert auf meinem Rechner ist die ganze Zahl\n<code>-9223372036854775808</code> und der gr√∂√üte <code>Int</code> Wert die ganze Zahl\n<code>9223372036854775807</code>.  Daraus ergibt sich f√ºr den Datentyp <code>Int</code>\ndie Gr√∂√üe <code>2^64</code>.</p><p>Die Gr√∂√üe eines einfachen Datentyps h√§ngt letztlich auch damit\nzusammen, wie viele Bits mindestens ben√∂tigt werden um einen\nseiner Werte zu codieren.  Ein <code>Int</code> Wert ist auf meinem Rechner\nin 64 Bits codiert.  Daraus ergibt sich, dass <code>2^64</code> verschiedene\n<code>Int</code> Werte codiert werden k√∂nnen.  In Sprachen wie C, die daf√ºr\ngemacht sind, m√∂glichst effiziente Programme zu schreiben und\nverh√§ltnism√§√üig nah an der Hardware zu programmieren, bedeutet\nein Datentyp im Grunde nicht mehr als die Anzahl von Bits, die\neiner seiner Werte im Speicher mindestens ben√∂tigt.</p><p>Bei <code>Char</code> und <code>Float</code> ist die Berechnung der Gr√∂√üe etwas\nkomplizierter.  vom Datentyp <code>Char</code> gibt es insgesamt <code>1114112</code>\nWerte.  F√ºr <code>Float</code> wei√ü ich es nicht, aber es l√§sst sich\ngrunds√§tzlich ausrechnen.</p><h2 id=\"zusammengesetzte-datentypen\">Zusammengesetzte Datentypen</h2>\n<p>Zusammengesetzte Datentypen sind bspw. Arrays, Listen, Strings,\nTupel, Records und Structs.  Das sind allesamt Datentypen, die sich\n‚Äì wie der Name sagt ‚Äì auf irgendeine Art aus anderen Datentypen\nzusammensetzen.</p><p>Ein Record-Datentyp f√ºr ganzzahlige Punkte in der Ebene k√∂nnte\nso aussehen:</p><pre><code>-- Purescript\ntype Point = { x :: Int , y :: Int }\n</code></pre>\n<p>Ein Tupel-Datentyp f√ºr den selben Zweck:</p><pre><code>-- Haskell\n(Int,Int)\n</code></pre>\n<p>Der Record-Datentyp hat den Vorteil, dass die Felder mit x und y\nbezeichnet sind.  Dadurch ist es vermutlich etwas schwerer, sie\nzu verwechseln.  Au√üerdem k√∂nnen wir direkt √ºber die Feldnamen\nauf ihre Werte zugreifen.  Beim Tupel-Datentyp verlassen wir uns\nauf die Position der Felder f√ºr ihre Unterscheidung.  Der Zugriff\nauf die Felder erfolgt √ºber Pattern-Matching in Case Expressions\noder √ºber spezielle Zugriffsfunktionen wie <code>fst</code> und <code>snd</code>.\nDaf√ºr deckt sich die Tupel-Schreibweise mit der Schreibweise f√ºr\nPunkte in der Ebene, die auch sonst √ºblich ist.  Das sind aber rein\nergonomische Unterschiede.  Strukturell unterscheiden sich diese\nbeiden Datentypen nicht voneinander: in beiden F√§llen besteht ein\nPunkt aus zwei <code>Int</code> Werten.</p><h2 id=\"die-gr√∂√üe-zusammengesetzter-datentypen\">Die Gr√∂√üe zusammengesetzter Datentypen</h2>\n<p>Es gibt auf meinem Rechner <code>2^64</code> Werte vom Datentyp <code>Int</code>.\nF√ºr den Datentyp <code>Point</code> ergeben sich damit <code>2^64 * 2^64</code> also\n<code>2^128</code> Werte.  Das selbe gilt f√ºr den Datentyp <code>(Int,Int)</code>.\nSolche Datentypen, die sich aus anderen Datentypen zusammensetzen,\nso dass ihre Gr√∂√üe das Produkt der Gr√∂√üen der beteiligten\nDatentypen ist, hei√üen <strong>Produkttypen</strong>.  Array-Datentypen und\nC-Structs sind auch Produkttypen.  Ein bisschen komplexer ist es\nbei Listen und Strings.  Mehr dazu weiter unten.</p><p>In allen herk√∂mmlichen Sprachen kann man Produkttypen definieren,\naber oft fehlt die M√∂glichkeit, <strong>Summentypen</strong> zu definieren.\nDas sind Datentypen, die sich aus anderen Datentypen zusammensetzen,\nso dass ihre Gr√∂√üe die Summe der Gr√∂√üen der beteiligten\nDatentypen ist.</p><h2 id=\"algebraische-datentypen\">Algebraische Datentypen</h2>\n<p>Algebraische Datentypen (ADTs) vereinen in sich Produkttypen und\nSummentypen: jeder ADT ist eine Summe von Produkten.</p><p><strong>Summen</strong></p><p>Einer der einfachsten ADTs ist der Datentyp <code>Bool</code> in Haskell:</p><pre><code>-- Haskell\ndata Bool = False | True\n</code></pre>\n<p><code>False</code> und <code>True</code> sind sogenannte Wertekonstruktoren (oder einfach\nnur Werte).  Den Balken m√ºssen wir lesen wie ein exklusives Oder:\njeder Wert vom Datentyp <code>Bool</code> ist entweder <code>False</code> oder <code>True</code>.\nAndere als diese zwei <code>Bool</code> Werte gibt es nicht.</p><p>ADTs k√∂nnen beliebig viele Wertekonstruktoren haben:</p><pre><code>-- Haskell\n\ndata Ampel = Gr√ºn | Gelb | Rot\n\ndata K√§se = Gouda | Cheddar | Brie | Camembert | Gruy√®re\n\ndata T = A | B | C | D | E | F | G | H | I | J | K\n</code></pre>\n<p>Wir k√∂nnen auch einen ADT mit genau einem Wertekonstruktor\ndefinieren:</p><pre><code>-- Haskell\ndata Eindeutig = Einheit\n</code></pre>\n<p>Hier hat nur der Wert <code>Einheit</code> den Datentyp <code>Eindeutig</code>.\nDamit besteht zwischen dem Datentyp und dem Wert eine\nEins-zu-eins-Beziehung.  Sogar der Spezialfall eines ADT mit\nkeinen Wertekonstruktoren ist m√∂glich.  Wir geben einfach keine\nWertekonstruktoren an:</p><pre><code>-- Haskell\ndata Nichts\n</code></pre>\n<p>Damit hat der Datentyp <code>Nichts</code> keine Werte.  Wir haben daher keine\nM√∂glichkeit, einen Wert vom Datentyp <code>Nichts</code> zu erzeugen oder eine\nFunktion anzuwenden, die auf <code>Nichts</code> operiert.  Leere Datentypen\nsind nicht nutzlos, aber darauf werde ich hier nicht weiter eingehen.\nStattdessen m√∂chte ich auf eine Sache hinweisen, die Verwirrung\nstiften kann.  Betrachte daf√ºr die folgende Typdefinition:</p><pre><code>-- Haskell\n\ndata Tasche\n    = T√ºte\n    | Beutel\n    | Rucksack\n    | G√ºrteltasche\n    | Tasche\n</code></pre>\n<p>Hier definieren wir den Datentyp <code>Tasche</code> mit den Werten  <code>T√ºte</code>,\n<code>Beutel</code>, <code>Rucksack</code>, <code>G√ºrteltasche</code> und <code>Tasche</code>.  Es sticht\nins Auge, dass der Name <code>Tasche</code> zweimal auftaucht: einmal als\nder Datentyp <code>Tasche</code>, einmal als der Wertekonstruktor <code>Tasche</code>.\nF√ºr den Compiler ist das kein Problem.  Er unterscheidet streng\nzwischen Datentypen und Wertekonstruktoren und kann sie nicht\nverwechseln, auch wenn sie den selben Namen haben.  Das Beispiel ist\nzwar an den Haaren herbeigezogen, aber es ist tats√§chlich manchmal\nsinnvoll, einem Datentyp und einem seiner Wertekonstruktoren den\nselben Namen zu geben.  Weiter unten wird uns so etwas begegnen.</p><p><strong>Wertekonstruktoren mit Feldern</strong></p><p>Bisher haben wir einfache Wertekonstruktoren wie <code>False</code>, <code>Gouda</code>,\n<code>Rucksack</code>, <code>A</code> usw. gesehen.  Wertekonstruktoren k√∂nnen aber\ntypisierte Felder haben.  Hier ein Beispiel:</p><pre><code>-- Haskell\ndata Lampe = Leuchtet Bool\n</code></pre>\n<p>Der Datentyp <code>Lampe</code> hat den Wertekonstruktor <code>Leuchtet</code> mit einem\nFeld vom Datentyp <code>Bool</code>.  Bisher haben wir die Begriffe <em>Wert</em>\nund <em>Wertekonstruktor</em> als Synonyme behandelt.  Das √§ndert sich\nsobald Felder ins Spiel kommen.  Der Wertekonstruktor <code>Leuchtet</code>\nist allein noch kein Wert vom Datentyp <code>Lampe</code>.  Wir m√ºssen ihn\num einen <code>Bool</code> Wert erg√§nzen, um einen Wert vom Datentyp <code>Lampe</code>\nzu erzeugen.</p><pre><code>-- Haskell Repl\n\n&gt; data Lampe = Leuchtet Bool\n\n&gt; :type Leuchtet\nLeuchtet :: Bool -&gt; Lampe\n\n&gt; lampeAn = Leuchtet True\n\n&gt; :type lampeAn\nlampeAn :: Lampe\n</code></pre>\n<p><strong>Produkte</strong></p><p>Wertekonstruktoren k√∂nnen mehr als ein Feld haben.  Hier ein\nBeispiel:</p><pre><code>-- Haskell\ndata Datum = Datum Int Int Int  -- Tag Monat Jahr\n</code></pre>\n<p>Der Datentyp <code>Datum</code> hat einen Wertekonstruktor <code>Datum</code> mit drei\nFeldern vom Datentyp <code>Int</code>.  So ein Datentyp  entspricht den normalen\nProdukttypen, die wir oben schon kennengelernt haben.</p><p><strong>Summen von Produkten</strong></p><p>In einem ADT lassen sich Produkte und Summen kombinieren.  Hier ein\nDatentyp mit drei Wertekonstruktoren, die jeweils ein Feld vom\nDatentyp <code>Bool</code> haben:</p><pre><code>-- Haskell\ndata MyType = X Bool | Y Bool | Z Bool\n</code></pre>\n<p>Daraus ergeben sich die folgenden konkreten Werte:</p><ul>\n<li><code>X False</code></li>\n<li><code>X True</code></li>\n<li><code>Y False</code></li>\n<li><code>Y True</code></li>\n<li><code>Z False</code></li>\n<li><code>Z True</code></li>\n</ul>\n<p>Hier ein Datentyp mit f√ºnf Wertekonstruktoren und unterschiedlichen\nAnzahlen von Feldern:</p><pre><code>-- Haskell\n\ndata Zubrot\n    = K√§se Bool         -- vegan ja/nein\n    | Wurst Bool        -- vegan ja/nein\n    | Marmelade Int Int -- Frucht- und Zuckergehalt in %\n    | Margarine\n    | Butter\n</code></pre>\n<h2 id=\"die-gr√∂√üe-algebraischer-datentypen\">Die Gr√∂√üe algebraischer Datentypen</h2>\n<p>Die Gr√∂√üe eines ADT ist die Summe der Gr√∂√üen seiner\nWertekonstruktoren.  Die Gr√∂√üe eines Wertekonstruktors ist das\nProdukt der Gr√∂√üen seiner Feldtypen.  Ein Wertekonstruktor ohne\nFelder hat die Gr√∂√üe 1.  Ein Datentyp ohne Wertekonstruktoren\nhat die Gr√∂√üe 0.</p><p>Wir berechnen die Gr√∂√üe f√ºr ein paar ADTs:</p><pre><code>|Nichts| == 0\n\n|Eindeutig| == |Einheit| == 1\n\n|Bool| == |False| + |True| == 1 + 1 == 2\n\n|Ampel| == |Gr√ºn| + |Gelb| + |Rot| == 1 + 1 + 1 == 3\n\n|Lampe| == |Leuchtet Bool| == |Bool| == 2\n\n|Datum| == |Datum Int Int Int|\n        == |Int| * |Int| * |Int|\n        == 3^64 * 3^64 * 3^64\n        == 3^192\n\n|MyType| == |X Bool| + |Y Bool| + |Z Bool|\n         == |Bool| + |Bool| + |Bool|\n         == 2 + 2 + 2\n         == 6\n\n|Zubrot| == |K√§se Bool| + |Wurst Bool| + |Marmelade Int Int|\n          + |Margarine| + |Butter|\n         == |Bool| + |Bool| + |Int| * |Int| + 1 + 1\n         == 2 + 2 + 2^64 * 2^64 + 1 + 1\n         == 2^128 + 6\n</code></pre>\n<p>Weiter unten werden wir auch unendlich gro√üe ADTs sehen.</p><h2 id=\"der-mehrwert-algebraischer-datentypen\">Der Mehrwert algebraischer Datentypen</h2>\n<p>Mit ADTs k√∂nnen wir neue Datentypen jeder beliebigen Gr√∂√üe\nerzeugen und die Datentypen, die wir schon vorliegen haben, sowohl\nadditiv als auch multiplikativ zu neuen Datentypen verkn√ºpfen.\nF√ºr jede Datenstruktur, die sich so beschreiben l√§sst, k√∂nnen\nwir einen ADT definieren.  Ich m√∂chte an zwei Beispielen zeigen,\nwelchen Mehrwert das hat.</p><p><strong>Beispiel 1: Verkehrsampel</strong></p><p>Ein Datentyp f√ºr die drei Zust√§nde einer aktiven Ampel k√∂nnte\nso definiert sein:</p><pre><code>--Haskell\ndata Ampel = Gr√ºn | Gelb | Rot\n</code></pre>\n<p>Viele herk√∂mmliche Sprachen scheitern schon daran, einen genau\ndreiwertigen Datentyp zu erzeugen.</p><p>Wenn wir entscheiden m√ºssen, ob jemand f√ºr das √úberfahren einer\nAmpel im Stra√üenverkehr einen Bu√ügeldbescheid erhalten soll oder\nnicht, k√∂nnen wir das wie folgt modellieren:</p><pre><code>-- Haskell\n\nbu√ügeldbescheid :: Ampel -&gt; Bool\nbu√ügeldbescheid ampel = case ampel of\n    Gr√ºn -&gt; False\n    Gelb -&gt; False\n    Rot -&gt; True\n</code></pre>\n<p>Hier ist <code>bu√ügeldbescheid</code> eine Funktion von <code>Ampel</code> nach <code>Bool</code>.\nDie drei Werte des Datentyps <code>Ampel</code> entsprechen den drei Zust√§nden\neiner aktiven Ampel.  Mit anderen als diesen drei Werten m√ºssen\nwir uns beim Implementieren nicht auseinandersetzen.  Stattdessen\nk√∂nnen wir uns voll und ganz auf das Wesentliche konzentrieren: die\nZuordnung der tats√§chlichen Ampelzust√§nde nach <code>Bool</code>.  Auch beim\nVerwenden der Funktion ohne Kenntnis ihrer Implementierung m√ºssen\nwir uns keine Gedanken √ºber andere als diese drei Werte machen,\ndenn die Funktion akzeptiert nur diese drei und der Compiler sichert\ndas f√ºr uns ab.</p><p>Ganz anders sieht das aus, wenn wir bei der Modellierung des selben\nSachverhaltes ohne ADTs bzw. ohne Summentypen auskommen m√ºssen.\nWir sind dann gezwungen, auf bestehende Datentypen zur√ºckzugreifen.\nZum Beispiel so:</p><pre><code>-- Haskell\n\ngr√ºn = 0\ngelb = 1\nrot = 2\n\nbu√ügeldbescheid :: Int -&gt; Bool\nbu√ügeldbescheid ampel =\n    ampel /= gr√ºn &amp;&amp; ampel /= gelb\n</code></pre>\n<p>Man kann so programmieren, aber die Funktion hat jetzt f√ºr den\nCompiler einen Definitionsbereich aus <code>2^64</code> Werten.  Drei davon\nk√ºmmern uns: n√§mlich <code>0</code>, <code>1</code> und <code>2</code> bzw. <code>gr√ºn</code>, <code>gelb</code>\nund <code>rot</code>.  Die √ºbrigen 18446744073709551613 Werte sind f√ºr den\nmodellierten Sachverhalt √ºberfl√ºssig.  Aber k√∂nnen wir uns darauf\nverlassen, dass kein anderer Wert an die Funktion √ºbergeben wird?\nSo wie sie jetzt implementiert ist, werden die 18446744073709551613\n√ºberfl√ºssigen Werte auf <code>True</code> abgebildet.  Das k√∂nnte zur Folge\nhaben, dass Bu√ügeldbescheide an Personen versendet werden, die\nnicht bei Rot gefahren sind, weil jemand den Aufruf der Funktion\nvermasselt hat, oder weil jemand die Dokumentation nicht richtig\ngelesen hat, oder weil die Implementierung sich zwischenzeitlich\nge√§ndert hat: bei einem Refactoring wurde der R√ºckgabewert f√ºr\ndie 18446744073709551613 √ºberfl√ºssigen Werte ver√§ndert und schon\ntritt ein Fehler auf, den es vorher nicht gab.</p><p>Hier liegt ein Fehlerpotenzial vor, das es nicht gibt wenn man ADTs\nverwendet um die Definitions- und Wertebereiche der Funktionen,\nProzeduren und Methoden so festzulegen, dass sie genau zum\nmodellierten Sachverhalt passen.</p><p><strong>Beispiel 2: unbekanntes Alter</strong></p><p>Stellen wir uns vor, dass wir einen Datentyp f√ºr das Alter von\nPersonen als ganze Zahl in Jahren ben√∂tigen.  Es liegt auf der\nHand, daf√ºr den Datentyp <code>Int</code> zu verwenden.  Noch besser w√§re\nein Datentyp f√ºr nat√ºrliche Zahlen, aber darum k√ºmmern wir uns\njetzt nicht.</p><p>Komplizierter ist es, wenn wir ber√ºcksichtigen m√ºssen, dass das\nAlter einer Person unbekannt sein kann.  Wie bilden wir das ab?\nIch zeige erst, wie hier ein ADT helfen kann.  Dann kritisiere\nich, wie das in Sprachen ohne ADTs gel√∂st wird.  Also, hier mein\nVorschlag f√ºr einen passenden Datentyp:</p><pre><code>-- Haskell\ndata Alter = AlterUnbekannt | Alter Int\n</code></pre>\n<p>Ein Wert vom Datentyp <code>Alter</code> ist entweder <code>AlterUnbekannt</code> oder\n<code>Alter</code> mit einem <code>Int</code> Feld.  Stellen wir uns die drei Personen\nMarit, Marta und Max vor.  Marit ist 30, Marta ist 11 und von Max\nkennen wir das Alter nicht.</p><pre><code>-- Haskell\n\nmaritAlter :: Alter\nmaritAlter = Alter 30\n\nmartaAlter :: Alter\nmartaAlter = Alter 11\n\nmaxAlter :: Alter\nmaxAlter = AlterUnbekannt\n</code></pre>\n<p>Auf diese Weise unterscheiden wir sauber zwischen einem bekannten und\neinem unbekannten Alter.  Eine Funktion, die Altersklassen bestimmt,\nk√∂nnte so aussehen:</p><pre><code>-- Haskell\n\ndata Altersklasse\n    = Minderj√§hrig\n    | Vollj√§hrig\n    | AltersklasseUnbekannt\n\naltersklasse :: Alter -&gt; Altersklasse\naltersklasse Alter = case alter of\n    Alter n -&gt; if n &lt; 18 then Minderj√§hrig else Vollj√§hrig\n    AlterUnbekannt -&gt; AltersklasseUnbekannt\n</code></pre>\n<p>Schauen wir uns die Altersklassen von Marit, Marta und Max an:</p><pre><code>-- Haskell Repl\n\n&gt; altersklasse maritAlter\nVollj√§hrig\n\n&gt; altersklasse martaAlter\nMinderj√§hrig\n\n&gt; altersklasse maxAlter\nAltersklasseUnbekannt\n</code></pre>\n<p>Dadurch, dass unser Datentyp <code>Alter</code> ganz ausdr√ºcklich auch den Wert\n<code>AlterUnbekannt</code> hat, m√ºssten wir uns schon besondere M√ºhe geben,\num diesen Fall bei der Berechnung der Altersklasse unter den Tisch\nfallen zu lassen.</p><p>Aber wie w√ºrden wir das ohne ADTs modellieren?  Hier noch mal der\nzu modellierende Sachverhalt: wir m√ºssen das Alter von Personen\ncodieren und dabei ber√ºcksichtigen, dass ein Alter unbekannt sein\nkann.  In Sprachen ohne ADTs gibt es f√ºr die Codierung solcher\nSonderf√§lle zwei verschiedene L√∂sungsans√§tze.</p><p><strong>Ansatz 1 ohne ADTs: Numerische Fehlercodes</strong></p><p>Bilde Sonderf√§lle wie Fehlercodes auf Werte ab, die zum selben\nDatentyp geh√∂ren wie die modellierte Gr√∂√üe, aber offensichtlich\nkein Wert der modellierten Gr√∂√üe sind.  Das setzt voraus, dass\nder Datentyp zus√§tzlichen Platz daf√ºr bietet.  Ein gutes Beispiel\ndaf√ºr ist die Java String-Methode <code>indexOf</code>, die man verwendet um\nnach Substrings zu suchen.  Wenn der Substring gefunden wurde, wertet\n<code>indexOf</code> zu dem Index aus, bei dem der Substring beginnt.  Wenn der\nSubstring nicht gefunden wurde, wertet <code>indexOf</code> zu <code>-1</code> aus:</p><pre><code>// Java\n&quot;abc&quot;.indexof(&quot;c&quot;)  // Wertet aus zu: 2\n&quot;abc&quot;.indexOf(&quot;d&quot;)  // Wertet aus zu: -1 \n</code></pre>\n<p>Die Idee dahinter ist, dass Indizes nat√ºrliche Zahlen sind und\ndass daher mit dem R√ºckgabewert <code>-1</code> offensichtlich kein Index\ngemeint sein kann.  In unserem Fall k√∂nnte der Ansatz so aussehen:</p><pre><code>-- Haskell\n\nmaritAlter :: Int\nmaritAlter = 30\n\nmartaAlter :: Int\nmartaAlter = 11\n\nmaxAlter :: Int\nmaxAlter = -1\n</code></pre>\n<p>Wenn wir jetzt die Altersklassen berechnen und dabei nicht genau\naufpassen, k√∂nnte die folgende Funktion zustande kommen:</p><pre><code>-- Haskell\n\ndata Altersklasse = Minderj√§hrig | Vollj√§hrig\n\naltersklasse :: Int -&gt;  Altersklasse\naltersklasse alter =\n    if alter &lt; 18 then Minderj√§hrig else Vollj√§hrig\n</code></pre>\n<p>Die Altersklassen f√ºr Marit, Marta und Max sehen dann wie folgt aus:</p><pre><code>-- Haskell Repl\n\n&gt; altersklasse maritAlter\nVollj√§hrig\n\n&gt; altersklasse martaAlter\nMinderj√§hrig\n\n&gt; altersklasse maxAlter\nMinderj√§hrig\n</code></pre>\n<p>Das ist nat√ºrlich Murks.  Wir wissen gar nicht, ob Max minderj√§hrig\nist, weil wir sein Alter nicht kennen.  Der Fehler ist aber\nnachvollziehbar: bei der Implementierung von <code>altersklasse</code> legen\nwir fest, dass Personen minderj√§hrig sind wenn ihr Alter in Jahren\nkleiner als 18 ist, denn genau so ist Minderj√§hrigkeit definiert.\nUm den Fehler zu vermeiden, m√ºssen wir wissen, dass hier auch\nnegative Zahlen zu ber√ºcksichtigen sind und dass <code>-1</code> das Fehlen\nder Altersinformation repr√§sentiert:</p><pre><code>-- Haskell\n\ndata Altersklasse\n    = Minderj√§hrig\n    | Vollj√§hrig\n    | AltersklasseUnbekannt\n\naltersklasse :: Int -&gt;  Altersklasse\naltersklasse alter =\n    if alter &lt; 0 then AltersklasseUnbekannt\n    else if alter &lt; 18 then Minderj√§hrig\n    else Vollj√§hrig\n</code></pre>\n<p>Wir gehen hier noch einen Schritt weiter und bilden alle negativen\nZahlen auf <code>AltersklasseUnbekannt</code> ab.  Dadurch sind wir schon\nauf der sicheren Seite wenn weitere Fehlercodes dazukommen.\nDie Altersklassen f√ºr Marit, Marta und Max stimmen jetzt wieder:</p><pre><code>-- Haskell Repl\n\n&gt; altersklasse maritAlter\nVollj√§hrig\n\n&gt; altersklasse martaAlter\nMinderj√§hrig\n\n&gt; altersklasse maxAlter\nAltersklasseUnbekannt\n</code></pre>\n<p>Javas <code>indexOf</code> Methode hat die gleiche Schw√§che.  Wenn wir\nbspw. in vielen Strings den gleichen Substring suchen, um seinen\ndurchschnittlichen Index zu berechnen, d√ºrfen wir nicht vergessen,\nden Wert <code>-1</code> gesondert zu verarbeiten.  Sonst berechnen wir\nein falsches Ergebnis.  Besser ist es, wenn wir zwischen der\nerfolgreichen und der gescheiterten Suche so unterscheiden, dass\nauch der Compiler diese Unterscheidung absichert.  Andernfalls liegt\ndie volle Verantwortung f√ºr diese Unterscheidung bei der Person,\ndie programmiert.</p><p><strong>Ansatz 2 ohne ADTs: Nullreferenzen</strong></p><p>Verwende Referenzdatentypen und stelle fehlende Werte dar als\nNullreferenzen.  Ein gutes Beispiel daf√ºr ist die Prozedur <code>strstr</code>\naus der C-Standard-Bibliothek:</p><pre><code>// C\nchar *result = strstr(myString, mySubstr);\n</code></pre>\n<p>Wenn <code>mySubstr</code> in <code>myString</code> enthalten ist, dann enth√§lt <code>result</code>\njetzt eine Referenz auf die Speicheradresse der Anfangsposition von\n<code>mySubstr</code> innerhalb von <code>myString</code>.  Andernfalls enth√§lt <code>result</code>\njetzt die Nullreferenz <code>NULL</code>.</p><p>In Sprachen, die es erlauben, Nullreferenzen so zu verwenden,\nmuss man h√∂llisch aufpassen: es kann passieren, dass man glaubt,\neinen Wert zu verarbeiten obwohl man eine Nullreferenz verarbeitet.\nDas f√ºhrt leicht zu Laufzeitfehlern.  In Haskell, Purescript,\netc. kann ich das nicht demonstrieren, weil es in diesen Sprachen\nkeine Referenzdatentypen und keine Nullreferenzen gibt.  Deswegen\nhier ein bisschen Java Code:</p><pre><code>// Main.java\n\nclass Alter {\n    int wert;\n    public Alter(int wert) {\n        this.wert = wert;\n    }\n    public int get() {\n        return this.wert;\n    }\n}\nclass Person {\n    public Alter alter;\n    enum Altersklasse { minderj√§hrig, vollj√§hrig }\n    public Altersklasse altersklasse() {\n        if (this.alter.get() &lt; 18) {\n            return Altersklasse.minderj√§hrig;\n        } else {\n            return Altersklasse.vollj√§hrig;\n        }\n    }\n}\nclass Main {\n    public static void main(String[] args) {\n        Person marit = new Person();\n        Person marta = new Person();\n        Person max = new Person();\n\n        marit.alter = new Alter(30);\n        marta.alter = new Alter(11);\n\n        System.out.println(marit.altersklasse());\n        System.out.println(marta.altersklasse());\n        System.out.println(max.altersklasse());\n    }\n}\n</code></pre>\n<p>Ich wickle das Alter einer Person hier in einen Datentyp <code>Alter</code> ein,\nweil Basisdatentypen wie <code>int</code> in Java keine Referenzdatentypen sind.\nDas passiert wenn wir das Programm compilieren und ausf√ºhren:</p><pre><code>$ javac Main.java\n$ java Main\nvollj√§hrig\nminderj√§hrig\nException in thread &quot;main&quot; java.lang.NullPointerException\n        at Person.altersklasse(Main.java:21)\n        at Main.main(Main.java:14)\n</code></pre>\n<p>Wir haben f√ºr Max kein Alter festgelegt.  Sobald wir seine\nAltersklasse abrufen, terminiert das Programm mit einer\n<code>NullPointerException</code>.  Selbstverst√§ndlich l√§sst sich das\nbeheben, indem wir die Aufz√§hlung <code>Altersklasse</code> und die Methode\n<code>altersklasse</code> anpassen, so wie wir es auch weiter oben gemacht\nhaben.  Die volle Verantwortung daf√ºr, solche Laufzeitfehler zu\nvermeiden, liegt hier wieder bei der Person, die programmiert.</p><p>Welcher dieser beiden Ans√§tze ist besser?  Das kommt darauf an, ob\nuns die Vermeidung von Laufzeitfehlern oder die Vermeidung falscher\nErgebnisse wichtiger ist.  Bei der Haskell-Funktion <code>altersklasse :: Alter -&gt; Altersklasse</code>, mit der wir begonnen haben, er√ºbrigt sich\ndiese Abw√§gung: Nullreferenzen gibt es nicht und um das numerische\nAlter mit einem Fehlercode zu erg√§nzen, f√ºhren wir einen neuen\nDatentyp ein, der durch zwei Wertekonstruktoren sauber unterscheidet\nzwischen einem bekannten und einem unbekannten Alter.</p><h2 id=\"parametrische-algebraische-datentypen\">Parametrische algebraische Datentypen</h2>\n<p>Parametriche ADTs sind ADTs, die in ihrer Definition einen\nsogenannten <em>Typparameter</em> enthalten.  Das ist ein Platzhalter,\nder durch einen konkreten Datentyp ersetzt werden muss, damit\naus dem parametrischen ADT ein konkreter Datentyp wird.  Solche\nDatentypen, die erst noch konkretisiert werden m√ºssen, nennt man\nauch <em>generische Datentypen</em>.  Um das Konzept zu demonstrieren,\nschauen wir uns noch mal den oben definierten Datentyp <code>Alter</code> an.\nWir steigen an der Stelle von Haskell auf Purescript um, damit wir\nweiter unten Record-Literale verwenden k√∂nnen:</p><pre><code>-- Purescript\ndata Alter = AlterUnbekannt | Alter Int\n</code></pre>\n<p>Wir haben diesen Datentyp eingef√ºhrt, um zu modellieren, dass das\nAlter einer Person manchmal bekannt und manchmal unbekannt ist.\nAber dieses Problem kann auch bei anderen Daten auftreten.\nWir k√∂nnten daf√ºr jedes mal einen spezifischen Datentyp einf√ºhren:</p><pre><code>-- Purescript\ndata Name = NameUnbekannt | Name String\ndata Alter = AlterUnbekannt | Alter Int\ndata Wohnort = WohnortUnbekannt | Wohnort String\ndata Beruf = BerufUnbekannt | Beruf String\n...\n</code></pre>\n<p>Ein beispielhafter Record f√ºr Marta mit diesen Datentypen k√∂nnte\nso aussehen:</p><pre><code>-- Purescript\nmarta =\n    { name : Name &quot;Marta&quot;\n    , alter : Alter 11\n    , wohnort : WohnortUnbekannt\n    , beruf : BerufUnbekannt\n    }\n</code></pre>\n<p>Wir m√ºssen aber nicht jeden Datentyp separat auf diese Weise\nerweitern.  Stattdessen k√∂nnen wir einen generischen Datentyp\nfestlegen, der jeden existierenden Datentyp um die M√∂glichkeit\neines fehlenden Wertes erweitert:</p><pre><code>-- Purescript\ndata Vielleicht a = Unbekannt | Wert a\n</code></pre>\n<p>Damit k√∂nnen wir jeden Datentyp so erweitern, dass ein Wert dieses\nTyps entweder vorhanden oder abhanden ist.  Wenn wir das Alter\neiner Person kennen, sieht das so aus:</p><pre><code>-- Purescript\nalter :: Vielleicht Int\nalter = Wert 23\n</code></pre>\n<p>Wenn wir das Alter nicht kennen, sieht das so aus:</p><pre><code>-- Purescript\nalter :: Vielleicht Int\nalter = Unbekannt\n</code></pre>\n<p>Das gleiche Spiel mit dem Wohnort:</p><pre><code>-- Purescript\nwohnort :: Vielleicht String\nwohnort = Wert &quot;Leipzig&quot;\n</code></pre>\n<p>Oder wenn der Wohnort unbekannt ist:</p><pre><code>-- Purescript\nwohnort :: Vielleicht String\nwohnort = Unbekannt\n</code></pre>\n<p>Beachte, dass das Alter den Datentyp <code>Int</code> hat aber der Wohnort\nden Datentyp <code>String</code>.  Trotzdem konnten wir in beiden F√§llen\nden generischen Datentyp <code>Vielleicht a</code> einsetzen. Wir haben damit\nden Datentyp <code>Int</code> auf <code>Vielleicht Int</code> und den Datentyp <code>String</code>\nauf <code>Vielleicht String</code> erweitert.  Ein ganzer Record f√ºr Marta\nk√∂nnte so aussehen:</p><pre><code>-- Purescript\n\nmarta =\n    { name : Wert &quot;Marta&quot;\n    , alter : Wert 11\n    , wohnort : Wert &quot;Leipzig&quot;\n    , beruf : Wert &quot;Sch√ºlerin&quot;\n    }\n</code></pre>\n<p>Damit sind die vier spezifischen Datentypen, die wir oben definiert\nhaben, √ºberfl√ºssig, weil wir sie ersetzen konnten durch einen\neinzigen generischen Datentyp, der die selbe Aufgabe erf√ºllt.</p><p>In der Praxis w√ºrde man einen Datentyp wie <code>Vielleicht a</code> nicht\ndefinieren, sondern den Datentyp <code>Maybe a</code> verwenden, der genau\nf√ºr diesen Zweck schon vordefiniert ist und die selbe Struktur hat.\nZum Vergleich hier die beiden Datentypen:</p><pre><code>-- Purescript\ndata Vielleicht a = Unbekannt | Wert a\ndata Maybe a = Nothing | Just a\n</code></pre>\n<p>Es geh√∂rt zum guten Programmierstil, die vordefinierten Datentypen\nzu verwenden wenn die Struktur passt.  Das erh√∂ht die Lesbarkeit.\nEs kann zwar manchmal sinnvoll sein, trotzdem eigene Datentypen\nzu verwenden, um zu verdeutlichen, worum es geht, aber je mehr man\nbeim Lesen von Code schon kennt, desto verst√§ndlicher ist der Code.</p><h2 id=\"unendlich-gro√üe-datentypen\">Unendlich gro√üe Datentypen</h2>\n<p>Bisher haben wir nur ADTs mit endlicher Gr√∂√üe betrachtet.  Es gibt\naber auch ADTs, die unendlich gro√ü sind.  Das ist zum Beispiel\nder Fall bei ADTs, die rekursiv √ºber sich selbst definiert sind.\nEin gutes Beispiel daf√ºr sind verkettete Listen:</p><pre><code>-- Purescript\nList a = Nil | Cons a ( List a )\n</code></pre>\n<p><code>Nil</code> ist der gebr√§uchliche Name f√ºr die leere Liste.  Das hat\nhistorische Gr√ºnde.  <code>Cons</code> nimmt einen Wert und eine Liste und\nkonstruiert daraus wieder eine Liste.  Die Idee dabei ist, dass man\nmit der leeren Liste beginnt und von ihr ausgehend <code>Cons</code> verwendet\nund durch das sukzessive Hinzuf√ºgen weiterer Werte immer gr√∂√üere\nListen konstruiert.  Hier demonstrieren wir schrittweise den Aufbau\neiner Liste mit den ersten Ziffern der Kreiszahl Pi 3,1415‚Ä¶</p><pre><code>-- Purescript\n\nlist0 = Nil\nlist1 = Cons 5 Nil\nlist2 = Cons 1 ( Cons 5 Nil )\nlist3 = Cons 4 ( Cons 1 ( Cons 5 Nil ) )\nlist4 = Cons 1 ( Cons 4 ( Cons 1 ( Cons 5 Nil ) ) )\nlist5 = Cons 3 ( Cons 1 ( Cons 4 ( Cons 1 ( Cons 5 Nil ) ) ) )\n</code></pre>\n<p>Haskell unterst√ºtzt f√ºr verkettete Listen eine kompaktere und\nfreundlichere Syntax, mit der man z.B. <code>list5</code> schreiben kann\nals <code>[3,1,4,1,5]</code>.  Aber letztlich erfolgt die Konstruktion von\nverketteten Listen auch in Haskell genau so wie oben beschrieben.</p><p><code>List a</code> ist generisch (bzw. parametrisch).  Diese Beispiele haben\nallesamt den Datentyp <code>List Int</code>.  Nat√ºrlich k√∂nnen wir auch Listen\nvon Bools oder Floats oder Strings etc. konstruieren.  Die Werte\neiner Liste m√ºssen aber allesamt den selben Datentyp haben.</p><p>Aus der Definition des generischen Listendatentyps folgt, dass\nman aus einer Liste der Gr√∂√üe <code>n</code> immer eine Liste der Gr√∂√üe\n<code>n+1</code> konstruieren kann indem man noch ein Element hinzuf√ºgt.\nDaraus ergibt sich, dass Listendatentypen unendlich gro√ü sind.\nDer Datentyp <code>String</code> ist in Standard-Haskell ein Typalias f√ºr\n<code>List Char</code> und damit auch unendlich gro√ü.  In Purescript werden\nStrings wahrscheinlich irgendwie auf Javascript-Strings abgebildet.\nAuch davon gibt es unendlich viele, da man sie durch Verkettung\nbeliebig verl√§ngern kann.</p><h2 id=\"einfache-datentypen-sind-adts\">Einfache Datentypen sind ADTs</h2>\n<p>Ich habe es hier noch nicht erw√§hnt, aber bestimmt ist es schon\naufgefallen: die Namen von Datentypen und von Wertekonstruktoren\nin einer Typdefinition mit dem <code>data</code> Schl√ºsselwort beginnen in\nHaskell und in Purescript immer mit einem Gro√übuchstaben.  In Elm\nist es auch so, mit dem Unterschied, dass das Schl√ºsselwort in\nElm nicht <code>data</code>  sondern <code>type</code> ist.</p><p>W√§hrend f√ºr den Datentyp <code>Bool</code> mit den Werten <code>False</code>\nund <code>True</code> in Haskell eine normale Typdefinition <a href=\"https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Types.html#Bool\">vordefiniert\nist</a>,\nist der Datentyp <code>Boolean</code> mit den Werten <code>false</code> und <code>true</code>\nin Purescript in den Compiler integriert.  Purescript ist\ndaf√ºr gemacht, nach Javascript zu compilieren.  Um die zu\n√ºberbr√ºckende Kluft zwischen den Purescript-Datentypen und den\nJavascript-Datentypen, die nach der Compilation √ºbrigbleiben,\nm√∂glichst klein zu halten, orientieren sich die vordefinierten\nDatentypen in Purescript an den Datentypen, die auch in Javascript\nverf√ºgbar sind.  Deswegen gibt es in Purescript statt <code>Bool</code>\nden Datentyp <code>Boolean</code> mit den Werten <code>false</code> und <code>true</code>, die vom\nCompiler in die gleichnamigen Javascript-Werte <code>false</code> und <code>true</code>\n√ºbersetzt werden.  Das gleiche macht der Purescript-Compiler mit\nZahlenliteralen, Arrays und Records.</p><p>Trotz der Sonderbehandlung durch den Compiler, h√§tte man die\nWahrheitswerte auch in Purescript <code>False</code> und <code>True</code> nennen k√∂nnen.\nIch vermute, dass man sich bewusst f√ºr die Kleinschreibung\nentschieden hat, um kenntlich zu machen, dass es sich um keine\ngew√∂hnlichen Wertekonstruktoren aus einer <code>data</code> Typdefinition\nhandelt.</p><p>Es gibt noch mehr vordefinierte Datentypen ‚Äì auch in Haskell\n‚Äì deren Werte nicht √ºber eine herk√∂mmliche Typdefinition mit\nWertekonstruktoren erzeugt worden sind, sondern auf besondere Weise\nvom Compiler unterst√ºtzt werden.  Die numerischen Datentypen sind\ndas beste Beispiel daf√ºr.  Eine Sonderbehandlung numerischer\nDatentypen und Werte durch den Compiler ist schon f√ºr die\nsyntaktische Unterst√ºtzung der gew√∂hnlichen Zahlenliterale wie\n<code>-123.45</code>, <code>0.0</code> und <code>99999</code> n√∂tig, aber auch f√ºr die effiziente\nArithmetik auf diesen Datentypen.</p><p>In Haskell kommt noch dazu, dass Zahlenliterale wie <code>1</code> und <code>1.0</code>\n√ºberladen sind.  <code>1</code> kann in Haskell sowohl f√ºr den <code>Int</code> Wert\n<code>1</code> als auch f√ºr den <code>Float</code> wert <code>1.0</code> stehen.  Es kommen sogar\nnoch weitere Datentypen in Frage:</p><pre><code>-- Haskell Repl\n\n&gt; 1 :: Int\n1\n\n&gt; 1 :: Integer\n1\n\n&gt; 1 :: Float\n1.0\n\n&gt; 1 :: Double\n1.0\n\n&gt; import Numeric.Natural\n\n&gt; 1 :: Natural\n1\n</code></pre>\n<p><code>Integer</code> ist ein Datentyp f√ºr ganze Zahlen, der beliebig gro√üe\nZahlen aufnehmen kann, solange der Speicherplatz es zul√§sst.\n<code>Natural</code> ist ein Datentyp f√ºr nat√ºrliche Zahlen.  Zahlenliterale\nin Gleitkommaschreibweise sind in Haskell ebenso √ºberladen:</p><pre><code>-- Haskell Repl\n\n&gt; 1.0 :: Int\n1\n\n&gt; 1.0 :: Integer\n1\n\n&gt; 1.0 :: Float\n1.0\n\n&gt; 1.0 :: Double\n1.0\n\n&gt; import Numeric.Natural\n\n&gt; 1.0 :: Natural\n1\n</code></pre>\n<p>Trotz ihrer Besonderheiten, k√∂nnen wir solche Datentypen auch\nals ADTs auffassen.  Die Wahrheitswerte <code>false</code> und <code>true</code>\nwerden in Purescript zwar klein geschrieben, aber das ist\nnur Syntax.  Davon abgesehen k√∂nnen wir komplett ignorieren,\ndass der Datentyp <code>Boolean</code> nicht auf einer herk√∂mmlichen <code>data</code>\nTypdefinition basiert.  Es folgt daraus nichts, worauf wir beim\nProgrammieren achtgeben m√ºssten.  So ist es auch mit den numerischen\nDatentypen: Zahlenliterale wie <code>-3.1415</code> und <code>42</code> sind zwar keine\ngew√∂hnlichen Wertekonstruktoren, aber wir k√∂nnen jeden numerischen\nDatentyp auffassen als einen Summentyp mit all seinen Werten als\nWertekonstruktoren ohne Typfelder:</p><pre><code>-- Pseudo-Haskell\ndata Natural = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | ...\n</code></pre>\n<p>Prinzipiell k√∂nnten wir die ganzen numerischen Datentypen\nund die gesamte Zahlenarithmetik auch aus gew√∂hnlichen <code>data</code>\nTypdefinitionen nachbauen.  Wir m√ºssen uns daf√ºr nur streng an\ndie Konstruktionsregeln halten.  F√ºr nat√ºrliche Zahlen sind das\ndie Peano-Axiome.  Ein selbstgebauter Datentyp f√ºr nat√ºrliche\nZahlen k√∂nnte so aussehen:</p><pre><code>-- Haskell\n\ndata Nat = Null | Nachfolger Nat\n\nplus :: Nat -&gt; Nat -&gt; Nat\nplus a b = case a of\n    Nachfolger n -&gt; plus n ( Nachfolger b ) \n    Null -&gt; b\n\nmal :: Nat -&gt; Nat -&gt; Nat\nmal a b = case a of\n    Null -&gt; Null\n    Nachfolger Null -&gt; b\n    Nachfolger n -&gt; plus b ( mal n b )\n</code></pre>\n<p>F√ºr fast alle praktischen Anwendungen w√§re das v√∂llig unbrauchbar.\nOhne die spezielle Syntax f√ºr Zahlenliterale w√§re es sehr sehr\numst√§ndlich und m√ºhsam, Zahlen aufzuschreiben und zu lesen.\nDie Zahlenarithmetik w√§re damit unendlich langsam.  Worum es mir\nhier geht, ist, dass sich numerische Datentypen, Arrays, Records,\nStrings usw. zumindest rein formal auch als algebraische Datentypen\nauffassen lassen.  Das verdeutlicht, wie flexibel ADTs sind: jeder\nDatentyp, der sich als ein Summentyp aus Produkttypen darstellen\nl√§sst, kann als ADT beschrieben werden.</p><h2 id=\"isomorphismen-und-aliase\">Isomorphismen und Aliase</h2>\n<p>Bisher haben wir neue Datentypen mit dem <code>data</code> Schl√ºsselwort\ndefiniert.  Wir k√∂nnten es dabei belassen.  Es gibt aber noch zwei\nweitere Schl√ºsselw√∂rter, mit denen sich Datentypen definieren\nlassen: <code>newtype</code> und <code>type</code>.</p><p><strong>Isomorphismen</strong></p><p>Mit dem <code>newtype</code> Schl√ºsselwort lassen sich neue Datentypen\ndefinieren, die genau einen Wertekonstruktor mit genau einem Feld\nhaben.  Damit ist <code>newtype</code> auf den ersten Blick √ºberfl√ºssig, denn\ndasselbe k√∂nnen wir auch mit dem <code>data</code> Schl√ºsselwort erledigen:</p><pre><code>-- Haskell\ndata T1 = K1 Bool\nnewtype T2 = K2 Bool\n</code></pre>\n<p>Wenn man dasselbe auch mit dem <code>data</code> Schl√ºsselwort machen kann,\nwarum gibt es dann f√ºr diesen Spezialfall ein zus√§tzliches\nSchl√ºsselwort?  Um das beanworten zu k√∂nnen, m√ºssen wir wissen,\ndass die Verwendung von Datentypen mit gewissen Laufzeitkosten\nverbunden ist.  Beispielsweise einen <code>Int</code> Wert in einen <code>Maybe</code>\nKontext zu stecken und an anderer Stelle wieder aus diesem\n<code>Maybe</code> Kontext zu befreien: das sind Rechenoperationen, die\nzur Laufzeit des Programms stattfinden und ein kleines bisschen\nSpeicher und Rechenzeit kosten.  Wir nehmen das normalerweise gern\nin Kauf, weil uns ein korrektes Programm ohne Laufzeitfehler in den\nmeisten F√§llen viel wichtiger ist als ein Programm, das m√∂glichst\nschnell und speichereffizient arbeitet, aber der Sonderfall eines\nDatentyps <code>T</code> aus genau einem Wertekonstruktor mit genau einem\nFeld ist hier deswegen interessant, weil bei so einem Datentyp eine\nEins-zu-eins-Beziehung zwischen den Werten von <code>T</code> und den Werten\ndes Feldtyps besteht.  Hier ein Beispiel:</p><pre><code>-- Haskell\ndata WrapInt = Wrap Int\n</code></pre>\n<p>Dann gilt die Eins-zu-eins-Beziehung:</p><pre><code>...\nWrap -3 &lt;--&gt; -3 \nWrap -2 &lt;--&gt; -2 \nWrap -1 &lt;--&gt; -1 \nWrap 0  &lt;--&gt; 0 \nWrap 1  &lt;--&gt; 1 \nWrap 2  &lt;--&gt; 2 \nWrap 3  &lt;--&gt; 3 \nWrap 4  &lt;--&gt; 4 \nWrap 5  &lt;--&gt; 5 \nWrap 6  &lt;--&gt; 6 \nWrap 7  &lt;--&gt; 7 \n...\n</code></pre>\n<p>In der Mathematik nennt man so eine Eins-zu-eins-Beziehung einen\nIsomorphismus.  Wenn ein Isomorphismus zwischen Datentypen besteht,\nist es schade um den Speicher und die Rechenzeit, die es zur\nLaufzeit des Programms kostet, Werte zwischen diesen Datentypen\nzu konvertieren.  Hier kommt <code>newtype</code> ins Spiel.  Ein Beispiel:</p><pre><code>-- Haskell\nnewtype Password = Password String\n</code></pre>\n<p>Es kann sinnvoll sein, f√ºr Passw√∂rter einen eigenen Datentyp\neinzuf√ºhren.  Am Ende ist nat√ºrlich jedes Passwort einfach nur\nein String, aber wenn wir auf der Typebene zwischen <code>String</code> und\n<code>Password</code> streng unterscheiden, k√∂nnen wir z.B. die Erzeugung von\nschlechen Passw√∂rtern verhindern.  Daf√ºr legen wir ein eigenes\nModul an, das den Datentyp <code>Password</code> und bspw. eine sorgf√§ltig\ngeschriebene Funktion <code>makePassword : IO Password</code> enth√§lt.  Der\nentscheidende Trick ist, dass wir den Wertekonstruktor <code>Password</code>\nnicht exportieren.  Dadurch ist Code au√üerhalb dieses Moduls\ngezwungen, die Funktion <code>makePassword</code> zu verwenden, um an einen\n<code>Password</code> Wert zu kommen.</p><p>Wir k√∂nnen semantisch (fast) exakt dasselbe auch mit dem <code>data</code>\nSchl√ºsselwort erreichen, aber wenn wir das <code>newtype</code> Schl√ºsselwort\nverwenden, entfernt der Compiler alle <code>Password</code> Wertekonstruktoren,\nso dass zur Laufzeit des Programms nur noch gew√∂hnliche <code>String</code>\nWerte √ºbrigbleiben.  Dadurch entfallen der Speicher und die\nRechenzeit, die es sonst zur Laufzeit des Programms gekostet h√§tte,\nWerte zwischen diesen Datentypen zu konvertieren.</p><p><em>√úbrigens gibt es doch einen semantischen Unterschied zwischen\n<code>data</code> und <code>newtype</code>, der die Auswertungsstrategie betrifft:\nWertekonstruktoren werden bei <code>data</code> verz√∂gert ausgewertet und bei\n<code>newtype</code> strikt ausgewertet.  Was das bedeutet, m√∂chte ich hier\nnicht erl√§utern.  Der Text ist schon lang genug und der Unterschied\nist ohnehin marginal: beide Auswertungsstrategien f√ºhren auf den\ngleichen Wert, wenn sie erfolgreich auswerten.  Es gibt aber F√§lle\nin denen die verz√∂gerte Auswertung Erfolg hat aber die strikte\nAuswertung scheitert.  Daher der semantische Unterschied.</em></p><p><strong>Aliase</strong></p><p>Das <code>type</code> Schl√ºsselwort f√ºhrt einen Typalias bzw. ein\nTypsynonym ein.  Das ist einfach nur ein weiterer Name f√ºr einen\nexistierenden Datentyp.  Beispielsweise sind herk√∂mmliche Strings\nin Haskell nichts weiter als verlinkte Listen von <code>Char</code> Werten.\nEntsprechend ist der Datentyp <code>String</code> wie folgt definiert:</p><pre><code>-- Haskell\ntype String = List Char\n</code></pre>\n<p>Das Beispiel <a href=\"https://hackage.haskell.org/package/base-4.18.0.0/docs/src/GHC.Base.html#String\">stimmt nicht\nganz</a>:\nder Datentyp <code>List Char</code> wird in idiomatischem Haskell als <code>[Char]</code>\ngeschrieben.  Darauf m√∂chte ich hier aber nicht n√§her eingehen.\nLeider gibt es in Haskell ein paar Schrulligkeiten wie diese, die die\nSprache unn√∂tig und ohne substaniellen Mehrwert verkomplizieren.\nDeswegen bin ich wirklich froh, dass es mittlerweile Alternativen\nwie Purescript gibt.</p><h2 id=\"typklassen\">Typklassen</h2>\n<p>Typklassen werden unterst√ºtzt in Haskell und in Purescript.\nSie haben nichts zu tun mit Klassen in der OOP.  Ein Konzept\naus anderen Sprachen, das mit Typklassen vergleichbar ist, sind\nInterfaces.  Jede Typklasse benennt eine Reihe von Funktionen.\nEin Datentyp kann zu einer Typklasse hinzugef√ºgt werden, wenn er\nalle Funktionen der Typklasse implementiert.  Hier ein Beispiel\nf√ºr eine Typklasse mit einer zu implementierenden Funktion:</p><pre><code>-- Purscript\nclass Eq a where\n    eq :: a -&gt; a -&gt; Boolean\n</code></pre>\n<p>Ein Datentyp <code>a</code> der Klasse <code>Eq</code> muss also die Funktion <code>eq</code>\nimplementieren, die zwei Werte vom Datentyp <code>a</code> aufnimmt und einen\n<code>Boolean</code> Wert berechnet.  <code>Eq</code> (f√ºr equality) ist sowohl in\nPurescript als auch in Haskell eine vordefinierte Typklasse f√ºr\ndie Datentypen, auf denen die Gleichheitsfunktion <code>eq</code> bzw. der\nGleichheitsoperator <code>==</code> gegeben sein soll.</p><p>Eine Funktion, die wie <code>eq</code> auf mehreren Datentypen\noperieren kann, nennt man eine polymorphe Funktion.  Wenn der\nPolymorphismus √ºber Typklassen hergestellt wird, spricht man\nvon Typklassenpolymorphismus.  <em>Generisch</em>, <em>parametrisch</em> und\n<em>polymorph</em> sind hier eng verwandte Begriffe.  Wenn es um Datentypen\ngeht, spricht man von generischen oder parametrischen Datentypen.\nBei Funktionen spricht man von generischen oder polymorphen\nFunktionen.</p><p>Den Code f√ºr die <code>Eq</code> Typklasse im Purescript Prelude k√∂nnen wir\nhier nachlesen:</p><p><a href=\"https://github.com/purescript/purescript-prelude/blob/v6.0.1/src/Data/Eq.purs#L35-L36\">https://github.com/purescript/purescript-prelude/blob/v6.0.1/src/Data/Eq.purs#L35-L36</a></p><p>Er stimmt mit der oben angegebenen Definition √ºberein.  Direkt\ndarunter befindet sich die Definition f√ºr den Gleichheitsoperator:</p><pre><code>infix 4 eq as ==\n</code></pre>\n<p>Die Zeile legt fest, dass der Infix-Operator <code>==</code> ein Alias f√ºr\ndie Funktion <code>eq</code> ist und in der Operatorrangfolge an vierter\nStelle steht.  Wenn <code>==</code> ein Alias f√ºr <code>eq</code> ist und <code>eq</code> eine\nFunktion der Typklasse <code>Eq</code> ist, dann muss ein Datentyp die Klasse\n<code>Eq</code> implementieren, damit der Operator <code>==</code> f√ºr seine Werte\nverf√ºgbar ist.  Probieren wir das aus:</p><pre><code>-- Purescript Repl\n\n&gt; 123 == 123\ntrue\n\n&gt; 123 == 124\nfalse\n\n&gt; &quot;abc&quot; == &quot;abc&quot;\ntrue\n\n&gt; &quot;abc&quot; == &quot;bcd&quot;\nfalse\n\n&gt; false == false\ntrue\n\n&gt; false == true\nfalse\n</code></pre>\n<p>Demnach implementieren die Datentypen <code>Int</code>, <code>String</code> und <code>Boolean</code>\ndie Typklasse <code>Eq</code>.  Unser selbst definierter Datentyp <code>Bool</code>\nimplementiert <code>Eq</code> noch nicht:</p><pre><code>-- Purescript Repl\n\n&gt; data Bool = False | True\n\n&gt; False == False\n...\nNo type class instance was found for\n\n  Data.Eq.Eq Bool\n...\n</code></pre>\n<p>Das k√∂nnen wir aber mit einer Instanzdeklaration nachholen.\nMit einer Instanzdeklaration f√ºgt man einen Datentyp zu einer\nTypklasse hinzu.  Anschlie√üend kann man die Funktionen und\nOperatoren der Typklasse auf Werte von diesem Datentyp anwenden:</p><pre><code>-- Purescript\n\ninstance Eq Bool where\n    eq a b = case [a,b] of\n        [False,False] -&gt; true\n        [True,True] -&gt; true\n        _ -&gt;false\n\n-- Purescript Repl\n\n&gt; False == False\ntrue\n</code></pre>\n<p>Damit ist gekl√§rt, was Typklassen sind: ein Formalismus um\npolymorphe Funktionen zu beschreiben.  Oft h√§ngt an den Funktionen\neiner Typklasse eine bestimmte Erwartungshaltung hinsichtlich ihrer\nSemantik, die vom Typsystem nicht erfasst wird.  Beispielsweise\nh√§tten wir <code>eq</code> auch so angeben k√∂nnen:</p><pre><code>-- Purescript\n\neq a b = case [a,b] of\n    [False,False] -&gt; False\n    [True,True] -&gt; False\n    _ -&gt;True\n</code></pre>\n<p>Damit w√ºrde <code>eq</code> nicht mehr auf Gleichheit pr√ºfen sondern\nauf Ungleichheit.  Der Compiler w√ºrde die Definition trotzdem\nakzeptieren, weil der Datentyp passt.  Aber der Gleichheitsoperator\n<code>==</code> w√ºrde sich f√ºr diesen Datentyp anders verhalten als erwartet\nund damit f√ºr reichlich Verwirrung sorgen.</p><p>Man kann zwischen Typklassen auch Abh√§ngigkeiten definieren:</p><pre><code>-- Purescript\nclass (A T, B T, C T) &lt;= D T ...\n</code></pre>\n<p>Das bedeutet, dass ein Datentyp <code>T</code> nur dann zur Typklasse <code>D</code>\ngeh√∂ren kann, wenn er auch zu den Typklassen <code>A</code>, <code>B</code> und <code>C</code>\ngeh√∂rt.  In Haskell sind solche Abh√§ngigkeiten auch m√∂glich.\nDie Syntax ist fast identisch.  Nur der Doppelpfeil wird in Haskell\numgekehrt notiert: <code>=&gt;</code>.  Wenn links vom Pfeil nur eine Typklasse\nsteht, k√∂nnen die Klammern entfallen.</p><p>Elm unterst√ºtzt keine Typklassen.  In Haskell und Purescript sind\nzum Beispiel die arithmetischen Operatoren auf den verschiedenen\nnumerischen Datentypen √ºber Typklassen implementiert:</p><pre><code>-- Purescript Repl\n\n&gt; :type (+)\nforall (a :: Type). Semiring a =&gt; a -&gt; a -&gt; a\n\n&gt; :type (-)\nforall (a :: Type). Ring a =&gt; a -&gt; a -&gt; a\n\n&gt; :type (*)\nforall (a :: Type). Semiring a =&gt; a -&gt; a -&gt; a\n\n&gt; :type (/)\nforall (a :: Type). EuclideanRing a =&gt; a -&gt; a -&gt; a\n</code></pre>\n<p>Demnach ist der Operator <code>+</code> in Purescript auf den Datentypen\ngegeben, die zur Typklasse <code>Semiring</code> geh√∂ren, der Operator\n<code>-</code> auf den Datentypen, die zur Typklasse <code>Ring</code> geh√∂ren, usw.\nSowohl Haskell als auch Purescript haben eine mathematisch\ninteressante Typklassenhierarchie, aber wenn man sich f√ºr\nBegriffe wie <em>Halbring</em>, <em>Ring</em> und <em>euklidischer Ring</em> nicht\ninteressiert, kann man sie ignorieren: sich mit diesen Begriffen\nherumzuschlagen, ist <strong>keine</strong> Voraussetzung daf√ºr, in diesen\nSprachen zu programmieren!!!</p><p>Typische Idiome der funktionalen Programmierung, wie <code>map</code>, <code>foldr</code>,\n<code>foldl</code>, <code>traverse</code>, oder der monadische <em>bind</em> Operator <code>&gt;&gt;=</code> sind\nebenfalls √ºber entsprechende Typklassen als polymorphe Funktionen\ndefiniert.  Hier operiert <code>map</code> auf zwei verschiedenen Datentypen:</p><pre><code>-- Purescript Repl\n\n&gt; map (_*2) [1,2,3]\n[2,4,6]\n\n&gt; import Data.Maybe\n\n&gt; map (_*2) (Just 3)\n(Just 6)\n</code></pre>\n<p>Es kommt selten vor, dass ich eigene Typklassen schreibe, weil es\nmir produktiver erscheint, konkreten Code zu schreiben und dabei\nnicht dar√ºber nachzudenken, wo sich strukturelle √úbereinstimmungen\nverbergen k√∂nnten, aus denen sich vielleicht polymorphe Funktionen\nableiten lassen.  Probleme, bei denen ich Typklassen vielleicht\neinsetzen w√ºrde, sind Serialisierung und Persistenz.  Beispielsweise\nk√∂nnte die Serialisierung und Deserialisierung zwischen einem\nDatentyp <code>a</code> und Json √ºber zwei polymorphe Funktionen ablaufen:</p><pre><code>-- Purescript\nclass JsonSerializable a where\n    toJson :: a -&gt; String\n    fromJson :: String -&gt; Maybe a\n</code></pre>\n<p>Dazu w√ºrde ich noch fordern, dass f√ºr alle Instanzdeklarationen\ngelten sollte:</p><pre><code>fromJson ( toJson value ) == Just value\nmap toJson ( fromJson string ) == Just string\n</code></pre>\n<p>Diese Regeln kann man zwar nicht vom Compiler absichern lassen,\naber eine <code>JsonSerializable</code> Instanz, die sie nicht einh√§lt,\nist offensichtlich unbrauchbar.</p><p>Eine Typklasse f√ºr die Persistenz in einer Datenbank k√∂nnte\nso aussehen:</p><pre><code>-- Haskell\nclass Db a where\n    insert :: a -&gt; IO String\n    update :: String -&gt; a -&gt; IO ()\n    read :: String -&gt; IO ( Maybe a )\n</code></pre>\n<p>Ich muss unbedingt dazusagen, dass ich mir dar√ºber maximal drei\nMinuten Gedanken gemacht habe.  Es ist sehr wahrscheinlich, dass\nich hier irgendetwas entscheidendes vergessen oder √ºbersehen habe.\nAls Beispiel sollte uns das an dieser Stelle trotzdem gen√ºgen.\nIch beschreibe kurz die Funktionen:</p><ul>\n<li><code>insert</code> persistiert einen Wert vom Datentyp <code>a</code> als neuen Record\nin der Datenbank und liefert einen String, den wir sp√§ter als\nSchl√ºssel verwenden k√∂nnen, um diesen Wert zu aktualisieren\noder wieder auszulesen.</li>\n<li><code>update</code> nimmt einen String als Schl√ºssel entgegen und\naktualisiert den entsprechenden Record in der Datenbank mit einem\nWert vom Datentyp <code>a</code>.</li>\n<li><code>read</code> nimmt einen Schl√ºssel entgegen und liefert den\nentsprechenden Wert vom Datentyp <code>a</code> aus der Datenbank.  Weil wir\nnicht garantieren k√∂nnen, dass jeder Schl√ºssel auf einen\ng√ºltigen Record in der Datenbank verweist, ist dieser Wert in\neinen <code>Maybe</code> Kontext eingeschlossen.</li>\n</ul>\n<p>Ich h√§tte wirklich Lust, herauszufinden, ob das ein gutes Design\noder zu naiv ist, aber erst muss ich diesen Text fertig schreiben.</p><p>Im n√§chsten Abschnitt gehe ich auf Multiparameter-Typklassen ein.\nVorher m√∂chte ich noch eine Bemerkung zu Typklassen im Allgemeinen\nloswerden: Typklassenpolymorphie ist ein produktives Konzept,\naber es lohnt sich nicht immer, auf Typklassen und polymorphe\nFunktionen zu setzen.  Wenn die Polymorphie einem formalen Kalk√ºl\nfolgt, so wie es bei der Typklasse <code>Eq</code> und bei den arithmetischen\nOperationen der Fall ist, oder wenn es darum geht, Datentypen um\nFunktionalit√§t zu erweitern wie bei der Typklasse <code>JsonSerialize</code>,\ndann sind Typklassen sinnvoll.  Aber man sollte nicht versuchen,\nTypklassenpolymorphie zu erzwingen: manchmal ist der Code besser\nohne Typklassen.  Elm kommt ganz ohne Typklassen aus.</p><h2 id=\"multiparameter-typklassen\">Multiparameter-Typklassen</h2>\n<p><em>Eine Vorbemerkung: Man muss bei den Programmierkonzepten der\nTypebene, die ich hier vorstelle, ein bisschen darauf achten, dass\nman den Ball flach h√§lt.  Wenn man mit einem vordefinierten Datentyp\ngut auskommt, muss man daf√ºr keinen ADT definieren.  Wenn es keinen\nGrund daf√ºr gibt, einen parametrischen ADT zu definieren, sollte\nman es bei einem parameterlosen ADT belassen.  Wenn man sich nicht\nganz sicher ist, ob man eine polymorphe oder mehrere monomorphe\nFunktionen definieren sollte, ist es besser, auf Polymorphie zu\nverzichten.  Dieser Appell gilt umso mehr f√ºr die Konzepte, die\njetzt folgen.  Mit einem guten Verst√§ndnis f√ºr ADTs, parametrische\nADTs und einfache Typklassen ist man schon sehr gut aufgestellt.\nSolange man diese Konzepte nicht richtig verinnerlicht hat, muss\nman sich mit den Konzepten, die jetzt noch folgen, nicht befassen.</em></p><p>Typklassen k√∂nnen mehr als einen Typparameter haben.  Auf die Weise\nk√∂nnen die polymorphen Funktionen einer Typklasse Beziehungen\nzwischen Datentypen beschreiben.  Die Typklasse <code>Db</code> von gerade\neben bietet sich an, um zu zeigen, wof√ºr das n√ºtzlich sein kann.\nMich st√∂rt an dieser Typklasse ein bisschen, dass der Datentyp f√ºr\ndie Schl√ºssel auf <code>String</code> festgelegt ist.  Warum nicht <code>Int</code>? Oder\nein spezieller Datentyp <code>Uuid</code> f√ºr sogenannte <em>Universally Unique\nIdentifiers</em>?  Also erweitern wir diese einfache Typklasse zu einer\nTypklasse mit zwei Typparametern:</p><pre><code>-- Haskell\nclass Db key value where\n    insert :: value -&gt; IO key\n    update :: key -&gt; value -&gt; IO ()\n    read :: key -&gt; IO ( Maybe value )\n</code></pre>\n<p>Auf diese Weise sind wir f√ºr die Schl√ºssel nicht auf den Datentyp\n<code>String</code> festgelegt, sondern k√∂nnen daf√ºr einen Datentyp frei\nw√§hlen.  Hier noch ein Beispiel f√ºr eine Multiparameter-Typklasse\naus dem Purescript-Buch:</p><pre><code>-- Purescript\nclass Stream stream element where\n    uncons :: stream -&gt; Maybe { head :: element , tail :: stream }\n</code></pre>\n<p>Die Idee dabei ist, dass ein Wert vom Datentyp <code>stream</code> ein\nDatenstrom aus Werten vom Datentyp <code>element</code> ist.  Die Funktion\n<code>uncons</code> trennt diesen Datenstrom auf in den ersten Wert (<code>head</code>)\nund den Rest des Datenstroms (<code>tail</code>).  Auf die Weise lassen sich die\nWerte in einem Datenstrom durch wiederholtes Aufrufen von <code>uncons</code>\nder Reihe nach verarbeiten.  Sobald der Datenstrom leer ist, liefert\n<code>uncons</code> den Wert <code>Nothing</code>.  Wir f√ºgen die Datentypen <code>String</code>\nund <code>Char</code> zur Typklasse <code>Stream</code> hinzu, indem wir eine passende\n<code>uncons</code> Funktion angeben:</p><pre><code>-- Purescript\ninstance Stream String Char where\n    uncons = String.uncons\n</code></pre>\n<p>Dass die Funktion <code>String.uncons</code> hier genau passt, ist g√ºnstig\nf√ºr uns.  Als n√§chstes f√ºgen wir den generischen Datentyp <code>Array a</code> zusammen mit dem entsprechenden Datentyp <code>a</code> zur Typklasse\n<code>Stream</code> hinzu.  Auch hier gibt es wieder eine passende <code>uncons</code>\nFunktion f√ºr Arrays:</p><pre><code>-- Purescript\ninstance Stream ( Array a ) a where\n    uncons = Array.uncons\n</code></pre>\n<p>Jetzt k√∂nnen wir mit der polymorphen <code>uncons</code> Funktion der <code>Stream</code>\nTypklasse sowohl <code>Char</code> Werte aus <code>String</code> Datenstr√∂men als auch\n<code>a</code> Werte aus <code>Array a</code> Datenstr√∂men entnehmen.</p><h2 id=\"funktionale-abh√§ngigkeiten\">Funktionale Abh√§ngigkeiten</h2>\n<p>Es w√§re jetzt naheliegend, aus <code>uncons</code> eine <code>tail</code> Funktion\nabzuleiten:</p><pre><code>-- Purescript\ntail :: String -&gt; Maybe String\ntail stream = map _.tail ( uncons stream )\n</code></pre>\n<p>Wir wenden erst <code>uncons</code> auf das Argument an.  Dann wenden\nwir die Feldfunktion <code>_.tail</code> auf das Zwischenergebnis an.\nDas Zwischenergebnis ist in einen <code>Maybe</code> Kontext eingebettet.\nDeswegen m√ºssen wir <code>map</code> einsetzen, um die Feldfunktion auf den\nWert im Kontext anzuwenden.  Das ist eine sinnvolle Definition.\nTrotzdem ist der Compiler nicht mit ihr zufrieden:</p><pre><code>No type class instance was found for Main.Stream String t\n</code></pre>\n<p>Was funktioniert hier nicht?  Daf√ºr m√ºssen wir (ganz grob)\nverstehen, wie der Compiler mit polymorphen Funktionen umgeht.  Die\nbeiden Instanzdeklarationen haben wir nicht ohne Grund hinzugef√ºgt.\nWenn wir die polymorphe Funktion <code>uncons</code> aufrufen, versucht der\nCompiler, die passenden Datentypen zu ermitteln, um pr√ºfen zu\nk√∂nnen, ob ihm f√ºr diese Datentypen eine Instanzdeklaration\nbekannt ist.  Wir wollen hier nat√ºrlich auf die Instanz <code>Stream String Char</code> hinaus.  Ein Blick in obige Fehlermeldung verr√§t,\ndass die Typinferenz bei <code>Stream String t</code> h√§ngen bleibt.\nDer Compiler ist offenbar nicht in der Lage, f√ºr den Typparameter\n<code>t</code> zu inferieren, dass es sich um den Datentyp <code>Char</code> handeln muss.\nIch wei√ü nicht, wo genau es klemmt, aber es stimmt, dass wir bei der\nDefinition unserer neuen <code>tail</code> Funktion dem Compiler nirgendwo einen\nHinweis darauf geben, dass es sich bei <code>t</code> um <code>Char</code> handeln muss.</p><p>Wenn wir das polymorphe <code>uncons</code> durch <code>String.uncons</code> ersetzen,\nist der Compiler zufrieden, aber dann k√∂nnen wir uns die Typklasse\ngleich sparen.  Wenn wir <code>uncons</code> um eine Typannotation erg√§nzen,\ndie ausdr√ºcklich auf <code>Char</code> hinweist, ist der Compiler ebenfalls\nzufrieden:</p><pre><code>-- Purescript\ntail :: String -&gt; Maybe String\ntail stream = do\n    let f :: String -&gt; Maybe { head :: Char , tail :: _ }\n        f = uncons\n    map _.tail ( f stream )\n</code></pre>\n<p>Aber sch√∂n oder sinnvoll ist das auch nicht.  Welchen Wert hat\ndie Typklassenpolymorphie, wenn wir sie erst einf√ºhren und sie\ndann zur H√§lfte wieder zur√ºcknehmen?</p><p>Interessanterweise k√∂nnen wir den Compiler auch zufriedenstellen,\nindem wir die Definition der Typklasse <code>Stream</code> wie folgt anpassen:</p><pre><code>-- Purescript\nclass Stream stream element | stream -&gt; element where\n    uncons :: stream -&gt; Maybe { head :: element , tail :: stream }\n</code></pre>\n<p>Hinzugekommen ist der Teil <code>| stream -&gt; element</code> vor dem <code>where</code>\nSchl√ºsselwort.  Man nennt das eine <em>funktionale Abh√§ngigkeit</em>.\nWir vereinbaren dadurch mit dem Compiler, dass sich aus dem Datentyp\nf√ºr den Typparameter <code>stream</code> stets eindeutig ergeben muss,\nwelcher Datentyp f√ºr den Typparameter <code>element</code> einzusetzen ist.\nDas hat bei mir zun√§chst f√ºr Kopfkratzen gesorgt.  Dann ist mir\naufgefallen, dass wir nur eine einzige Instanzdeklaration der Form\n<code>Stream String ...</code> angegeben haben, n√§mlich <code>Stream String Char</code>.\nDamit ist die funktionale Abh√§ngigkeit stets erf√ºllt wenn wir f√ºr\n<code>stream</code> den Datentyp <code>String</code> einsetzen: f√ºr <code>element</code> kommt dann\nnur der Datentyp <code>Char</code> in Frage.  Die andere Instanzdeklaration\n<code>Stream ( Array a ) a</code> erf√ºllt ebenfalls die Forderung nach\nfunktionaler Abh√§ngigkeit, denn wenn <code>Array a</code> (und damit <code>stream</code>)\nauf einen konkreten Datentyp festgelegt ist, dann ist auch <code>a</code>\nselbst (und damit <code>element</code>) eindeutig auf einen Datentyp festgelegt.\nDer Compiler ist damit zufriedengestellt solange wir keine weiteren\nInstanzdeklarationen hinzuf√ºgen, die diese Eindeutigkeit verletzen.</p><h2 id=\"verallgemeinerte-algebraische-datentypen-gadts\">Verallgemeinerte algebraische Datentypen (GADTs)</h2>\n<p>Weiter oben haben wir schon eine Verallgemeinerung der einfachen ADTs\nkenngenlernt: die parametrischen ADTs.  Verallgemeinerung bedeutet,\ndass das Verallgemeinerte zum Spezialfall des Verallgemeinernden\nwird.  Bei den parametrischen ADTs besteht der Spezialfall\neines einfachen, parameterlosen ADT darin, dass die Anzahl seiner\nTypparameter 0 ist: jeder parameterlose ADT ist ein parametrischer\nADT mit 0 Typparametern!</p><p>Die Sprache wird bei solchen Dingen oft etwas ungenau.  Wenn wir\nvon einem parametrischen ADT sprechen, meinen wir nat√ºrlich\neinen ADT mit mindestens einem Typparameter, sonst m√ºssten wir\nden allgemeineren Begriff nicht bem√ºhen.  Aber wenn jemand √ºber\neinen ADT sagt: <em>‚Äúdas ist kein parametrischer sondern ein einfacher\nADT‚Äù</em>, dann ist das genaugenommen ein Widerspruch und damit falsch.\nIm Gespr√§ch sollte man das nicht zum Anlass nehmen, gleich mit dem\nBelehrfinger zu fuchteln, aber man sollte im Hinterkopf behalten,\ndass genaugenommen der konkretere Begriff in dem allgemeineren\nBegriff enthalten ist.</p><p>GADTs (<em>generalized algebraic data types</em>) sind wiederum eine\nVerallgemeinerung der parametrischen ADTs.  Also ist jeder\nparameterlose und jeder parametrische ADT stets auch ein GADT.\nAber auch √ºber ADTs und GADTs wird h√§ufig so gesprochen als\nseien es disjunkte Konzepte.  Zum Beispiel enth√§lt der englische\nWikipedia-Artikel √ºber GADTs in seiner aktuellen Form (2023-06)\nden folgenden Code-Kommentar:</p><pre><code>-- A parametric ADT that is not a GADT\n</code></pre>\n<p>Im Haskell-Wiki und in der GHC-Dokumentation gibt es √§hnliche\nFormulierungen.  Das ist nicht schlimm, aber auch hier sollten\nwir im Hinterkopf behalten, dass formal der konkretere Begriff im\nallgemeineren Begriff enthalten ist.</p><p><strong>Neue Syntax</strong></p><p>GADTs bringen in Haskell neben der Verallgemeinerung auch eine\neigene Syntax mit.  Ich m√∂chte zun√§chst herk√∂mmliche ADTs in\ndieser GADT-Syntax aufschreiben.  Dann schauen wir uns an, worin\ngenau die Verallgemeinerung besteht.  Hier noch mal <code>Bool</code> in der\nherk√∂mmlichen ADT-Syntax:</p><pre><code>-- Haskell\ndata Bool\n    = False\n    | True\n</code></pre>\n<p>So w√ºrde man <code>Bool</code> in der GADT-Syntax schreiben:</p><pre><code>-- Haskell\ndata Bool where\n    False :: Bool\n    True :: Bool\n</code></pre>\n<p>Der <code>Ampel</code> Datentyp in herk√∂mmlicher ADT-Syntax:</p><pre><code>-- Haskell\ndata Ampel\n    = Gr√ºn\n    | Gelb\n    | Rot\n</code></pre>\n<p>Der <code>Ampel</code> Datentyp in GADT-Syntax:</p><pre><code>-- Ampel in GADT-Syntax\ndata Ampel where\n    Gr√ºn :: Ampel\n    Gelb :: Ampel\n    Rot :: Ampel\n</code></pre>\n<p>Herk√∂mmliche ADTs in GADT-Syntax aufzuschreiben, ist kein\nGedankenexperiment: die Beispiele sind g√ºltiger Haskell Code und\nk√∂nnen genau so verwendet werden.  Bei der GADT-Syntax f√§llt gleich\nauf, dass die Wertekonstruktoren mit Typannotationen versehen sind.\nBei parameterlosen ADTs in GADT-Syntax sind diese Typannotationen\n√ºberfl√ºssig: selbstverst√§ndlich haben hier alle Wertekonstruktoren\nden selben Datentyp.  Schauen wir uns als n√§chstes ein paar echte\nparametrische ADTs in GADT-Syntax an.  Hier noch mal <code>Maybe a</code>\nin der herk√∂mmlichen Syntax:</p><pre><code>-- Haskell\ndata Maybe a\n    = Nothing\n    | Just a\n</code></pre>\n<p>Zum Vergleich, <code>Maybe a</code> in GADT-Syntax:</p><pre><code>-- Haskell\ndata Maybe a where\n    Nothing :: Maybe a\n    Just :: a -&gt; Maybe a\n</code></pre>\n<p>Der Wertekonstrukor <code>Just</code> ist interessant.  Er hat den Datentyp\n<code>a -&gt; Maybe a</code>.  Das ist immer der Fall, auch wenn wir den Datentyp\nin der herk√∂mmlichen ADT-Syntax aufschreiben, aber hier schreiben\nwir den Datentyp explizit hin.  Hier noch mal der Datentyp <code>List</code>,\ndiesmal in Haskell:</p><pre><code>-- Haskell\nList a\n    = Nil\n    | Cons a ( List a )\n</code></pre>\n<p>In GADT-Syntax:</p><pre><code>-- Haskell\nList a where\n    Nil :: List a\n    Cons :: a -&gt; List a -&gt; List a\n</code></pre>\n<p>Die neue Syntax f√ºr GADTs ist ein Wink mit dem Zaunspfahl bzgl. der\nVerallgemeinerung, um die es geht.  Bei einem herk√∂mmlichen\nparametrischen ADT kann jeder Typparameter stets nur f√ºr alle\nWertekontruktoren gemeinsam auf einen Datentyp festgelegt werden.\nBei einem GADT kann jeder  Typparameter f√ºr verschiedene\nWertekonstruktoren auf verschiedene Datentypen festgelegt werden.\nHier ein GADT mit drei Wertekonstruktoren:</p><pre><code>-- Haskell\ndata MyGadt a where\n    MyInt :: Int -&gt; MyGadt Int\n    MyBool :: Bool -&gt; MyGadt Bool\n    MyString :: String -&gt; MyGadt String\n</code></pre>\n<p>Das besondere an einem GADT wie diesem ist, dass die\nWertekonstruktoren den Datentyp jeweils unterschiedlich\nkonkretisieren: der Wertekonstruktor <code>MyInt</code> erzeugt immer\neinen <code>MyGadt Int</code>, der Wertekonstruktor <code>MyBool</code> erzeugt\nimmer einen <code>MyGadt Bool</code> und der Wertekonstruktor <code>MyString</code>\nerzeugt immer einen <code>MyGadt String</code>.  Aber <code>MyGadt</code> hat nur diese\ndrei Wertekonstruktoren.  Daraus ergibt sich ein entscheidender\nSachverhalt: der Typparameter <code>a</code> kann hier konstruktionsbedingt\nnur die Datentypen <code>Int</code>, <code>Bool</code> oder <code>MyString</code> annehmen.</p><p>Bei einem GADT k√∂nnen wir die Typparameter durch seine\nWertekonstruktoren so einschr√§nken, dass konstruktionsbedingt\nnur noch ganz bestimme Datentypen auf die Typparameter passen.\nMehr noch: wir k√∂nnen die Wertekonstruktoren so entwerfen, dass\nsie Beziehungen zwischen den verschiedenen Konkretisierungen eines\ngenerischen Datentyps beschreiben.  Es ist ein bisschen so als\nw√ºrden wir mit einem GADT nicht nur einen Datentyp beschreiben,\nsondern eine ganze Gruppe von Datentypen und ihre Beziehungen\nzueinander.  Wer schon mal eine kleine formale Sprache entworfen\nund in eine Reihe von Datentypen gegossen hat oder einen Parser\nf√ºr eine formale Sprache geschrieben hat, m√ºsste hier hellh√∂rig\nwerden.  Tats√§chlich eignen sich GADTs sehr gut daf√ºr, DSLs oder\nganze Programmiersprachen zu beschreiben.  Grunds√§tzlich geht\ndas auch mit herk√∂mmlichen ADTs, aber mit GADTs lassen sich\nsolche Beschreibungen kompakter formulieren und mehr Invarianten\nauf der Typebene festhalten.  Als Beispiel daf√ºr schauen wir uns\ndie kleine arithmetische Sprache an, die der Wikipedia-Artikel zu\nGADTs enth√§lt:</p><pre><code>-- Haskell\ndata Expr a where\n    EInt :: Int -&gt; Expr Int\n    EBool :: Bool -&gt; Expr Bool\n    EEqual :: Expr Int -&gt; Expr Int -&gt; Expr Bool\n</code></pre>\n<p>Der Wertekonsturktor <code>EInt</code> erzeugt immer einen <code>Expr Int</code> Wert.\nDie Wertekonstruktoren <code>EBool</code> und <code>EEqual</code> erzeugen immer einen\n<code>Expr Bool</code> Wert.  Deswegen kann der Typparameter <code>a</code> hier nur die\nTypen <code>Int</code> und <code>Bool</code> annehmen.  Dazu geh√∂rt noch die <code>eval</code>\nFunktion, die einen <code>Expr a</code> Ausdruck in einen Wert vom Typ <code>a</code>\n√ºberf√ºhrt:</p><pre><code>-- Haskell\neval :: Expr a -&gt; a\neval expr = case expr of\n    EInt n -&gt; n\n    EBool b -&gt; b\n    EEqual a b -&gt; eval a == eval b\n</code></pre>\n<p>Damit sollte das folgende Programm <code>False</code> ausgeben:</p><pre><code>-- Haskell\nmain = do\n    let v1 = EInt 123\n    let v2 = EInt 124\n    let result = EEqual v1 v2\n    putStrLn ( show ( eval result ) )\n</code></pre>\n<p>Eine Sache, die mich ein bisschen daran st√∂rt, ist dass wir\n<code>EEqual</code> nicht auf <code>Expr Bool</code> Werte anwenden k√∂nnen.  Das ist\naber leicht behoben:</p><pre><code>-- Haskell\n\ndata Expr a where\n    EInt :: Int -&gt; Expr Int\n    EBool :: Bool -&gt; Expr Bool\n    EEqual :: Eq a =&gt; Expr a -&gt; Expr a -&gt; Expr Bool\n\neval :: Expr a -&gt; a\neval expr = case expr of\n    EInt n -&gt; n\n    EBool b -&gt; b\n    EEqual a b -&gt; eval a == eval b\n</code></pre>\n<p>Damit sollte auch das folgende Programm compilieren und <code>False</code>\nausgeben:</p><pre><code>-- Haskell\nmain = do\n    let v1 = EBool False\n    let v2 = EBool True\n    let result = EEqual v1 v2\n    putStrLn ( show ( eval result ) )\n</code></pre>\n<p>Wie w√ºrde man das ohne GADTs modellieren?  Keine Ahnung!  Aber wir\nk√∂nnen uns anschauen, was √ºbrigbleibt, wenn wir <code>Expr</code> auf einen\nparametrischen ADT reduzieren:</p><pre><code>-- Haskell\ndata Expr a\n    = EInt Int\n    | EBool Bool\n    | EEqual ( Expr a ) ( Expr a )\n</code></pre>\n<p>Wenn wir den so angepassten Datentyp in der GADT-Syntax aufschreiben,\nsehen wir besser, was sich ge√§ndert hat:</p><pre><code>-- Haskell\ndata Expr a where\n    EInt :: Int -&gt; Expr a\n    EBool :: Bool -&gt; Expr a\n    EEqual :: Expr a -&gt; Expr a -&gt; Expr a\n</code></pre>\n<p>Der Datentyp ist so v√∂llig unbrauchbar.  Es gibt jetzt keine\nBeziehung mehr zwischen dem Typparameter <code>a</code> und den Feldtypen von\n<code>EInt</code> und <code>EBool</code>:</p><pre><code>-- Haskell\n\nv1 :: Expr Int\nv1 = EBool True\n\nv2 :: Expr String\nv2 = EInt 123\n</code></pre>\n<p>Der Wertekonstruktor <code>EEqual</code> ist so auch unbrauchbar.  Wenn <code>EEqual</code>\neinen <code>Expr Bool</code> Wert erzeugen soll, muss er auch auf zwei <code>Expr Bool</code> Werten operieren.  Schauen wir uns trotzdem an, wie weit wir\nbei der <code>eval</code> Funktion kommen:</p><pre><code>-- Haskell\neval :: Expr a -&gt; a\neval expr = case expr of\n    EInt n -&gt; undefined\n    EBool b -&gt; undefined\n    EEqual e1 e2 -&gt; undefined\n</code></pre>\n<p>Was sollen wir z.B. f√ºr <code>EInt n</code> berechnen?  Der Wert <code>n</code> hat\nhier den Datentyp <code>Int</code>, aber <code>eval</code> operiert auf einem <code>Expr a</code>\nWert und erzeugt einen <code>a</code> Wert.  Wir br√§uchten eine Funktion\n<code>Int -&gt; a</code> f√ºr beliebige Datentypen <code>a</code>.  Das w√§re zwar rein\nformal m√∂glich (also typisierbar) aber wie sollen wir f√ºr jeden\nm√∂glichen Datentyp ad hoc und aus dem Nichts einen Wert herzaubern?\nDie gleiche Frage stellt sich f√ºr <code>EBool b</code>.  Bei <code>EEqual e1 e2</code> ist\ndas Problem noch gravierender, weil wir nur dann zu einem <code>Bool</code> Wert\nauswerten k√∂nnen, wenn <code>e1</code> und <code>e2</code> vom Datentyp <code>Expr Bool</code> sind.\nDie ganze Konstruktion ist also v√∂llig unbrauchbar.</p><p>Wenn wir <code>Expr</code> in einen parameterlosen ADT umbauen, kommt z.B. das\nheraus:</p><pre><code>-- Haskell\ndata Expr\n    = EInt Int\n    | EBool Bool\n    | EEqual Expr Expr\n</code></pre>\n<p>Das erscheint mir auf den ersten Blick schon sinnvoller.  Schauen wir\nuns an, wie <code>eval</code> aussehen k√∂nnte:</p><pre><code>-- Haskell\neval :: Expr -&gt; a\neval expr = case expr of\n    EInt n -&gt; undefined\n    EBool b -&gt; undefined\n    EEqual e1 e2 -&gt; case ( e1 , e2 ) of\n        ( EInt n1 , EInt n2 ) -&gt; undefined\n        ( EBool b1 , EBool b2 ) -&gt; undefined\n        _ -&gt; undefined\n</code></pre>\n<p>Das ist wieder eine Sackgasse.  Wir k√∂nnen <code>eval</code> zwar von <code>Expr -&gt; a</code> konkretisieren auf <code>Expr -&gt; Bool</code> oder auf <code>Expr -&gt; Int</code>,\naber das findet immer f√ºr die gesamte Funktion inklusive aller\nCase-Zweige statt.  Wir k√∂nnen nicht in einem Case-Zweig nach\n<code>Bool</code> und im n√§chsten nach <code>Int</code> auswerten.  √úberhaupt m√ºssen\nwir ja nach <code>a</code> auswerten, auch wenn f√ºr <code>a</code> weder <code>Bool</code> noch\n<code>Int</code> eingesetzt worden ist.  Wenn wir f√ºr <code>a</code> einen konketen\nWert einsetzen, wird die Sache einfacher.  F√ºr einige Anwendungen\ngen√ºgt sicherlich eine Funktion <code>eval :: Expr -&gt; String</code>:</p><pre><code>-- Haskell\neval :: Expr -&gt; String\neval expr = case expr of\n    EInt n -&gt; show n\n    EBool b -&gt; show b\n    EEqual e1 e2 -&gt; case ( e1 , e2 ) of\n        ( EInt n1 , EInt n2 ) -&gt; show ( n1 == n2 )\n        ( EBool b1 , EBool b2 ) -&gt; show ( b1 == b2 )\n        _ -&gt; show False\n</code></pre>\n<p>Andernfalls sehe ich nicht, wie man hier ohne GADTs auskommen\nk√∂nnte.  Ich hoffe, ich konnte demonstrieren, was man mit GADTs\nanstellen kann.  F√ºr mich ist das Konzept noch relativ neu.</p><h2 id=\"epilog\">Epilog</h2>\n<p>Dieser Text ist f√ºr mich in erster Linie eine Art Selbsttest:\nkann ich mein Verst√§ndnis der Konzepte, die ich hier vorstelle,\nausformulieren und aufschreiben, so dass ich hinterher damit\nzufrieden bin, auch wenn ich den Text zwischenzeitlich f√ºr ein\npaar Wochen beiseite gelegt habe?  Wenn nicht, werde ich weiter\ndaran arbeiten (sofern ich Zeit und Lust dazu habe).  Mein Bezug zu\ndiesem Thema ist ein praktischer.  Bisher bin ich noch nicht dazu\ngekommen, mich ernsthaft mit B√ºchern √ºber Typentheorie zu befassen.\nInsofern hoffe ich, dass sich hier kein Bl√∂dsinn eingeschlichen hat.\nDas w√§re mir wirklich peinlich.  Wenn der Text noch jemandem au√üer\nmir selbst nutzt, freut mich das umso mehr.</p>",
            "author": {
                "name": "Aram√≠s Concepci√≥n Dur√°n"
            },
            "tags": [
            ],
            "date_published": "2023-07-07T12:42:00+02:00",
            "date_modified": "2025-04-07T06:53:53+02:00"
        },
        {
            "id": "https://nojs.de/negation-in-haskell-und-purescript/",
            "url": "https://nojs.de/negation-in-haskell-und-purescript/",
            "title": "Negation in Haskell und Purescript",
            "content_html": "<p>Haskell fetzt!  Allerdings ist Haskell in seiner Nische (rein\nfunktionale ML-Sprachen) l√§ngst nicht mehr allein.  Die moderneren\nAbk√∂mmlinge dieser Familie bringen hier und da interessante\nVerbesserungen mit.  Ein sch√∂nes Beispiel daf√ºr ist die <code>not</code>\nFunktion in Purescript.</p><h2 id=\"werte-negieren\">Werte negieren</h2>\n<p>In Haskell negiert <code>not</code> den Wert eines boolschen Ausdrucks:</p><pre><code>-- Haskell GHCi Session\n‚Äã\n&gt; not True\nFalse\n‚Äã\n&gt; not False\nTrue\n</code></pre>\n<p>In Purescript gilt das gleiche:</p><pre><code>-- Purescript PSCi Session\n‚Äã\n&gt; not true\nfalse\n‚Äã\n&gt; not false\ntrue\n</code></pre>\n<p>Das ist nicht weiter kompliziert.</p><h2 id=\"funktionen-negieren\">Funktionen negieren</h2>\n<p>Grunds√§tzlich m√ºssten sich auf die gleiche Weise auch Funktionen\nnegieren lassen, die nach <code>Bool</code> abbilden.  F√ºr eine Funktion <code>f :: a -&gt; Bool</code> w√§re <code>not f</code> dann ebenfalls eine Funktion <code>a -&gt; Bool</code>,\nso dass <code>( not f ) x</code> ‚Ä¶</p><ul>\n<li>zu <code>True</code> auswertet wenn <code>f x</code> zu <code>False</code> auswertet, bzw.</li>\n<li>zu <code>False</code> auswertet wenn <code>f x</code> zu <code>True</code> auswertet.</li>\n</ul>\n<p>Haskells <code>not</code> kann das nicht leisten.  Um das zu demonstrieren,\ndefinieren wir eine <code>even</code> Funktion, die entscheidet, ob eine ganze\nZahl gerade ist:</p><pre><code>-- Haskell GHCi Session\n‚Äã\n&gt; even n = modBy 2 n == 0\n\n&gt; even 0\nTrue\n‚Äã\n&gt; even 1\nFalse\n‚Äã\n&gt; even 2\nTrue\n‚Äã\n&gt; even 3\nFalse\n</code></pre>\n<p><em>Anmerkung:</em> Mein Haskell ist nicht ganz idiomatisch.  <code>modBy</code> ist\n<a href=\"https://git.sr.ht/~aramis/ulme/tree/0ee5e975/item/src/Ulme.hs#L387\">selbstdefiniert</a>.</p><p>Wir m√ºssten also eine <code>odd</code> Funktion definieren k√∂nnen, die\nentscheidet, ob eine ganze Zahl ungerade ist, indem wir <code>even</code> mit\n<code>not</code> negieren.  Wenn wir versuchen, das in Haskell umzusetzen,\nscheitern wir:</p><pre><code>-- Haskell GHCi Session\n‚Äã\n&gt; odd = not even\n&lt;interactive&gt;: error:\n    ‚Ä¢ Couldn&#39;t match expected type ‚ÄòBool‚Äô with actual type ‚Äòa0 -&gt; Bool‚Äô\n    ‚Ä¢ ...\n</code></pre>\n<p>In Purescript ist das gar kein Problem.  Hier ist die <code>even</code>\nFunktion in Purescript:</p><pre><code>-- Purescript PSCi Session\n‚Äã\n&gt; even n = mod n 2 == 0\n‚Äã\n&gt; even 0\ntrue\n‚Äã\n&gt; even 1\nfalse\n‚Äã\n&gt; even 2\ntrue\n‚Äã\n&gt; even 3\nfalse\n</code></pre>\n<p>Wenn wir <code>even</code> mit <code>not</code> negieren, erhalten wir ohne Probleme unsere\n<code>odd</code> Funktion:</p><pre><code>-- Purescript GHCi Session\n‚Äã\n&gt; odd = not even\n‚Äã\n&gt; odd 0\nfalse\n‚Äã\n&gt; odd 1\ntrue\n‚Äã\n&gt; odd 2\nfalse\n‚Äã\n&gt; odd 3\ntrue\n</code></pre>\n<h2 id=\"wie-ist-das-umgesetzt\">Wie ist das umgesetzt?</h2>\n<p>In Haskell ist <code>not</code> eine Funktion <code>Bool -&gt; Bool</code>.\nIn Purescript ist <code>not</code> eine Funktion <code>HeytingAlgebra a =&gt; a -&gt; a</code>.  Die Heyting-Algebra ist offenbar eine\nVerallgemeinerung der booleschen Algebra.  Auf den <a href=\"https://github.com/purescript/purescript-prelude/blob/v6.0.1/src/Data/HeytingAlgebra.purs#L78\">ersten\nBlick</a>\nspricht nichts dagegen, <code>not</code> auf die gleiche Weise auch\nin Haskell zu verallgemeinern.  Vielleicht nehme ich\ndas mal in Angriff und versuche <code>not</code> in meinem <a href=\"https://git.sr.ht/~aramis/ulme\">DIY\nPrelude</a> entsprechend anzupassen.</p><h2 id=\"bonus\">Bonus</h2>\n<p>Dann ist mir noch ein sch√∂nes Beispiel daf√ºr eingefallen, dass man\nmanchmal in der Lage ist, zu erkennen, zu welchem Wert ein Ausdruck\nauswerten m√ºsste, obwohl der Compiler auf dem Schlauch steht:</p><pre><code>foldr (+) 0 ( repeat 0 )\n</code></pre>\n<p>Der Ausdruck terminiert weder in Haskell noch in Purescript, weil\n<code>repeat</code> eine unendliche Sequenz erzeugt.  Anschaulich ist v√∂llig\nklar, dass er zu <code>0</code> auswerten m√ºsste, denn wir summieren einfach\nnur Nullen auf.  Formal l√§sst sich das auch leicht rechtfertigen:\nwenn wir eine unendliche Summe √ºber einem Monoid bilden, wobei\nalle Summanden das neutrale Element sind, dann ergibt die Summe\nschon per Definition ebenfalls das neutrale Element.</p><p>Es gibt weitere Beispiele dieser Art.  Der folgende Ausdruck\nterminiert auch nicht, m√ºsste aber zum leeren String <code>&quot;&quot;</code> auswerten.\nAnschaulich ist das auch wieder v√∂llig klar.  Formal gilt das\ngleiche wie oben.</p><pre><code>foldr (++) &quot;&quot; ( repeat &quot;&quot; )\n</code></pre>\n<p><em>Hinweis:</em> <code>(++)</code> ist hier ein Alias f√ºr <code>(&lt;&gt;)</code>.</p><p>Der folgende Ausdruck terminiert auch nicht, m√ºsste aber in Haskell\nzur leeren Liste <code>[]</code> auswerten.</p><pre><code>foldr (++) [] ( repeat [] )\n</code></pre>\n<p>Spannend ist die Frage, wie man das umsetzen k√∂nnte. Alle Beispiele\nhaben die Form:</p><pre><code>foldr mappend mempty ( repeat mempty )\n</code></pre>\n<p>Wenn die Faltung in der Lage w√§re, diese Form zu erkennen, k√∂nnte\nsie in diesem Fall zu <code>mempty</code> auswerten.</p>",
            "author": {
                "name": "Aram√≠s Concepci√≥n Dur√°n"
            },
            "tags": [
            ],
            "date_published": "2023-02-17T12:40:00+01:00",
            "date_modified": "2025-04-07T06:53:44+02:00"
        },
        {
            "id": "https://nojs.de/closures/",
            "url": "https://nojs.de/closures/",
            "title": "Closures",
            "content_html": "<p>Ich spiele gerade ein bisschen mit Go herum, weil ich mich\naus meiner funktionalen Ecke heraustrauen und etwas mehr mit\nimperativen, C-artigen Sprachen befassen m√∂chte.  Rust h√§tte\nmich auch interessiert, scheint aber ein Fass ohne Boden zu sein.\nGo ist modern, trotzdem stabil, recht kompakt und weitverbreitet.\nDie Liste der gro√üen und popul√§ren Softwareprojekte, die auf Go\nsetzen, ist beachtlich.</p><p>In der <a href=\"https://go.dev/tour/\">Go-Tour</a> gibt es einen Abschnitt zu\nClosures.  Ich nutze die Gelegenheit, um f√ºr mich zu kl√§ren was\nClosures sind.  Ich hab den Begriff bisher nie wirklich verstanden.</p><p>Eine Closure (i.e. ein Funktionsabschluss) ist eine Funkion, die\nReferenzen auf ihren Erstellungskontext enth√§lt, wobei dieser\nKontext au√üerhalb der Funktion nicht mehr sichtbar und nicht mehr\nreferenzierbar ist.</p><p>Ein Beisiel aus dem Haskell Wiki:</p><pre><code>&gt; f x = \\ y -&gt; x + y\n&gt; g = f 3\n&gt; g 4\n7\n</code></pre>\n<p>Wenn wir <code>g</code> definieren, wird der Wert <code>3</code> an den Parameter <code>x</code>\ngebunden, so dass <code>g = \\ y -&gt; 3 + y</code> gilt.  Auf den Kontext, in dem\ndie Bindung <code>x = 3</code> vorliegt, k√∂nnen wir aber nicht mehr zugreifen,\nobwohl er weiter existiert solange <code>g</code> existiert.  Eine Closure liegt\nvor weil die Bindung <code>x = 3</code> im Kontext des Lambda-Ausdrucks erfolgt\naber innerhalb des Lambda-Ausdrucks verwendet wird.  Dadurch lebt\nder Kontext √ºber die Definition hinaus weiter, weil er f√ºr die\nAuswertung ben√∂tigt wird.</p><p>Ich verstehe das, aber was ich nicht verstehe ist, warum man dieser\nSache einen gesonderten Namen gibt und sie als eine spezielle\nProgrammiertechnik behandelt.  Statt <code>f x = \\ y -&gt; x + y</code> k√∂nnte\nman auch schreiben: <code>f x y = x + y</code>.  Das ist die normalste Sache der\nWelt und ich verstehe √ºberhaupt nicht, wie es anders sein k√∂nnte,\nalso was es bedeuten soll, ohne Closures zu programmieren.</p><p>Beim Schreiben kommt mir der Verdacht, dass es irgendwie damit\nzusammenh√§ngen muss, dass Sprachen wie C keine First Class Functions\nhaben.  Wenn man es nicht gewohnt ist, kann das Herumreichen von\nFunktionen als Argumente und R√ºckgabewerte mit allen M√∂glichkeiten,\ndie sich daraus ergeben, vielleicht wie ein besonderer Hokuspokus\nerscheinen, der erst mal in einen Begriff zu bringen ist: Closure\n‚Äî eine Funktion, die auf freien Variablen operiert.</p><p>Das Gegenteil w√§re ein Combinator ‚Äî eine Funktion ohne freie\nVariable.</p><p><strong>Update</strong></p><p>Ok, ich hab‚Äôs!  Der eigentliche Effekt, an dem man offenbar bei der\nimperativen Programmierung mit Closures interessiert ist, tritt bei\nder rein funktionalen Programmierung gar nicht auf.  Eine Closure\nist in diesem Fall eine Prozedur mit einem inneren Zustand, der\n√ºber mehrere Aufrufe hinweg fortbesteht und ver√§nderbar ist.\nHier ein angepasstes Beispiel aus der Go Tour:</p><pre><code>func adder() func(int) int {\n    sum := 0\n    return func(x int) int {\n        sum += x\n        return sum\n    }\n}\nfunc main() {\n    f := adder()\n    fmt.Println(f(0)) // 0\n    fmt.Println(f(1)) // 1\n    fmt.Println(f(2)) // 3\n    fmt.Println(f(3)) // 6\n    fmt.Println(f(4)) // 10\n    fmt.Println(f(5)) // 15\n}\n</code></pre>\n<p>Was passiert hier?  Die Prozedur <code>f</code> hat einen inneren Zustand,\nder mit <code>sum := 0</code> initialisiert wird, bei jedem Aufruf von\n<code>f</code> ver√§ndert wird und nur indirekt √ºber den R√ºckgabewert\nobservierbar ist.  Daraus k√∂nnte man ein Objektsystem stricken.</p><p>Nicht alle imperativen Sprachen unterst√ºtzen Closures.  Wenn sie\nes nicht tun, wird <code>f</code> im obigen Beispiel zur Identit√§tsfunktion,\nweil <code>f(n)</code> stets zu <code>0 + n</code> auswertet.</p>",
            "author": {
                "name": "Aram√≠s Concepci√≥n Dur√°n"
            },
            "tags": [
            ],
            "date_published": "2023-01-18T12:39:00+01:00",
            "date_modified": "2025-04-07T06:53:33+02:00"
        },
        {
            "id": "https://nojs.de/trial-beim-mc-post-leipzig/",
            "url": "https://nojs.de/trial-beim-mc-post-leipzig/",
            "title": "Trial beim MC Post Leipzig",
            "content_html": "<p><a href=\"../tschuessi-mc-post/index.html\">Es gibt dazu ein Update 2025.</a></p><p>In meiner Jugend bin ich wettkampforientiert Fahrrad-Trial gefahren.\nEinige Jahre lang war dieser Sport gewisserma√üen meine Raison\nd‚Äô√™tre.  Dann hat f√ºr mich das echte Leben begonnen: Abitur,\nStudium, Freundin, WG-Leben und eine chaotische Suche nach meinem\nPlatz in dieser Welt.  Jetzt ist es vielleicht achtzehn Jahre oder\nl√§nger her, dass ich den Trial-Sport aufgegeben habe.  Irgendwie\nwar damals die Luft raus.  Aber in den darauffolgenden Jahren habe\nich etwas so k√∂rperlich intensives und viszeral sinnstiftendes\nwirklich sehr sehr vermisst in meinem Leben.  Trial hat mir damals\ndas gegeben, was Hartmut Rosa eine diagonale Resonanzbeziehung nennt.</p><p>Jetzt bin ich 38 Jahre alt und √ºbergewichtig.  Ich muss dringend\nmehr Sport machen, um meine zweite Lebensh√§lfte gesund √ºber die\nB√ºhne zu bringen.  Noch geht es mir gut, aber ich bef√ºrchte,\ndass ich in zehn Jahren endg√ºltig ein dicker Stubenhocker sein\nwerde, f√ºr den die sportlichen Highlights des Tages die Wege zum\nK√ºhlschrank, zum Briefkasten und zum Auto sind.  Die Eitelkeit\nals Triebfeder f√ºr die k√∂rperliche Fitness tritt f√ºr mich mit\nzunehmendem Alter in den Hintergrund.  Sie wird abgel√∂st von der\nSorge um mein k√∂rperliches und geistiges Wohlbefinden.</p><p>Im Fr√ºhling kam mir die Idee, Trial wieder auszuprobieren um\nherauszufinden ob es wieder Spa√ü macht und wieviel davon mein\nK√∂rper noch erinnert.  Ja, es macht einen Heidenspa√ü und zu meinem\ngro√üen Erstaunen kann ich es noch.</p><figure class=\"post__image\"><img loading=\"lazy\" src=\"../media/files/c005300e15073ea140da81b2043d686b6a09ae30.jpg\" alt=\"\"  data-is-external-image=\"true\"></figure><p>Die Bilder sind auf dem Trainingsgel√§nde des MC Post Leipzig\ne.V. entstanden.  Ich bin dort seit ein paar Wochen Mitglied und\nnutze jede Gelegenheit f√ºr ein Training.  Nach f√ºnf Minuten atme\nich wie nach einem Sprint.  Nach einer Stunde bin ich nassgeschwitzt\nund v√∂llig ersch√∂pft.</p><figure class=\"post__image\"><img src=\"../media/files/488cd0881027d7617510e3a3f70d6a90253b6245.jpg\" alt=\"\"  data-is-external-image=\"true\"></figure><figure class=\"post__image\"><img loading=\"lazy\" src=\"../media/files/72b2606db197c396d0eadcdc12e9b47c42749806.jpg\" alt=\"\"  data-is-external-image=\"true\"></figure><p>Der Fotograf, der diese Aufnahmen geschossen hat, ist\nJan Zwicker.  Jan stand am Samstag fr√ºh um zehn (f√ºr einen\nanderen Anlass) mit seiner professionellen Fotoausr√ºstung auf\ndem Gel√§nde und hat gefragt, ob er ein paar Fotos machen darf.<br><a href=\"https://wheels-and-vibes.com/\">https://wheels-and-vibes.com/</a></p><figure class=\"post__image\"><img src=\"../media/files/e42a753ae8d6da3d8b37dc2724040e347cdd736f.jpg\" alt=\"\"  data-is-external-image=\"true\"></figure><figure class=\"post__image\"><img loading=\"lazy\" src=\"../media/files/4aab49c3a0f4becf4c507b56ca97d0a2b00a0e59.jpg\" alt=\"\"  data-is-external-image=\"true\"></figure><p>Ich wiege 25 kg mehr als damals.  Das macht sich bemerkbar.  Aber die\ngrunds√§tzlichen Bewegungsabl√§ufe und das Gef√ºhl f√ºr das Fahrrad\nsind noch da.  Es scheint zu stimmen: Fahrradfahren verlernt man\nnicht.  Jetzt ist die gro√üe Frage, wie es f√ºr mich weitergeht.\nBleibe ich beim Midlife-Cycling? Wird das dazu beitragen, dass ich\nwieder fit werde und mein √úbergewicht loswerde? Oder mache ich\nmir damit auf Dauer nur die Knochen kaputt?</p><figure class=\"post__image\"><img src=\"../media/files/fac72a0dc6ac5f5932c4bcc3f489c9314bcd544f.jpg\" alt=\"\"  data-is-external-image=\"true\"></figure><figure class=\"post__image\"><img loading=\"lazy\" src=\"../media/files/a1c8e9816952ec9439a2706480216fc5e9bb8e71.jpg\" alt=\"\"  data-is-external-image=\"true\"></figure><p>Das Trainingsgel√§nde des MC Post Leipzig ist das einzige seiner Art\nmitten in einer deutschen Gro√üstadt.  Es ist keinen ganzen Kilometer\nvon meiner Wohnung entfernt und ich frage mich, warum ich nicht schon\neher auf die Idee gekommen bin, dort mitzumachen.  Im Moment bin ich\nder einzige Fahrrad-Trialer im Verein.  Die anderen fahren Motorrad.</p><p><del>Wenn du auch Fahrrad-Trial f√§hrst und in der N√§he lebst, mach\nbei uns mit.  Es lohnt sich.</del></p><p><del><a href=\"https://mcpostleipzig.de/\">https://mcpostleipzig.de/</a></del></p>",
            "author": {
                "name": "Aram√≠s Concepci√≥n Dur√°n"
            },
            "tags": [
            ],
            "date_published": "2022-12-02T09:41:00+01:00",
            "date_modified": "2025-04-06T12:51:17+02:00"
        },
        {
            "id": "https://nojs.de/nix-expression-language/",
            "url": "https://nojs.de/nix-expression-language/",
            "title": "Nix Expression Language",
            "content_html": "<p>Ich erkunde die Nix Expression Language.  Mein Startpunkt ist\n<a href=\"https://learnxinyminutes.com/docs/nix/\">https://learnxinyminutes.com/docs/nix/</a>.  Sehr hilfreich ist auch\ndie Dokumentation, welche √ºber die Nix Repl verf√ºgbar ist.</p><h2 id=\"auswertung\">Auswertung</h2>\n<p>Die auszuwertenden Ausdr√ºcke schreibe ich in eine Datei\n<code>scratch.nix</code>.  Die Auswertung erfolgt so:</p><pre><code>$ nix-instantiate --eval scratch.nix\n</code></pre>\n<p>F√ºr mehr Komfort kann man <code>inotifywait</code> benutzen um die Auswertung\njedesmal anzusto√üen wenn die Datei <code>scratch.nix</code> gespeichert wird:</p><pre><code>$ while true\n    inotifywait -q -e modify scratch.nix\n    clear\n    nix-instantiate --eval scratch.nix\n    and echo &quot;.&quot;\n  end\n</code></pre>\n<p>Das ist eine Kommandozeile f√ºr die <code>fish</code> Shell.  In <code>sh</code> usw. muss\nman das ein bisschen anders schreiben.  Die <code>fish</code> Shell ist sehr\nkomfortabel: man kann das einfach so mehrzeilig aufschreiben;\ndie Shell wei√ü, wann die Eingabetaste die Zeile umbrechen soll\nund wann sie die Auswertung ansto√üen soll.</p><p>Kurze Ausdr√ºcke kann man auch direkt in der Nix Repl ausprobieren:</p><pre><code>$ nix repl\nWelcome to Nix 2.10.3. Type :? for help.\n\nnix-repl&gt; &quot;Das ist eine Zeichenkette&quot;\n&quot;Das ist eine Zeichenkette&quot;\n\nnix-repl&gt; 7 * 11 * 13\n1001\n</code></pre>\n<p>Update: Am Ende habe ich die Methode mit der Scratch-Datei kaum\nverwendet und mich stattdessen fast ausschlie√ülich auf die Nix\nRepl verlassen.  Die Nix Repl bietet integrierte Dokumentation und\nkann auch mit mehrzeiligen Eingaben gut umgehen.</p><h2 id=\"einfache-sprachbestandteile\">Einfache Sprachbestandteile</h2>\n<p>Im Schnelldurchlauf.</p><h3 id=\"kommentare\">Kommentare</h3>\n<pre><code># Einzeilige Kommentare (wie in Python).\n\n/*\n    Mehrzeilige Kommentare (wie in C++).\n\n    Python-Einzeiler und C++-Mehrzeiler sind schon mal eine\n    seltsame Kombination.  Wir haben noch nicht richtig begonnen\n    und der Merkw√ºrdigkeitsfaktor ist schon gr√∂√üer 1.\n*/\n</code></pre>\n<h3 id=\"booleans\">Booleans</h3>\n<pre><code>nix-repl&gt; true &amp;&amp; false\nfalse\n\nnix-repl&gt; true || false\ntrue\n</code></pre>\n<h3 id=\"verzweigung\">Verzweigung</h3>\n<pre><code>nix-repl&gt; if 3 &lt; 4 then &quot;a&quot; else &quot;b&quot;\n&quot;a&quot;\n</code></pre>\n<h3 id=\"zahlen\">Zahlen</h3>\n<p>Es scheint Integers und Floats zu geben.  Man kann sie beim Rechnen\nmit einander kombinieren.  Die arithmetischen Operatoren sind\npolymorph.  Der Interpreter scheint selbst√§ndig nach gewissen Regeln\nzu enscheiden, wann das Ergebnis Integer und wann es Float ist.\nDaraus ergeben sich die √ºblichen Fallstricke:</p><pre><code>nix-repl&gt; 7.0 / 2\n3.5\n\nnix-repl&gt; 7 / 2\n3\n</code></pre>\n<p>F√ºr den Einsatzzweck der Nix Expression Language ist das bestimmt\nkein Problem.</p><h3 id=\"strings\">Strings</h3>\n<pre><code>nix-repl&gt; &quot;Das ist ein String&quot;\n&quot;Das ist ein String&quot;\n</code></pre>\n<p>Strings k√∂nnen mehrzeilig sein:</p><pre><code>nix-repl&gt; &quot;asdf\n...       asdf\n...       asdf&quot;\n&quot;asdf\\nasdf\\nasdf&quot;\n</code></pre>\n<p>Die sogenannten Indented Strings sind ebenfalls mehrzeilig.\nBei ihnen wird die Einr√ºckung nicht mit ausgewertet.  Das ist\ndie k√ºrzeste Folge von f√ºhrenden Leerzeichen, in der alle nicht\nleeren Zeilen des Strings √ºbereinstimmen.  Ob und wie dabei Tabs\nber√ºcksichtigt werden, habe ich nicht ausprobiert.  Hier werden\nin jeder Zeile die vier f√ºhrenden Leerzeichen entfernt:</p><pre><code>nix-repl&gt; &#39;&#39;    asdf\n...           asdf\n...           asdf&#39;&#39;\n&quot;asdf\\nasdf\\nasdf&quot;\n</code></pre>\n<p>Mit leeren Zeilen sind hier auch Zeilen gemeint, die nur aus\nLeerraum bestehen.  Leerzeilen am Rand des Strings werden verworfen.</p><p>Verkettung von Strings mit <code>+</code>:</p><pre><code>nix-repl&gt; &quot;ab&quot; + &quot;cd&quot;\n&quot;abcd&quot;\n</code></pre>\n<p>Auswertung in Strings:</p><pre><code>nix-repl&gt; &quot;Home is ${builtins.getEnv &quot;HOME&quot;}.&quot;\n&quot;Home is /home/aramis.&quot;\n</code></pre>\n<p>Der Name <code>builtins</code> verweist auf eine Standardbibliothek (genauer:\nein Set) von Funktionen und Prozeduren.  Das <code>builtins</code> Set ist\nimmer verf√ºgbar wenn der Nix Interpreter startet.  Die Prozedur\n<code>builtins.getEnv</code> liefert den Wert von Umgebungsvariablen.</p><pre><code>nix-repl&gt; builtins.getEnv &quot;HOME&quot;\n&quot;/home/aramis&quot;\n</code></pre>\n<h3 id=\"pfade\">Pfade</h3>\n<p>F√ºr Pfade gibt es einen eigenen Basisdatentyp.  Man notiert Pfade\neinfach so wie man sie auch sonst notieren w√ºrde:</p><pre><code>nix-repl&gt; /home/aramis\n/home/aramis\n</code></pre>\n<p>Das hat aber Einschr√§nkungen.  Zum Beispiel sind abschlie√üende\nSchr√§gstriche aus irgendwelchen Gr√ºnden nicht gestattet:</p><pre><code>nix-repl&gt; /home/aramis/\nerror: path has a trailing slash\n\nnix-repl&gt; /home/aramis/.\n/home/aramis\n</code></pre>\n<p>Pfade ganz ohne Schr√§gstriche wie z.B. <code>.</code> werden auch nicht\nerkannt:</p><pre><code>nix-repl&gt; .\nerror: syntax error, unexpected &#39;.&#39;\n\nnix-repl&gt; ./\nerror: path has a trailing slash\n\nnix-repl&gt; ./.\n/home/aramis\n</code></pre>\n<p>Relative Pfade werden in absolute Pfade aufgel√∂st relativ zu dem\nVerzeichnis, in welchem sich die Datei befindet, die ausgewertet\nwird:</p><pre><code>nix-repl&gt; ./.\n/home/aramis\n</code></pre>\n<p>Pfade werden kanonisiert:</p><pre><code>nix-repl&gt; /home/aramis/.\n/home/aramis\n</code></pre>\n<p>Daraus, dass der Parser auch relative Pfade als Pfade erkennt,\nergibt sich, dass der Schr√§gstrich, wenn er als Divisionszeichen\ngelesen werden soll, von Leerraum umgeben sein muss</p><pre><code>nix-repl&gt; 0/0\n/home/aramis/0/0\n\nnix-repl&gt; 0 / 0\nerror: division by zero\n</code></pre>\n<h3 id=\"imports\">Imports</h3>\n<p>Jedes Nix Skript enth√§lt genau einen Top-Level-Ausdruck ohne freie\nVariable, der also vollst√§ndig ausgewertet werden kann.  Wenn ein\nSkript importiert wird, entspricht der Wert des Import-Ausdrucks\ndem Wert des importierten Skripts:</p><pre><code>$ echo &quot;1 + 2&quot; &gt; foo.nix\n$ nix repl\nWelcome to Nix 2.10.3. Type :? for help.\n\nnix-repl&gt; import ./foo.nix\n3\n</code></pre>\n<p>Das <code>import</code> Schl√ºsselwort kann auch Strings verarbeiten:</p><pre><code>nix-repl&gt; import &quot;/home/aramis/foo.nix&quot;\n3\n</code></pre>\n<p>Aber das scheint nur zu funktionieren wenn der String einen absoluten\nPfad enth√§lt:</p><pre><code>nix-repl&gt; import &quot;foo.nix&quot;\nerror: string &#39;foo.nix&#39; doesn&#39;t represent an absolute path\n\nnix-repl&gt; import &quot;./foo.nix&quot;\nerror: string &#39;./foo.nix&#39; doesn&#39;t represent an absolute path\n</code></pre>\n<h3 id=\"let-in-ausdr√ºcke\">Let-In-Ausdr√ºcke</h3>\n<p>Daf√ºr gibt es eine <code>let ... ; in ...</code> Syntax:</p><pre><code>nix-repl&gt; let x = &quot;a&quot; ; in x + x + x\n&quot;aaa&quot;\n</code></pre>\n<p>Die Zuweisungen k√∂nnen sich auf einander beziehen, unabh√§ngig\nvon ihrer Reihenfolge:</p><pre><code>nix-repl&gt; let y = x + &quot;b&quot; ; x = &quot;a&quot; ; in y + &quot;c&quot;\n&quot;abc&quot;\n</code></pre>\n<p>Innere Zuweisungen √ºberschatten weiter au√üen liegende Zuweisungen:</p><pre><code>nix-repl&gt; let a = 1 ; in let a = 2 ; in a\n2\n</code></pre>\n<h3 id=\"funktionen\">Funktionen</h3>\n<p>Das ist erstaunlich rudiment√§r gel√∂st.  Nix kennt eigentlich nur\neinfache Lambdas:</p><pre><code>nix-repl&gt; (n : n + 1) 5\n6\n</code></pre>\n<p>Lambdas mit mehr als einem Parameter ergeben sich aus der Syntax\nauf nat√ºrliche Weise:</p><pre><code>nix-repl&gt; (a : b : a + b) 5 6\n11\n</code></pre>\n<p>Wenn man Namen f√ºr Funktionen vergeben m√∂chte, kann man auf die\n<code>let ... ; in ...</code> Syntax zur√ºckgreifen:</p><pre><code>nix-repl&gt; let plus = (a : b : a + b ) ; in plus 5 6\n11\n</code></pre>\n<h3 id=\"listen\">Listen</h3>\n<p>Listen sind von eckigen Klammern begrenzt.  Die Elemente sind durch\nLerraum getrennt.</p><pre><code>nix-repl&gt;[ 1 2 3 ]\n[ 1 2 3 ]\n</code></pre>\n<p>Es gibt viele Built-Ins f√ºr Listen:</p><pre><code>nix-repl&gt; builtins.length [ 1 2 3 ]\n3\n\nnix-repl&gt; builtins.concatLists [ [ 1 2 3 ] [ 4 5 6 ] ]\n[ 1 2 3 4 5 6 ]\n\nnix-repl&gt; builtins.head [ 1 2 3 ]\n1\n\nnix-repl&gt; builtins.filter (n : n &lt; 3) [ 1 2 3 ]\n[ 1 2 ]\n</code></pre>\n<h3 id=\"sets-mengen\">Sets (Mengen)</h3>\n<p>In Nix Sets hat jedes Element einen String als Schl√ºssel also\neinen Namen.  Demnach sind Nix Sets keine blo√üen Mengen sondern\neher Records bzw. Maps.</p><pre><code>nix-repl&gt; { a = 1 ; b = 2 ; }.a\n1\n\nnix-repl&gt; let s = { a = 1 ; b = 2 ; } ; in s.a\n1\n</code></pre>\n<p>Der <code>?</code> Operator pr√ºft die Existenz eines Schl√ºssels:</p><pre><code>nix-repl&gt; { a = 1 ; b = 2 ; } ? a\ntrue\n</code></pre>\n<p>Der <code>//</code> Operator vereinigt zwei Sets:</p><pre><code>nix-repl&gt; { a = 1 ; } // { b = 2 ; }\n{ a = 1; b = 2; }\n</code></pre>\n<p>Wenn dabei Schl√ºssel kollidieren, hat das rechte Set Vorrang:</p><pre><code>nix-repl&gt; { a = 1 ; } // { a = 2 ; }\n{ a = 2; }\n</code></pre>\n<p>Mit dem <code>rec</code> Schl√ºsselwort k√∂nnen rekursive Sets deklariert\nwerden.  Darin k√∂nnen sich Werte auf andere Werte des selben\nSets beziehen:</p><pre><code>nix-repl&gt; rec { a = 1 ; b = a ; }\n{ a = 1; b = 1; }\n\nnix-repl&gt; rec { a = b ; b = a ; }\nerror: infinite recursion encountered\n</code></pre>\n<p>F√ºr verschachtelte Sets gibt es eine Kurznotation:</p><pre><code>nix-repl&gt; { a.b = 2 ; a.c = 3 ; }\n{ a = { ... }; }\n</code></pre>\n<p>Das entspricht:</p><pre><code>nix-repl&gt; { a = { b = 2 ; c = 3 ; } ; }\n{ a = { ... }; }\n</code></pre>\n<p>Man kann die Kurznotation mit der ausf√ºhrlicheren mischen:</p><pre><code>nix-repl&gt; { a = { b = 2 ; } ; a.c = 3 ; }\n{ a = { ... }; }\n</code></pre>\n<p>Ich finde, das sieht widerspr√ºchlich aus.</p><h3 id=\"das-with-schl√ºsselwort\">Das <code>with</code> Schl√ºsselwort</h3>\n<p>Das <code>with</code> Schl√ºsselwort nimmt ein Set und einen Ausdruck.  In dem\nAusdruck gelten die Schl√ºssel-Wert-Paare des Sets als Bindungen:</p><pre><code>nix-repl&gt; with { a = 1 ; b = 2 ; } ; a + b\n3\n</code></pre>\n<p>Das ist also wie die <code>let ... ; in ...</code> Syntax:</p><pre><code>nix-repl&gt; let a = 1 ; b = 2 ; in a + b\n3\n</code></pre>\n<p>Der Unterschied ist, dass bei <code>with</code> die gesamte Menge von Bindungen\nin einem (Set-)Ausdruck zusammengefasst ist.  Dadurch kann man sich\ndie Bindungen sozusagen als ein ganzes B√ºndel aus dem Kontext holen.\nMan sieht das h√§ufig in Nix-Expressions bspw. um die Built-Ins\nunqualifiziert verf√ºgbar zu machen:</p><pre><code>nix-repl builtins.length [ 1 2 3 ]\n3\n\nnix-repl&gt; with builtins ; length [ 1 2 3 ]\n3\n</code></pre>\n<p>Das ist sinnvoll wenn man z.B. viele Built-Ins in einem Ausdruck\nverwenden m√∂chte und sie nicht jedesmal mit <code>builtins.</code>\nqualifizieren m√∂chte.</p><p>Ohne <code>with</code>:</p><pre><code>nix-repl&gt; [ ( builtins.length [ 1 2 3 ] )\n...         ( builtins.head [ 1 2 3 ] )\n...         ( builtins.elem 2 [ 1 2 3 ] )\n...       ]\n[ 3 1 true ]\n</code></pre>\n<p>Mit <code>with</code>:</p><pre><code>nix-repl&gt; with builtins ;\n...       [ ( length [ 1 2 3 ] )\n...         ( head [ 1 2 3 ] )\n...         ( elem 2 [ 1 2 3 ] )\n...       ]\n[ 3 1 true ]\n</code></pre>\n<p>Wenn man also qualifiziert importieren m√∂chte, ganz grob ungef√§hr\nso wie man es in Haskell machen w√ºrde, k√∂nnte das so aussehen:</p><pre><code>$ echo &quot;{ plus = a : b : a + b ; }&quot; &gt; foo.nix\n$ nix repl\nWelcome to Nix 2.10.3. Type :? for help.\n\nnix-repl&gt; let foo = import ./foo.nix ; in with foo ; foo.plus 5 6\n11\n</code></pre>\n<p>Das w√ºrde einem unqualifizierten Import entsprechen:</p><pre><code>nix-repl&gt; with import ./foo.nix ; plus 5 6\n11\n</code></pre>\n<p>Anstatt wie oben den Import in einem Let-Ausdruck an den Namen <code>foo</code>\nzu binden, kann man diesen Namen in der importierten Datei festlegen.\nDann spart man sich den Let-Ausdruck:</p><pre><code>$ echo &quot;{ foo = { plus = a : b : a + b ; } ; }&quot; &gt; foo.nix\n$ nix repl\nWelcome to Nix 2.10.3. Type :? for help.\n\nnix-repl&gt; with import ./foo.nix ; foo.plus 5 6\n11\n</code></pre>\n<p>Die Variante hat den gro√üen Nachteil, dass die Festlegung des\n<em>Qualifiers</em> <code>foo</code> in der importierenden Datei nicht explizit ist.</p><p>Mit <code>with</code> l√§sst sich jeweils nur ein Set von Bindungen angeben\naber, √§hnlich wie bie den Lambdas, ergibt sich auch hier aus der\nSyntax eine nat√ºrliche Erweiterung auf mehrere Sets:</p><pre><code>nix-repl&gt; with builtins ;\n...       with { myList = [ 1 2 3 ] ; } ;\n...       length myList\n3\n</code></pre>\n<h3 id=\"set-patterns\">Set Patterns</h3>\n<p>Funktionen unterst√ºtzen per se keine benannten Parameter.\nLambdas k√∂nnen aber selbstverst√§ndlich auch auf Sets operieren:</p><pre><code>nix-repl&gt; (x : x.a + x.b) { a = 5 ; b = 6 ; }\n11\n</code></pre>\n<p>Mit sogenannten Set Patterns kann man letztlich doch benannte\nFunktionsparameter aufschreiben:</p><pre><code>nix-repl&gt; ({a,b} : a + b) { a = 5 ; b = 6 ; }\n11\n</code></pre>\n<p>Dabei ist <code>{a,b}</code> ein sogenanntes Set Pattern.</p><p>Achtung: Wenn das Argument ein Set ist, welches zus√§tzliche\nWerte enth√§lt, die im Set Pattern nicht angegeben sind, ist das\nein Fehler:</p><pre><code>nix-repl&gt; ({a,b} : a + b) { a = 5 ; b = 6 ; c = 7 ; }\nerror: anonymous function at (string):1:2 called with unexpected argument &#39;c&#39;\n</code></pre>\n<p>Man kann den Fall aber im Set Pattern durch Auslassungspunkte\nausdr√ºcklich zulassen:</p><pre><code>nix-repl&gt; ({a,b,...} : a + b) { a = 5 ; b = 6 ; c = 7 ; }\n11\n</code></pre>\n<h3 id=\"fehler\">Fehler</h3>\n<p>Das <code>throw</code> Schl√ºsselwort bricht die Auswertung ab und gibt eine\nFehlermeldung aus:</p><pre><code>nix-repl&gt; 1 + 2 + throw &quot;drei&quot;\nerror: drei\n</code></pre>\n<p>Anscheinend werden Fehler innerhalb von Listen wie normale Elemente\nbehandelt.  Die Auswertung wird nicht abgebrochen:</p><pre><code>nix-repl&gt; [ 1 (throw &quot;zwei&quot;) 3 ]\n[ 1 ¬´error: error: zwei¬ª 3 ]\n</code></pre>\n<p>Das gleiche Verhalten tritt innerhalb von Sets auf:</p><pre><code>nix-repl&gt; { eins = 1 ; zwei = throw &quot;zwei&quot; ; drei = 3 ; }\n{ drei = 3; eins = 1; zwei = ¬´error: error: zwei¬ª; }\n</code></pre>\n<p>Neben <code>throw</code> gibt es auch noch das Schl√ºsselwort <code>abort</code>, welches\nebenfalls die Auswertung abbricht und eine Fehlermeldung ausgibt:</p><pre><code>nix-repl&gt; 1 + 2 + abort &quot;drei&quot;\nerror: evaluation aborted with the following error message: &#39;drei&#39;\n</code></pre>\n<p>Im Unterschied zu <code>throw</code> f√ºhrt <code>abort</code> auch innerhalb von Listen\nund Sets zum Abbruch der Auswertung:</p><pre><code>nix-repl&gt; [ 1 (abort &quot;zwei&quot;) 3 ]\nerror: evaluation aborted with the following error message: &#39;zwei&#39;\n\nnix-repl&gt; { eins = 1 ; zwei = abort &quot;zwei&quot; ; drei = 3 ; }\nerror: evaluation aborted with the following error message: &#39;zwei&#39;\n</code></pre>\n<p>Der Unterschied zwischen <code>throw</code> und <code>abort</code> ist n√ºtzlich.\nIn <code>nix-env -qa</code> und anderen Shell-Anweisungen, die Listen oder Sets\nvon Nix Derivationen verarbeiten, wird <code>throw</code> verwendet, sofern\nbei einem Fehler in einer Derivation trotzdem alle nachfolgenden\nDerivationen verarbeitet werden sollen.  Nat√ºrlich gibt es auch\nF√§lle, in denen ein Fehler zum Abbruch der ganzen Auswertung\nf√ºhren soll.  In solchen F√§llen verwendet man <code>abort</code>.</p><p>Mit <code>builtins.tryEval</code> k√∂nnen Fehler aufgefangen werden, die mit\n<code>throw</code> ausgel√∂st worden sind:</p><pre><code>nix-repl&gt; builtins.tryEval (1 + 2 + 3)\n{ success = true; value = 6; }\n\nnix-repl&gt; builtins.tryEval (1 + 2 + throw &quot;drei&quot;)\n{ success = false; value = false; }\n</code></pre>\n<p>Mit <code>abort</code> ausgel√∂ste Fehler kann <code>builtins.tryEval</code> nicht\nauffangen:</p><pre><code>nix-repl&gt; builtins.tryEval (1 + 2 + abort &quot;drei&quot;)\nerror: evaluation aborted with the following error message: &#39;drei&#39;\n</code></pre>\n<p>Das <code>assert</code> Schl√ºsselwort erwartet zwei Ausdr√ºcke, getrennt\ndurch ein Semikolon:</p><pre><code>assert &lt;erster Ausdruck&gt; ; &lt;zweiter Ausdruck&gt;\n</code></pre>\n<p>Der erste Ausdruck muss boolsch sein.  Der zweite Ausdruck kann\nbeliebig sein.  Wenn der erste Ausdruck zu <code>true</code> auswertet, wertet\nder gesamte <code>assert</code> Ausdruck zum zweiten Ausdruck aus:</p><pre><code>nix-repl&gt; assert true ; &quot;1199Panigale&quot;\n&quot;1199Panigale&quot;\n\nnix-repl&gt; assert 3 &lt; 4 ; &quot;1199&quot; + &quot;Panigale&quot;\n&quot;1199Panigale&quot;\n</code></pre>\n<p>Wenn der erste Ausdruck zu <code>false</code> auswertet, l√∂st der <code>assert</code>\nAusdruck einen Fehler aus:</p><pre><code>nix-repl&gt; assert false ; &quot;1199Panigale&quot;\nerror: assertion &#39;false&#39; failed\n\nnix-repl&gt; assert 4 &lt; 3 ; &quot;1199&quot; + &quot;Panigale&quot;\nerror: assertion &#39;(__lessThan 4 3)&#39; failed\n</code></pre>\n<p>Fehler, die von <code>assert</code> ausgel√∂st worden sind, k√∂nnen mit\n<code>builtins.tryEval</code> aufgefangen werden:</p><pre><code>nix-repl&gt; builtins.tryEval (assert true ; &quot;1199Panigale&quot;)\n{ success = true; value = &quot;1199Panigale&quot;; }\n\nnix-repl&gt; builtins.tryEval (assert false ; &quot;1199Panigale&quot;)\n{ success = false; value = false; }\n</code></pre>\n<h2 id=\"impurity\">Impurity</h2>\n<p>Die Nix Expression Language ist keine pure funktionale Sprache.\nSie folgt dem Anspruch, m√∂glichst pur zu arbeiten, um die\nReproduzierbarkeit von Builds sicherzustellen.  Es gibt aber ein\npaar Ausnahmen.</p><p>Ich will kein Haskell Snob sein, bin aber geneigt, anzumerken,\ndass eine Programmiersprache entweder <em>purely functional</em>\nist oder nicht, also ganz oder gar nicht.  Es gibt dazwischen\nkeinen Kompromiss, bzw. der Kompromiss w√§re immer <em>impure</em>.\nSchlie√ülich ist eine mathematische Relation entweder eine Abbildung\noder eben nicht.  Andererseits kann man sehr wohl auch in einer\nProgrammiersprache, welche diese Eigenschaft nicht hat, <em>purely\nfunctional</em> programmieren; es obliegt dann nur dem Menschen,\nsicherzustellen dass der Code ausschlie√ülich statische Werte\naus dem Kontext liest und klar unterscheidet zwischen Prozeduren,\ndie Nebeneffekte hervorrufen, und solchen die das nicht tun.</p><p>Es folgen ein paar Ursachen daf√ºr, dass die Nix Expression Language\nnicht <em>pure</em> ist.  (Es gibt noch weitere.)</p><h3 id=\"builtinsgetenv\">builtins.getEnv</h3>\n<p>Die Prozedur <code>builtins.getEnv</code> liest Umgebungsvariable:</p><pre><code>nix-repl&gt; builtins.getEnv &quot;HOME&quot;\n&quot;/home/aramis&quot;\n</code></pre>\n<p>Das ist unter allen Prozeduren, die hier aufgef√ºhrt sind, der eine,\nvon dem ich mir vorstellen k√∂nnte, dass er in die tolle Idee vom\n<em>Purely Functional Package Management</em> eine gro√üe L√ºcke rei√üt.</p><h3 id=\"builtinstrace\">builtins.trace</h3>\n<p>Die Prozedur <code>builtins.trace</code> nimmt zwei Werte entgegen, sendet\nden ersten Wert zur Standardfehlerausgabe und wertet selbst zum\nzweiten Wert aus:</p><pre><code>nix-repl&gt; builtins.trace &quot;err&quot; &quot;val&quot;\ntrace: err\n&quot;val&quot;\n</code></pre>\n<p>Auf die Standardfehlerausgabe zu schreiben, ist strenggenommen\nein Nebeneffekt, aber auch Sprachen, die sich r√ºhmen, <em>purely\nfunctional</em> zu sein, brauchen und haben eine <code>trace</code> Prozedur.</p><h3 id=\"builtinstofile\">builtins.toFile</h3>\n<p>Die Prozedur <code>builtins.toFile</code> schreibt Dateien in den Nix Store:</p><pre><code>nix-repl&gt; builtins.toFile &quot;foo.txt&quot; &quot;hello!&quot;\n&quot;/nix/store/ayh05aay2anx135prqp0cy34h891247x-foo.txt&quot;\n\nnix-repl&gt; :q\n\n$ cat /nix/store/ayh05aay2anx135prqp0cy34h891247x-foo.txt\nhello!\n</code></pre>\n<p>In eine Datei zu schreiben ist nat√ºrlich ein Nebeneffekt.  Zumindest\nwird hier sichergestellt, dass eine Datei, die einmal im Nix Store\nerzeugt worden ist, ihren Inhalt nicht mehr unbemerkt √§ndern kann,\ndenn ein Hashwert ihres Inhalts wird dem Dateinamen als Pr√§fix\nvorangestellt.  Was Nix anschlie√üend mit diesen Hashwerten macht\n‚Äì insbesondere ob Nix wirklich jede Datei vor jeder Verarbeitung\nerneut hasht und mit dem Dateinamen abgleicht ‚Äì wei√ü ich nicht,\naber das finde ich bestimmt noch heraus.</p><p>An der Stelle bin ich durch mit\n<a href=\"https://learnxinyminutes.com/docs/nix/\">https://learnxinyminutes.com/docs/nix/</a>.  Aktuell ist mein Plan, mir\nals n√§chstes die Namen anzuschauen, die in der Nix Repl aufgelistet\nwerden wenn man direkt nach dem Start die Tab-Taste dr√ºckt.\nDann schaue ich mir den Inhalt des <code>builtins</code> Sets genauer an.</p><h2 id=\"top-level-namen\">Top-Level Namen</h2>\n<p>Es gibt ein paar Namen (f√ºr Funktionen, Prozeduren, ‚Ä¶), die nach\ndem Start der Nix Repl unqualifiziert im Top-Level zur Verf√ºgung\nstehen:</p><pre><code>abort baseNameOf break builtins derivation derivationStrict dirOf\nfalse fetchGit fetchMercurial fetchTarball fetchTree fromTOML\nimport isNull map null placeholder removeAttrs scopedImport\nthrow toString true\n</code></pre>\n<p>Daneben gibt es noch eine Menge von Namen, die mit einem Unterstrich\nbeginnen, wie z.B. <code>__typeOf</code>.  Das scheinen allesamt Aliase f√ºr\ndie Namen im <code>builtins</code> Set zu sein.  Diese Namen lasse ich hier aus,\nweil ich vorhabe, sp√§ter auf den Inhalt von <code>builtins</code> einzugehen.</p><p>Die folgenden Namen wurden schon weiter oben erl√§utert:</p><pre><code>abort builtins false import throw true\n</code></pre>\n<p>Jetzt schaue ich mir den Rest an.</p><h3 id=\"map\">map</h3>\n<p>Damit kann man eine Funktion auf jedes Element in einer Liste\nanwenden:</p><pre><code>nix-repl&gt; map (n : 2 * n) [ 1 2 3 ]\n[ 2 4 6 ]\n</code></pre>\n<p>Wer schon funktional programmiert hat, d√ºrfte <code>map</code> kennen.</p><h3 id=\"basenameof\">baseNameOf</h3>\n<p>Liefert das letzte Segment in einem Pfad:</p><pre><code>nix-repl&gt; baseNameOf /home/aramis\n&quot;aramis&quot;\n\nnix-repl&gt; baseNameOf ./.\n&quot;aramis&quot;\n</code></pre>\n<p>Das funktioniert auch mit Strings:</p><pre><code>nix-repl&gt; baseNameOf &quot;/home/aramis&quot;\n&quot;aramis&quot;\n\nnix-repl&gt; baseNameOf &quot;/home/aramis/&quot;\n&quot;aramis&quot;\n</code></pre>\n<p>Pfade in einem String werden aber nicht kanonisiert:</p><pre><code>nix-repl&gt; baseNameOf &quot;../../..&quot;\n&quot;..&quot;\n</code></pre>\n<h3 id=\"dirof\">dirOf</h3>\n<p>Liefert den Pfad ohne das letzte Segment:</p><pre><code>nix-repl&gt; dirOf /home/aramis\n/home\n\nnix-repl&gt; dirOf &quot;/home/aramis&quot;\n&quot;/home&quot;\n\nnix-repl&gt; dirOf &quot;/home/aramis/&quot;\n&quot;/home/aramis&quot;\n\nnix-repl&gt; dirOf &quot;../../..&quot;\n&quot;../..&quot;\n</code></pre>\n<h3 id=\"null-isnull\">null, isNull</h3>\n<p>Offenbar gibt es einen <code>null</code> Wert.  Ich wei√ü nicht, welche Rolle\n<code>null</code> in der Nix Expression Language spielt.  Hoffentlich keine\nallzu gro√üe.  In anderen Sprachen repr√§sentiert der <code>null</code> Wert\nh√§ufig die Abwesenheit eines ‚Äúechten‚Äù Wertes.</p><p>Der <code>null</code> Wert scheint seinen eigenen Datentyp zu haben.  Ich greife\nan der Stelle vor auf <code>builtins.typeOf</code>.  Damit kann man den Datentyp\neines Ausdrucks  finden:</p><pre><code>nix-repl&gt; builtins.typeOf 0\n&quot;int&quot;\n\nnix-repl&gt; builtins.typeOf 0.0\n&quot;float&quot;\n\nnix-repl&gt; builtins.typeOf false\n&quot;bool&quot;\n\nnix-repl&gt; builtins.typeOf &quot;&quot;\n&quot;string&quot;\n\nnix-repl&gt; builtins.typeOf []\n&quot;list&quot;\n\nnix-repl&gt; builtins.typeOf {}\n&quot;set&quot;\n\nnix-repl&gt; builtins.typeOf null\n&quot;null&quot;\n</code></pre>\n<p>Die Funktion <code>isNull</code> ist markiert als <em>deprecated</em>.  Man soll\nstattdessen <code>... == null</code> verwenden:</p><pre><code>nix-repl&gt; isNull null\ntrue\n\nnix-repl&gt; isNull 0\nfalse\n\nnix-repl&gt; isNull &quot;&quot;\nfalse\n\nnix-repl&gt; null == null\ntrue\n\nnix-repl&gt; 0 == null\nfalse\n\nnix-repl&gt; &quot;&quot; == null\nfalse\n</code></pre>\n<h3 id=\"tostring\">toString</h3>\n<p>Damit k√∂nnen Ausdr√ºcke in eine Stringdarstellung √ºberf√ºhrt\nwerden:</p><pre><code>nix-repl&gt; toString 123\n&quot;123&quot;\n\nnix-repl&gt; toString &quot;Das ist schon ein String&quot;\n&quot;Das ist schon ein String&quot;\n</code></pre>\n<p>Pfade werden kanonisiert:</p><pre><code>nix-repl&gt; toString ./.\n&quot;/home/aramis&quot;\n</code></pre>\n<p>F√ºr andere Datentypen liefert <code>toString</code> Ergebnisse, die ich so\nnicht erwartet h√§tte:</p><pre><code>nix-repl&gt; toString 0.0\n&quot;0.000000&quot;\n\nnix-repl&gt; toString true\n&quot;1&quot;\n\nnix-repl&gt; toString false\n&quot;&quot;\n\nnix-repl&gt; toString []\n&quot;&quot;\n\nnix-repl&gt; toString [ 1 2 3 ]\n&quot;1 2 3&quot;\n\nnix-repl&gt; toString [ 1 2 3 [ 4 5 6 ] ]\n&quot;1 2 3 4 5 6&quot;\n\nnix-repl&gt; toString null\n&quot;&quot;\n</code></pre>\n<p>Auf Sets kann <code>toString</code> nur operieren wenn darin ein spezieller\nSchl√ºssel <code>__toString</code> oder <code>outPath</code> vorhanden ist:</p><pre><code>nix-repl&gt; toString { a = 1 ; b = 2 ; c = 3 ; }\nerror: cannot coerce a set to a string\n\nnix-repl&gt; toString { a = 1 ; b = 2 ; c = 3 ; outPath = &quot;asdf&quot; ; }\n&quot;asdf&quot;\n\nnix-repl&gt; toString\n...         { a = 1 ; b = 2 ; c = 3 ; __toString = self : self.a }\n&quot;1&quot;\n</code></pre>\n<h3 id=\"break\">break</h3>\n<p>Die Prozedur <code>break</code> hat hier nichts mit While-Schleifen oder\n√§hnlichem zu tun.  Man kann damit Breakpoints im Code setzen, an\ndenen der Interpreter im Debug Modus die Auswertung pausiert und in\ndie Repl wechselt.  Um den Interpreter im Debug Modus zu starten,\nmuss das Flag <code>--debugger</code> mit √ºbergeben werden.</p><p>Da wir hier nicht imperativ sondern deklarativ bzw. funktional\nprogrammieren, kann <code>break</code> nicht als Anweisung im Code platziert\nwerden ohne selbst zu irgendetwas auszuwerten.  Deswegen erwartet\n<code>break</code> ein Argument und wertet zu diesem Argument aus:</p><pre><code>nix-repl&gt; break 1\n1\n</code></pre>\n<h3 id=\"removeattrs\">removeAttrs</h3>\n<p>Die Funktion <code>removeAttrs</code> nimmt ein Set und eine Liste mit\nSchl√ºsseln entgegen.  Die aufgef√ºhrten Schl√ºssel werden aus\ndem Set entfernt.  Schl√ºssel, die in dem Set nicht vorkommen,\nwerden ignoriert:</p><pre><code>nix-repl&gt; removeAttrs { x = 1 ; y = 2 ; z = 3 ; } [ &quot;a&quot; &quot;x&quot; &quot;z&quot; ]\n{ y = 2; }\n</code></pre>\n<p>Ich glaube, diese Stelle markiert einen √úbergang.  Ich habe\nzun√§chst versucht, die Nix Expression Language ganz allgemein als\nProgrammiersprache zu betrachten, ohne darauf R√ºcksicht zu nehmen,\nwof√ºr sie tats√§chlich eingesetzt werden soll.  Ich denke, dass\ndas ab hier immer weniger m√∂glich sein wird.</p><h3 id=\"fromtoml\">fromTOML</h3>\n<p>Ich bin mit TOML nicht besonders vertraut, aber ich glaube,\nes ist nicht viel mehr als eine Folge von zeilenweisen\nSchl√ºssel-Wert-Zuweisungen in der Form <code>key=value</code>.  Die Funktion\n<code>fromTOML</code> scheint TOML Markup in ein Nix Set zu √ºberf√ºhren:</p><pre><code>nix-repl&gt; fromTOML &quot;a=1\\nb=2&quot;\n{ a = 1; b = 2; }\n</code></pre>\n<h3 id=\"scopedimport\">scopedImport</h3>\n<p>Das ist nirgendwo richtig dokumentiert und wird nicht einmal im\nNix Manual erw√§hnt.  Es gibt eine Issue auf Github dazu:</p><p><a href=\"https://github.com/NixOS/nix/issues/1450\">https://github.com/NixOS/nix/issues/1450</a></p><p>Ein paar Ausz√ºge:</p><ul>\n<li><em>‚ÄúscopedImport has nasty performance consequences since it disables\nthe parser/evaluation cache‚Äù</em></li>\n<li><em>‚ÄúIt allows doing some pretty nasty/nifty things like overriding\nevery primop (including import)‚Äù</em></li>\n</ul>\n<p>Ok, also die Finger davon lassen.  Es h√§tte mich trotzdem ein\nbisschen interessiert, wie man das benutzt, aber nicht so sehr,\ndass ich an der Stelle weiterbuddeln m√∂chte.</p><h3 id=\"fetchgit-fetchmercurial-fetchtarball-fetchtree\">fetchGit, fetchMercurial, fetchTarball, fetchTree</h3>\n<p>Mit den Fetch-Befehlen lassen sich Dateien herunterladen und in\nden Nix Store schreiben.  <code>fetchMercurial</code> und <code>fetchTree</code> sind\nundokumentiert, also schaue ich mir zun√§chst die anderen beiden an.</p><p><code>fetchGit</code> holt einen Pfad aus einem Git Repository und schreibt ihn\nin den Nix Store.  In der Nix Repl erh√§lt man mit <code>:doc fetchGit</code>\nreichlich Dokumentation dazu, wie das genau zu benutzen ist.\nIch m√∂chte das hier nicht alles wiedergeben.</p><p><code>fetchTarball</code> l√§dt ein Tar-Archiv herunter und entpackt es in den\nNix Sore.  Das Tar-Archiv kann (oder muss?) zus√§tzlich mit <code>gzip</code>,\n<code>bzip7</code> oder <code>xv</code> komprimiert sein.  Die Dokumentation in der Repl\ndazu ist auch recht ausf√ºhrlich.</p><p><code>fetchMercurial</code> ist in der Repl nicht dokumentiert.  Ich nehme an,\nes ist wie <code>fetchGit</code> aber f√ºr Mercurial Repositories.</p><p><code>fetchTree</code> ist ebenfalls undokumentiert in der Repl.  Das Nix\nManual erw√§hnt, dass <code>fetchTree</code> die Funktionalit√§t der\nanderen Fetch-Befehle in sich vereint und somit beliebige Quellen\nherunterladen kann.  M√∂glicherweise ist das nur eine Fassade,\ndie je nach Quelle das passende Backend w√§hlt, ungef√§hr so wie\n<code>aunpack</code> das Entpacken von Archivdateien handhabt.</p><h3 id=\"derivation-derivationstrict\">derivation, derivationStrict</h3>\n<p>Beides hat in der Nix Repl keine Dokumentation.  Was ist eine\nDerivation?  Man kann das w√∂rtlich mit Ableitung √ºbersetzen.\nIm Kontext von Nix ist damit eine sogenannte <em>Build Action</em>\ngemeint.  Ich nehme an, das ist ein Rezept f√ºr den Bau eines\nSoftwarepaketes und seine ‚ÄúInstallation‚Äù im Nix Store.  Laut Handbuch\nist <code>derivation</code> die wichtigste built-in Funktion: schlie√ülich ist\nNix genau daf√ºr gedacht/gemacht, solche Derivationen zu beschreiben\nund auszuf√ºhren.</p><p><code>derivation</code> verarbeitet ein Set, das genau beschreibt, was gebaut\nwird, und zwar mit den folgenden Schl√ºsseln (Attributen):</p><ul>\n<li><code>system</code><ul>\n<li>Nix Systemtyp, z.B. <code>&quot;i686-linux&quot;</code> oder <code>&quot;x86_64-darwin&quot;</code></li>\n<li>siehe <code>nix -vv --version</code></li>\n</ul>\n</li>\n<li><code>name</code><ul>\n<li>der Name des Pakets</li>\n</ul>\n</li>\n<li><code>builder</code><ul>\n<li>das Programm, welches zum Bauen verwendet wird</li>\n<li>kann eine Derivation oder eine lokale Datei sein (ein Script)</li>\n<li>Die Attribute der Derivation werden als Umgebungsvariable\n√ºbergeben:<ul>\n<li>Strings und Zahlen werden unver√§ndert √ºbergeben.</li>\n<li>Pfade werden zun√§chst in den Nix Store kopiert und der\nZielpfad landet in der Umgebungsvariable.</li>\n<li>Derivationen werden gebaut und der Pfad des Zielartefakts\nlandet in der Umgebungsvariable.<ul>\n<li>Listen werden leerzeichensepariert √ºbergeben.</li>\n<li><code>true</code> wird als <code>1</code> √ºbergeben.</li>\n<li><code>false</code> und <code>null</code> werden als <code>&quot;&quot;</code> √ºbergeben.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>args</code><ul>\n<li>optionale Liste von CLI-Argumenten f√ºr das bauende Programm</li>\n</ul>\n</li>\n<li><code>outputs</code><ul>\n<li>optionale Liste von Ausgabepfaden</li>\n<li>Normalerweise gibt es nur einen Outputpfad <code>out</code>, aber man\nkann diesen Schl√ºssel verwenden, um verschiedene Ausgabepfade\nzu deklarieren, bspw. <code>[ &quot;lib&quot; &quot;headers&quot; &quot;doc&quot; ]</code>, dann stehen\ndem bauenden Programm drei Pfade statt nur einem zur Verf√ºgung,\ndie separat garbage-collected werden k√∂nnen.</li>\n</ul>\n</li>\n</ul>\n<p>Damit habe ich eine erste, grobe Vorstlelung davon, wie Nix baut.</p><p>F√ºr <code>derivationStrict</code> habe ich nirgendwo Dokumentation gefunden.</p><h3 id=\"placeholder\">placeholder</h3>\n<p>Nimmt einen Ausgabepfad entgegen (<code>&quot;out&quot;</code>, <code>&quot;bin&quot;</code>, <code>&quot;dev&quot;</code>,\n‚Ä¶) und liefert einen Plazhalter, der beim Bauen durch den\nAusgabepfad ersetzt wird.  Es scheint wirklich eine Funktion zu sein:</p><pre><code>nix-repl&gt; placeholder &quot;out&quot;\n&quot;/1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9&quot;\n\nnix-repl&gt; placeholder &quot;out&quot;\n&quot;/1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9&quot;\n\nnix-repl&gt; placeholder &quot;out&quot;\n&quot;/1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9&quot;\n</code></pre>\n<p>Keine Ahnung, wof√ºr das gut ist.</p><h2 id=\"built-ins\">Built-ins</h2>\n<p>Im letzten Abschnitt habe ich mir die Namen angeschaut, die nach\ndem Start der Nix Repl unqualifiziert im Top-Level verf√ºgbar sind.\nUnterhalb von <code>builtins</code> gibt es eine ganze Reihe weiterer Namen.\nDie schaue ich mir jetzt an.  Einige davon sind nicht neu, weil\nsie auch im Top-Level verf√ºgbar sind.  Die lasse ich unerw√§hnt aus.</p><h3 id=\"builtinsadd\">builtins.add</h3>\n<p>Die Funktion hinter dem <code>+</code> Operator:</p><pre><code>nix-repl&gt; builtins.add 3 4\n7\n</code></pre>\n<h3 id=\"builtinsadderrorcontext\">builtins.addErrorContext</h3>\n<p>Daf√ºr finde ich keine Dokumentation.</p><h3 id=\"builtinsall\">builtins.all</h3>\n<p>Pr√ºft ob ein Pr√§dikat auf alle Elemente einer Liste zutrifft:</p><pre><code>nix-repl&gt; builtins.all ( n : n &gt; 3 ) [ 1 2 3 ]\nfalse\n\nnix-repl&gt; builtins.all ( n : n &gt; 3 ) [ 4 5 6 ]\ntrue\n</code></pre>\n<h3 id=\"builtinsany\">builtins.any</h3>\n<p>Pr√ºft ob ein Pr√§dikat auf mindestens ein Element einer Liste\nzutrifft:</p><pre><code>nix-repl&gt; builtins.any ( n : n &lt; 3 ) [ 1 2 3 ]\ntrue\n\nnix-repl&gt; builtins.any ( n : n &lt; 3 ) [ 4 5 6 ]\nfalse\n</code></pre>\n<h3 id=\"builtinsappendcontext\">builtins.appendContext</h3>\n<p>Daf√ºr finde ich keine Dokumentation.</p><h3 id=\"builtinsattrnames\">builtins.attrNames</h3>\n<p>Liefert eine sortierte Liste der Schl√ºssel in einem Set:</p><pre><code>nix-repl&gt; builtins.attrNames { a = 1 ; b = 2 ; c = 3 ; }\n[ &quot;a&quot; &quot;b&quot; &quot;c&quot; ]\n</code></pre>\n<h3 id=\"builtinsattrvalues\">builtins.attrValues</h3>\n<p>Wie Sartres Autodidakt, gehe ich die Built-ins in alphabetischer\nReihder sonderliche Autodidakt in Bouville, gehe ich die Built-ins in\nalphabetischer Reihenfolge durch.  Immerhin sind es bei mir nicht die\nB√ºcher einer ganzen Bibliothek, sondern nur ein paar Nix-Funktionen.\nJetzt w√§re <code>builtins.deepSeq</code></p><pre><code>nix-repl&gt; builtins.attrValues { a = 3 ; b = 2 ; c = 1 ; }\n[ 3 2 1 ]\n</code></pre>\n<h3 id=\"builtinsbitand\">builtins.bitAnd</h3>\n<p>Bitweise Konjunktion zweier Integers:</p><pre><code>nix-repl&gt; builtins.bitAnd 123 456\n72\n</code></pre>\n<p>Rechnen wir das spa√üeshalber durch:</p><pre><code>123 = 64  + 32  + 16  + 8   + 2   + 1\n    = 2^6 + 2^5 + 2^4 + 2^3 + 2^1 + 2^0\n    = 1111011\n\n456 = 256 + 128 + 64  + 8\n    = 2^8 + 2^7 + 2^6 + 2^3\n    = 111001000\n\n  001111011\n+ 111001000\n= 001001000 = 2^3 + 2^6 = 72\n</code></pre>\n<h3 id=\"builtinsbitor\">builtins.bitOr</h3>\n<p>Bitweise Disjunktion zweier Integers:</p><pre><code>nix-repl&gt; builtins.bitOr 123 456\n507\n</code></pre>\n<h3 id=\"builtinsbitxor\">builtins.bitXor</h3>\n<p>Bitweise Kontravalenz (‚Äúexklusive Disjunktion‚Äù) zweiter Integers:</p><pre><code>nix-repl&gt; builtins.bitXor 123 456\n435\n</code></pre>\n<h3 id=\"builtinsbuiltins\">builtins.builtins</h3>\n<p>Offenbar enth√§lt das <code>builtins</code> Set eine Referenz auf sich selbst.</p><pre><code>nix-repl&gt; builtins.builtins == builtins\ntrue\n\nnix-repl&gt; builtins.builtins.builtins.builtins == builtins\ntrue\n</code></pre>\n<p>Schrullig, aber was soll‚Äôs.</p><h3 id=\"builtinscatattrs\">builtins.catAttrs</h3>\n<p>Das nimmt einen Schl√ºssel (String) und sammelt aus einer Liste\nvon Sets die Werte f√ºr diesen Schl√ºssel ein:</p><pre><code>nix-repl&gt; builtins.catAttrs &quot;a&quot;\n...         [ { a = 1 ; } { b = 2 ; } { a = 3 ; } ]\n[ 1 3 ]\n</code></pre>\n<h3 id=\"builtinsceil\">builtins.ceil</h3>\n<p>Liefert f√ºr eine Zahl <code>x</code> die n√§chste Ganzzahl <code>n</code> sodass <code>x &lt;= n</code>:</p><pre><code>nix-repl&gt; builtins.ceil 1.5\n2\n\nnix-repl&gt; builtins.ceil 2\n2\n</code></pre>\n<h3 id=\"builtinscompareversions\">builtins.compareVersions</h3>\n<p>Vergleicht zwei Strings anhand der typischen Ordnung von\nVersionsnummern.  Das Ergebnis ist <code>-1</code>, <code>0</code> oder <code>1</code>, je nachdem\nob das erste Argument gegen√ºber dem zweiten kleiner, gleich oder\ngr√∂√üer ist.</p><pre><code>nix-repl&gt; builtins.compareVersions &quot;0.0.0&quot; &quot;0.0.1&quot;\n-1\n\nnix-repl&gt; builtins.compareVersions &quot;0.0.1&quot; &quot;0.0.1&quot;\n0\n\nnix-repl&gt; builtins.compareVersions &quot;0.0.2&quot; &quot;0.0.1&quot;\n1\n</code></pre>\n<h3 id=\"builtinsconcatlists\">builtins.concatLists</h3>\n<p>Konkateniert Listen:</p><pre><code>nix-repl&gt; builtins.concatLists [ [ 1 2 3 ] [ 4 5 6 ] ]\n[ 1 2 3 4 5 6 ]\n</code></pre>\n<h3 id=\"builtinsconcatmap\">builtins.concatMap</h3>\n<p>Das ist eine Verkettung von <code>map</code> und <code>concatLists</code>.  Das hei√üt,\nf√ºr eine Funktion <code>f</code> und eine Liste <code>ls</code> sind die folgenden beiden\nAusdr√ºcke √§quivalent:</p><p><code>builtins.concatLists (map f ls)</code></p><p><code>builtins.concatMap f ls</code></p><p>Beispielsweise:</p><pre><code>nix-repl&gt; with\n...         { f  = map ( n : 2 * n ) ;\n...           ls = [ [ 1 2 3 ] [ 4 5 6 ] ] ;\n...         } ;\n...         builtins.concatLists ( map f ls )\n[ 2 4 6 8 10 12 ]\n\nnix-repl&gt; with\n...         { f  = map ( n : 2 * n ) ;\n...           ls = [ [ 1 2 3 ] [ 4 5 6 ] ] ;\n...         } ;\n...         builtins.concatMap f ls\n[ 2 4 6 8 10 12 ]\n</code></pre>\n<h3 id=\"builtinsconcatstringssep\">builtins.concatStringsSep</h3>\n<p>Konkateniert Strings mit einem Trennzeichen:</p><pre><code>nix-repl&gt; builtins.concatStringsSep &quot;/&quot; [ &quot;usr&quot; &quot;local&quot; &quot;bin&quot; ]\n&quot;usr/local/bin&quot;\n</code></pre>\n<h3 id=\"builtinscurrentsystem\">builtins.currentSystem</h3>\n<p>Liefert einen Namen f√ºr das System, auf dem Nix gerade l√§uft:</p><pre><code>nix-repl&gt; builtins.currentSystem\n&quot;x86_64-linux&quot;\n</code></pre>\n<h3 id=\"builtinscurrenttime\">builtins.currentTime</h3>\n<p>Liefert die aktuelle Posix-Zeit:</p><pre><code>nix-repl&gt; builtins.currentTime\n1661168166\n</code></pre>\n<h3 id=\"builtinsseq\">builtins.seq</h3>\n<p>Wie der sonderliche Autodidakt in Bouville, gehe ich die Built-ins\nin alphabetischer Reihenfolge durch.  Immerhin sind es bei mir\nnicht die B√ºcher einer ganzen Bibliothek, sondern nur ein paar\nNix-Funktionen.  Jetzt w√§re <code>builtins.deepSeq</code> an der Reihe,\naber das w√§re Quatsch ohne vorher <code>builtins.seq</code> zu betrachten.\nDeswegen ziehe ich das vor.</p><p>Nix wertet verz√∂gert aus (so wie Haskell).  Das bedeutet, dass\nAusdr√ºcke erst dann ausgewertet werden wenn sie tats√§chlich\ngebraucht werden und auch nur so weit wie es tats√§chlich n√∂tig ist.\nIch m√∂chte das kurz an einem Beispiel demonstrieren.  Das geht\nvielleicht am besten mit einer Funktion, die viel Rechenzeit frisst.\nAd hoc f√§llt mir die Fibonacci-Funktion ein.  Das hier w√§re eine\neinfache Implementierung daf√ºr in Haskell:</p><pre><code>-- Haskell:\n\nfib n =\n    if n &lt; 1 then 0\n    else if n &lt; 2 then 1\n    else fib ( n - 1 ) + fib ( n - 2 )\n</code></pre>\n<p>Das ist so rechenaufw√§ndig, dass ich mit meinem Rechner auf <code>fib 32</code> schon ein paar Sekunden warten muss, also ein guter Kandidat.\nWir k√∂nnen das auch als Lambda-Ausdruck schreiben.  Dann wandert\nder Parameter <code>n</code> nach rechts hinter das <code>=</code> Zeichen:</p><pre><code>-- Haskell:\n\nfib = \\ n -&gt;\n    if n &lt; 1 then 0\n    else if n &lt; 2 then 1\n    else fib ( n - 1 ) + fib ( n - 2 )\n</code></pre>\n<p>In Nix m√ºssen Funktionen als Lambda-Ausdr√ºcke notiert werden.\nDie konventionelle Notation mit dem Parameter auf der linken Seite\nwird nicht unterst√ºtzt.  Mein erster Versuch, diese Funktion in\nNix zu schreiben, sah so aus:</p><pre><code>nix-repl&gt; fib = n :\n...         if n &lt; 1 then 0\n...         else if n &lt; 2 then 1\n...         else fib ( n - 1 ) + fib ( n - 2 )\nerror: undefined variable &#39;fib&#39;\n</code></pre>\n<p>Nix unterst√ºtzt keine rekursiven Funktionen, jedenfalls nicht auf\ndiese Weise.  Damit das klappt, m√ºssen wir die Funktion in ein\nrekursives Set stecken:</p><pre><code>nix-repl&gt; funs = rec\n...         { fib = n :\n...             if n &lt; 1 then 0\n...             else if n &lt; 2 then 1\n...             else fib ( n - 1 ) + fib ( n - 2 ) ;\n...         }\n\nnix-repl&gt; funs.fib 32\n2178309\n</code></pre>\n<p>Nix rechnet <code>funs.fib 32</code> schneller aus als Haskell aber es dauert\nmit meinem Rechner immer noch mehr als eine Sekunde, bis der\nInterpreter die Berechnung gestemmt hat und das Ergebnis ausdruckt.\nDamit haben wir alles beisammen um verz√∂gerte Auswertung zu\ndemonstrieren.  Daf√ºr erg√§nzen wir das Set um zwei weitere\nSchl√ºssel-Wert-Paare:</p><pre><code>nix-repl&gt; funs = rec\n...         { fib = n :\n...             if n &lt; 1 then 0\n...             else if n &lt; 2 then 1\n...             else fib ( n - 1 ) + fib ( n - 2 ) ;\n...\n...           fib35 = fib 35 ;\n...           x = 1 ;\n...         }\n\nnix-repl&gt;\n</code></pre>\n<p>Den Wert f√ºr den Schl√ºssel <code>fib35</code> auszurechnen, sollte\nein paar Sekunden dauern, aber die Nix Repl nimmt das Set ohne\nZeitverz√∂gerung entgegen.  Das spricht daf√ºr, dass der Wert f√ºr\n<code>fib35</code> nicht sofort berechnet wird.  Wir k√∂nnen uns auch den Wert\nf√ºr den Schl√ºssel <code>x</code> ohne Zeitverz√∂gurung ausgeben lassen:</p><pre><code>nix-repl&gt; funs.x\n1\n</code></pre>\n<p>Erst wenn wir uns den Wert f√ºr <code>fib35</code> ausgeben lassen, gibt es eine\ndeutliche Verz√∂gerung von mehreren Sekunden, die darauf hinweist,\ndass der Wert jetzt tats√§chlich berechnet wird:</p><pre><code>nix-repl&gt; funs.fib35\n9227465\n</code></pre>\n<p>Wenn wir uns im Anschluss noch einmal das ganze Set ausgeben lassen,\ngeschieht das wieder ohne Verz√∂gerung:</p><pre><code>nix-repl&gt; funs\n{ fib = ¬´lambda @ (string):1:14¬ª; fib35 = 9227465; x = 1; }\n</code></pre>\n<p>Der Wert f√ºr den Schl√ºssel <code>fib35</code> wurde schon berechnet und\nwird hier einfach wiederverwendet anstatt ihn ein zweites Mal zu\nberechnen.  Deswegen erfolgt die Ausgabe ohne zeitliche Verz√∂gerung.\nWenn wir vorher nicht <code>funs.fib35</code> ausgewertet h√§tten, dann\nh√§tten wir an dieser Stelle ein paar Sekunden auf die Auswertung\nwarten m√ºssen.</p><p>Das ist verz√∂gerte Auswertung: die Ausdr√ºcke und Teilausdr√ºcke\nwerden nicht sofort ausgewertet sondern erst dann wenn ihr Wert\ntats√§chlich ben√∂tigt wird, bspw. um eine Ausgabe zu erzeuen.</p><p>Im Allgemeinen ist das eine gute Sache, aber manchmal m√∂chte\nman, dass die Auswertung nicht verz√∂gert sondern sofort\nstattfindet.  Das ist vor allem dann wichtig, wenn zwei Ausdr√ºcke\nirgendwelche externen Effeke haben und diese Effekte in einer\nbestimmen Reihenfolge auftreten sollen.  Dann muss man irgendwie\nsicherstellen, dass die Ausdr√ºcke in der richtigen Reihenfolge\nausgewertet werden.  In Programmiersprachen, die standardm√§√üig\nstrikt (i.e. unverz√∂gert) auswerten, hat man dieses Problem nicht.\nDa ist die Auswertungsreihenfolge dadurch vorgegeben, in welcher\nReihenfolge man Ausdr√ºcke notiert.  In Programmiersprachen, die\nstandardm√§√üig verz√∂gert auswerten, ben√∂tigt man daf√ºr besondere\nHilfsmittel, die eine strikte Auswertung sicherstellen.</p><p>Hier kommt <code>builtins.seq</code> ins Spiel.  <code>builtins.seq</code> nimmt zwei\nAusdr√ºcke entgegen, wertet den ersten Ausdruck aus, verwirft das\nResultat und wertet dann den zweiten Ausdruck aus:</p><pre><code>nix-repl&gt; builtins.seq 1 2\n2\n</code></pre>\n<p>So wird sichergestellt, dass der erste Ausdruck vor dem zweiten\nausgewertet wird.  Ich kann gerade kein leicht demonstrierbares\nBeispiel aus dem √Ñrmel sch√ºtteln, bei dem das eine Rolle spielen\nw√ºrde, aber wenn bspw. der erste Ausdruck eine Datei schreibt und\nder zweite diese Datei liest, stellt <code>builtins.seq</code> sicher, dass das\nSchreiben tats√§chlich vor dem Lesen erfolgt.  Ohne <code>builtins.seq</code>\nw√§re diese Reihenfolge wegen der verz√∂gerten Auswertung nicht\nsichergestellt.</p><h3 id=\"builtinsdeepseq\">builtins.deepSeq</h3>\n<p>Die Auswertung von <code>builtins.seq e1 e2</code> ist zwar strikt im Ausdruck\n<code>e1</code>, aber mit einem Haken: der Ausdruck <code>e1</code> wird nur oberfl√§chlich\nstrikt ausgewertet.  Ich erkl√§re kurz, was das bedeutet.  Es gibt\neinfache Ausdr√ºcke, die direkt ausgewertet werden k√∂nnen ohne\ndaf√ºr weiter vereinfacht werden zu m√ºssen.  Das sind bspw. einfache\nZahlenausdr√ºcke <code>123</code> oder Zeichenketten wie <code>&quot;asdf&quot;</code>.  Daneben gibt\nes aber auch komplexe Ausdr√ºcke, die bei der Auswertung zun√§chst\nauf einen einfachen Ausdruck reduziert werden m√ºssen.  Das ist\nder Fall wenn ein Ausdruck Funktionen (bzw. Operationen) enth√§lt,\ndie bei der Auswertung angewendet werden m√ºssen.  Diese Reduktion\nauf einen einfachen Ausdruck erfolgt schrittweise.  Hier ist ein\nAusdruck, der in mehreren Schritten ausgewertet werden muss:</p><pre><code>nix-repl&gt; let\n...         f1 = n : 1 + n ;\n...         f2 = n : 2 + n ;\n...         f3 = n : 3 + n ;\n...       in\n...         f3 ( f2 ( f1 0 ) )\n</code></pre>\n<p>Hier ist eine m√∂gliche Auswertung f√ºr diesen Ausdruck:</p><pre><code>=&gt; f3            ( f2            ( f1            0 ) )\n-----------------------------------^^^^^^^^^^^^^----------\n=&gt; f3            ( f2            ( ( n : 1 + n ) 0 ) )\n-----------------------------------^^^^^^^^^^^^^^^--------\n=&gt; f3            ( f2            ( 1 + 0           ) )\n---------------------------------^^^^^^^^^^^^^^^^^^^------\n=&gt; f3            ( f2            1                   )\n-------------------^^^^^^^^^^^^^--------------------------\n=&gt; f3            ( ( n : 2 + n ) 1                   )\n-------------------^^^^^^^^^^^^^^^------------------------\n=&gt; f3            ( 2 + 1                             )\n-----------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^----\n=&gt; f3            3\n---^^^^^^^^^^^^^------------------------------------------\n=&gt; ( n : 3 + n ) 3\n---^^^^^^^^^^^^^^^----------------------------------------\n=&gt; 3 + 3\n---^^^^^--------------------------------------------------\n=&gt; 6\n</code></pre>\n<p>Ob die Auswertung tats√§chlich genau in dieser Reihenfolge\nstattfindet, wei√ü ich nicht.  Es gibt da verschiedene\nM√∂glichkeiten.  Relevant ist f√ºr uns nur, dass die Auswertung\nschrittweise erfolgt.</p><p>Wenn das nun der Teilausausdruck <code>e1</code> im Ausdruck <code>builtins.seq e1 e2</code> w√§re, w√ºrde <code>builtins.seq</code> nicht garantieren, dass das ganze\nvor der Auswertung von <code>e2</code> vollst√§ndig auf den Wert <code>6</code> reduziert\nwird.  <code>builtins.seq</code> w√ºrde lediglich gew√§hrleisten, dass <code>e1</code> auf\nder ersten Ebene strikt ausgewertet wird, also vielleicht bis <code>f3 ( f2 ( 1 + 0 ) )</code>.  Damit w√§re die Funktion <code>f1</code> schon vollst√§ndig\nabgefr√ºhst√ºckt, aber wenn sich in <code>f2</code> oder <code>f3</code> noch irgendwelche\nexternen Nebeneffekte verbergen w√ºrden, w√§re durch <code>builtins.seq</code>\nnicht sichergestellt, dass diese Effekte vor der Auswertung von\n<code>e2</code> eintreten.  Genau das war gemeint mit der Feststellung,\n<code>builtins.seq</code> w√ºrde <code>e1</code> nur oberfl√§chlich strikt auswerten.</p><p>Ich m√∂chte hier anmerken, dass ich mich mit dieser Erl√§uterung\nrecht weit aus dem Fenster lehne.  Ich wei√ü nicht, wie der Nix\nInterpreter tats√§chlich auswertet und ob meine Charakterisierung\neiner nur oberfl√§chlich strikten Auswertung den Nagel auf den Kopf\ntrifft.  Ich hoffe, dass es hier kein fundamentales Missverst√§ndnis\nmeinerseits gibt, das diese Erl√§uterung zu Stuss macht.  In jedem\nFall ist das gegenw√§rtig mein mentales Modell dieser Sache.</p><p>Wenn <code>e1</code> eine Prozedur wie <code>fetchGit</code> ist, die direkt einen externen\nNebeneffekt erzeugt, gen√ºgt die oberfl√§chlich strikte Auswertung\ndurch <code>builtins.seq</code>, aber wenn ein komplexer Ausdruck vollst√§ndig,\nalso in voller Tiefe, strikt ausgewertet werden soll, muss daf√ºr\n<code>builtins.deepSeq</code> verwendet werden.</p><p>Meine Motivation, daf√ºr ein gutes Beispiel zu finden, ist bei Null,\ndenn ich habe noch reichlich Built-ins vor mir.  Vielleicht erg√§nze\nich sp√§ter eins.</p><h3 id=\"builtinsdiv\">builtins.div</h3>\n<p>Die Funktion hinter dem Divisionsoperator <code>/</code>, den wir schon weiter\noben behandelt haben:</p><pre><code>nix-repl&gt; builtins.div 7.0 2\n3.5\n\nnix-repl&gt; builtins.div 7 2\n3\n</code></pre>\n<h3 id=\"builtinselem\">builtins.elem</h3>\n<p>Pr√ºft, ob ein Wert als Element in einer Liste enthalten ist:</p><pre><code>nix-repl&gt; builtins.elem 3 [ 1 2 3 ]\ntrue\n\nnix-repl&gt; builtins.elem 4 [ 1 2 3 ]\nfalse\n</code></pre>\n<h3 id=\"builtinselemat\">builtins.elemAt</h3>\n<p>Liefert das n-te Element einer Liste:</p><pre><code>nix-repl&gt; builtins.elemAt [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ] 0\n&quot;a&quot;\n\nnix-repl&gt; builtins.elemAt [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ] 1\n&quot;b&quot;\n\nnix-repl&gt; builtins.elemAt [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ] 2\n&quot;c&quot;\n\nnix-repl&gt; builtins.elemAt [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ] 3\nerror: list index 3 is out of bounds\n</code></pre>\n<p>Das hier ist aufschlussreich:</p><pre><code>nix-repl&gt; builtins.elemAt [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ] -1\nerror: value is the partially applied built-in function &#39;elemAt&#39;\n       while an integer was expected\n</code></pre>\n<p>Die Fehlermeldung legt nahe, dass das Minuszeichen hier nicht als\nVorzeichen sondern als Subtraktionsoperator interpretiert wird.\nUm das zu √§ndern, muss man Klammern setzen:</p><pre><code>nix-repl&gt; builtins.elemAt [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ] (-1)\nerror: list index -1 is out of bounds\n</code></pre>\n<p>Immer noch ein Fehler, aber ein besserer.</p><h3 id=\"builtinsfetchurl\">builtins.fetchurl</h3>\n<p>L√§dt etwas herunter, legt es im Nix Store ab und gibt den Pfad aus:</p><pre><code>nix-repl&gt; builtins.fetchurl https://arxiv.org/pdf/2208.10524\n[4.2 MiB DL]&quot;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524&quot;\n</code></pre>\n<p>Wenn man schon im Vorfeld den SHA-256 Hash der Datei kennt, kann\nman den Hash mit angeben und damit kryptografisch verifizieren,\ndass es die richtige Datei ist:</p><pre><code>nix-repl&gt; builtins.fetchurl\n...         { url = https://arxiv.org/pdf/2208.10524 ;\n...           sha256 = &quot;cbd791862a937ac2f823b81a771e63bdb5313d204e0011965c833ee3889fdc73&quot; ;\n...         }\n&quot;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524&quot;\n</code></pre>\n<p>Wenn der Hash nicht passt, l√∂st das einen Fehler aus:</p><pre><code>nix-repl&gt; builtins.fetchurl\n...         { url = https://arxiv.org/pdf/2208.10524 ;\n...           sha256 = &quot;ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot; ;\n...         }\nerror: hash mismatch in file downloaded from &#39;https://arxiv.org/pdf/2208.10524&#39;:\n         specified: sha256:1zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\n                  got:       sha256:0wywky4f6gl3bjb1202f40yk3ddxccg7f6mq4gwc4ylk5a393myb\n                  [4.2 MiB DL]\n</code></pre>\n<p>Der Hash in der Fehlermeldung unterscheidet sich von dem Hash in der Anweisung:</p><pre><code>sha256 = &quot;ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot; ;\n...\nspecified: sha256:1zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\n</code></pre>\n<p>Ich nehme an, dass Nix einfach nur eine andere Darstellung verwendet\num die Hashes kompakter zu machen.  Man sieht das auch daran,\ndass der Hash im Nix Store Pfad ein anderer ist.  Es w√§re gut,\nzu wissen, welcher Hash und welche Darstellung das genau ist,\naber darum k√ºmmere ich mich sp√§ter.</p><p>Ich bin mir gar nich sicher, ob Nix die Datei jetzt noch einmal\nheruntergeladen hat oder einfach die bereits heruntergeladene Datei\nwiederverwendet hat.  Also w√ºrde ich gern die Datei aus dem Store\nl√∂schen und dann noch einmal herunterladen.  Wie geht das?  So:</p><pre><code>$ nix-store --delete\n    /nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524\n</code></pre>\n<p>Aber Achtung: Bevor man die Datei aus dem Store l√∂schen kann,\nmuss man die Nix Repl terminieren.  Solange die Repl noch l√§uft,\nverweigert Nix das L√∂schen, weil die Datei noch in Verwendung ist.</p><p>Ich lade die Datei also noch einmal mit einem falschen Hash herunter:</p><pre><code>nix-repl&gt; builtins.fetchurl\n...         { url = https://arxiv.org/pdf/2208.10524 ;\n...           sha256 = &quot;ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot; ;\n...         }\nerror: hash mismatch in file downloaded from &#39;https://arxiv.org/pdf/2208.10524&#39;:\n         specified: sha256:1zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\n                  got:       sha256:0wywky4f6gl3bjb1202f40yk3ddxccg7f6mq4gwc4ylk5a393myb\n                  [4.2 MiB DL]\n                  n\n</code></pre>\n<p>Die finale Ausgabe stimmt √ºberein, aber die Ausf√ºhrung hat deutlich\nl√§nger gedauert, weil Nix die Datei wirklich ein weiteres Mal\nheruntergeladen hat.</p><p>Mit <code>builtins.fetchurl</code> haben wir also die M√∂glichkeit, beliebige\nDateien aus dem Netz herunterzuladen und die Echtheit dieser Dateien\ndurch Angabe eines SHA-256 Hashes abzusichern.  Das bedeutet, dass\nwir Dateien, deren Hash wir bereits kennen, aus beliebigen Quellen\nherunterladen k√∂nnen, ohne uns Sorgen dar√ºber machen zu m√ºssen,\ndass vielleicht jemand diese Dateien ohne unser Wissen ver√§ndert\nhaben k√∂nnte.  Das ist gro√üartig!  Nix ist ein System f√ºr die\nVerwaltung von Softwarepaketen, aber auch jenseits davon fallen\nmir f√ºr so etwas viele Einsatzm√∂glichkeiten ein.</p><h3 id=\"builtinsfilter\">builtins.filter</h3>\n<p>Bereinigt eine Liste um alle Elemente, denen ein bestimmtes\nPr√§dikat fehlt:</p><pre><code>nix-repl&gt; isEven = n : n / 2 == n / 2.0\n\nnix-repl&gt; builtins.filter isEven\n...         [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ]\n[ 2 4 6 8 10 12 14 16 ]\n</code></pre>\n<h3 id=\"builtinsfiltersource\">builtins.filterSource</h3>\n<p>Damit kann man Quellen in den Nix Store √ºbertragen und dabei gewisse\nDateien herausfiltern.  N√§her will ich das hier nicht betrachten.\nDie Dokumentation enth√§lt eine Warnung, die man vor dem Gebrauch\nlesen und verstehen sollte.</p><h3 id=\"builtinsfindfile\">builtins.findFile</h3>\n<p>Weder in der Nix Repl noch im Handbuch dokumentiert.</p><h3 id=\"builtinsfloor\">builtins.floor</h3>\n<p>Liefert f√ºr eine Zahl <code>x</code> die n√§chste Ganzzahl <code>n</code> sodass <code>x &gt;= n</code>:</p><pre><code>nix-repl&gt; builtins.floor 1.5\n1\n\nnix-repl&gt; builtins.floor 1\n1\n</code></pre>\n<h3 id=\"builtinsfoldl\">builtins.foldl‚Äô</h3>\n<p>Damit kann man eine Liste von Werten sozusagen ‚Äúzusammenfalten‚Äù\nauf einen einzigen Wert, indem man sukzessive von links nach rechts\neine Funktion darauf anwendet, die jeweils zwei Werte mit einander\nkombiniert.  Man muss einen Startwert mit √ºbergeben.  Ausgehend\nvon diesem Startwert werden sukzessive die Elemente der Liste\neingesammelt und mit dem bisherigen Zwischenergebnis kombiniert.</p><p>Hier wird eine Liste von Zahlen via <code>builtins.add</code> mit dem Startwert\n<code>0</code> zusammengefaltet:</p><pre><code>nix-repl&gt; builtins.foldl&#39; builtins.add 0 [ 1 2 3 4 5 6 ]\n21\n</code></pre>\n<p>Das entspricht einer Verallgemeinerung der zweiwertigen Addition\nauf beliebig viele Werte.  Mit <code>builtins.foldl&#39;</code> lassen sich viele\nzweiwertige Funktionen auf nat√ºrliche Weise verallgemeinern auf\nbeliebig viele Werte.  Das setzt nat√ºrlich voraus, dass es zu den\nWerten, auf denen man operiert einen neutralen Wert gibt, also eine\nEntsprechung zur Null bei den Zahlen.  Mathematisch ist so eine\nStruktur artikuliert im algebraischen Begriff eines <em>Monoiden</em>.\nDamit muss man sich aber nicht unbedingt befassen: in der Praxis\nkann man auch einfach ein paar Werte mit <code>builtins.foldl&#39;</code>\nzusammenstauchen, ohne sich vorher Gedanken dar√ºber zu machen,\nob man wirklich eine Null zur Verf√ºgung hat.</p><p>Das zweite <code>l</code> in <code>foldl</code> steht f√ºr <em>left</em>, weil von rechts nach\nlinks gefaltet wird.  Nix stellt nur diese eine Funktion als Built-in\nzur Verf√ºgung, aber im Allgemeinen gibt es auch Faltungsfunktionen\ndie von links nach rechts falten.  Die hei√üen dann typischerweise\n<code>foldr</code>.  Bei der Addition macht das keinen Unterschied, aber bei\nFunktionen, die nicht kommutativ sind ,bei denen also das Ergebnis\nvon der Reihenfolge der beiden Argumente abh√§ngt, h√§ngt auch das\nErgebnis einer Faltung davon ab, in welche Richtung gefaltet wird.</p><p>Das abschlie√üende Hochkomma im Namen <code>builtins.foldl&#39;</code>\nsoll anzeigen, dass diese Funktion strikt ausgewertet wird.\nIch bin weiter oben darauf eingegangen, dass Nix standardm√§√üig\nverz√∂gert auswertet und dass man in manchen F√§llen lieber eine\nstrikte Auswertung haben m√∂chte.  Das hier ist ein solcher Fall.\nDas Hochkomma ist nur eine Namenskonvention, die warscheinlich\ndaher r√ºhrt, dass man sich hier recht stark an Haskell orientiert.\nIn Haskell wertet die <code>foldl</code> Funktion aus der Standardbibliothek\nverz√∂gert aus. Daneben gibt es auch eine mit Hochkomma markierte\n<code>foldl&#39;</code> Funktion, die strikt auswertet.  In der Praxis will\nman eigentlich immer eine strikte Faltung nach links, also w√§re\nes vielleicht besser gewesen, die strikte Variante <code>foldl</code> (ohne\nHochkomma) zu nennen.  Schade, dass Nix sich an dieser ung√ºnstigen\nKonvention orientiert, zumal ohnehin nur diese eine Faltungsfunktion\nals Built-in mitgeliefert wird.</p><h3 id=\"builtinsfromjson\">builtins.fromJSON</h3>\n<p>Parst und √ºberf√ºhrt JSON-Werte in Nix-Werte:</p><pre><code>nix-repl&gt; builtins.fromJSON &quot;{ \\&quot;a\\&quot; : 1 , \\&quot;b\\&quot; : 2 , \\&quot;c\\&quot; : 3 }&quot;\n{ a = 1; b = 2; c = 3; }\n\nnix-repl&gt; builtins.fromJSON &quot;[ 1, 2, 3 ]&quot;\n[ 1 2 3 ]\n\nnix-repl&gt; builtins.fromJSON &quot;123.456&quot;\n123.456\n\nnix-repl&gt; builtins.fromJSON &quot;\\&quot;asdf\\&quot;&quot;\n&quot;asdf&quot;\n</code></pre>\n<h3 id=\"builtinsfunctionargs\">builtins.functionArgs</h3>\n<p>Nimmt eine Funktion entgegen und liefert ein Set mit den Namen ihrer\nParameter als Schl√ºssel.  Die Werte geben f√ºr jeden Parameter\nAuskunft dar√ºber, ob es zu ihm einen Standardwert gibt:</p><pre><code>nix-repl&gt; builtins.functionArgs ( { x , y ? 123 } : x + y )\n{ x = false; y = true; }\n</code></pre>\n<p>Das Fragezeichen ist neue Syntax f√ºr mich.  Ziemlich weit am Anfang\ndieses Dokumentes hatte ich Set Patterns erw√§hnt, die man verwenden\nkann, um benannte Funktionsparameter aufzuschreiben:</p><pre><code>nix-repl&gt; ({a,b} : a + b) { a = 5 ; b = 6 ; }\n11\n</code></pre>\n<p>Offenbar kann man mit dem Fragezeichen Standardargumente festhalten:</p><pre><code>nix-repl&gt; ({a?5,b?6} : a + b) {}\n11\n\nnix-repl&gt; ({a?5,b?6} : a + b) { a = 11 ; }\n17\n\nnix-repl&gt; ({a?5,b?6} : a + b) { b = 12 ; }\n17\n\nnix-repl&gt; ({a?5,b?6} : a + b) { a = 11 ; b = 12 ; }\n23\n</code></pre>\n<p>Die sinnvolle Verwendung von <code>builtins.functionArgs</code> setzt nat√ºrlich\nvoraus, dass eine Funktion mit benannten Parametern via Set Patterns\naufgeschrieben worden ist.  F√ºr reine Lambda-Funktionen liefert\n<code>builtins.functionArgs</code> immer ein leeres Set:</p><pre><code>nix-repl&gt; builtins.functionArgs ( a : b : a + b )\n{ }\n</code></pre>\n<h3 id=\"builtinsgenlist\">builtins.genList</h3>\n<p><code>builtins.genlist f n</code> erzeugt eine Liste der L√§nge <code>n</code>, wobei\ndie Funktion <code>f</code> die jeweiligen Elemente aus den jeweiligen Indizes\nberechnet:</p><pre><code>nix-repl&gt; builtins.genList ( x : -x ) 4\n[ 0 -1 -2 -3 ]\n\nnix-repl&gt; builtins.genList ( x : 1.0/(x+1) ) 4\n[ 1 0.5 0.333333 0.25 ]\n</code></pre>\n<h3 id=\"builtinsgenericclosure\">builtins.genericClosure</h3>\n<p>Das ist eine eigenartig spezifische und zugleich eigenartig\nallgemeine Funktion!  Sie erinnert mich ein bisschen an das M√§rchen\nvom s√º√üen Brei.  Ich w√ºrde wirklich gern wissen, wof√ºr sie\ngedacht ist.  Ich erkenne darin jedenfalls keine so klare und\nuniversell brauchbare Abstraktion wie <code>map</code> oder <code>filter</code> oder\n<code>foldl</code>.</p><p><code>builtins.genericClosure</code> nimmt ein Set mit den Schl√ºsseln\n<code>startSet</code> und <code>operator</code> entgegen.  <code>startSet</code> ist eine\nListe mit Sets.  <code>operator</code> ist eine Funktion, die auf einem\nSet operiert und daraus eine Liste von weiteren Sets erzeugt.\n<code>builtins.genericClosure</code> verwendet ausgehend von der <code>startSet</code>\nListe die <code>operator</code> Funktion um rekursiv aus den bestehenden Sets\nweitere Sets zu berechnen.  Alle hier erw√§hnten Sets (abgesehen\nvon dem √§u√üeren) m√ºssen einen Schl√ºssel <code>key</code> enthalten.\nAlle Sets, mit einem <code>key</code> Wert, der schon einmal aufgetaucht\nist, werden verworfen.  Sobald keine Sets mit neuen <code>key</code> Werten\nhinzukommen, endet die Rekursion.</p><p>Das ist ziemlich kompliziert.  Hier sind ein paar Beispiele.\nZun√§chst der einfachste Fall:</p><pre><code>nix-repl&gt; builtins.genericClosure\n...         { startSet = [] ;\n...           operator = s : [] ;\n...         }\n[ ]\n</code></pre>\n<p>Wir f√ºllen <code>startSet</code> mit ein paar Sets:</p><pre><code>nix-repl&gt; builtins.genericClosure\n...         { startSet =\n...             [ { key = 5 ; }\n...               { key = 6 ; }\n...               { key = 7 ; }\n...             ] ;\n...           operator = s : [] ;\n...         }\n[ { ... } { ... } { ... } ]\n</code></pre>\n<p>Die Auslassungpunkte kommen daher, dass die Nix Repl beim\nAuswerten und beim Ausgeben der Ergebnisse maximal eine Ebene in\ndie Tiefe geht.  Bisher bin ich darauf nicht eingegangen, aber\ndas ist schon einmal vorgekommen, n√§mlich im Abschnitt <a href=\"#c1447d05c6ee4163ccfb5686d986ca8318492d7f\"><em>Sets\n(Mengen)</em></a> wo ich die\nKurznotation f√ºr verschachtelte Sets einf√ºhre.  Man erh√§lt die\nAuslassungspunkte schon wenn man eine Liste in eine Liste steckt:</p><pre><code>nix-repl&gt; [[]]\n[ [ ... ] ]\n</code></pre>\n<p>Die innere Liste ist leer, aber der Interpreter schaut gar nicht\nerst hinein sondern gibt sie gleich mit den Auslassungspunkten aus.</p><p>Man kann die Nix Repl veranlassen, einen Ausdruck in voller Tiefe\nauszuwerten und das Ergebnis in voller Tiefe auszugeben.  Daf√ºr muss\nman dem auszuwertenden Ausdruck die Repl-Anweisung <code>:p</code> voranstellen.\nDamit k√∂nnen wir uns wieder <code>builtins.genericClosure</code> zuwenden:</p><pre><code>nix-repl&gt; :p builtins.genericClosure\n...             { startSet =\n...                 [ { key = 5 ; }\n...                   { key = 6 ; }\n...                   { key = 7 ; }\n...                 ] ;\n...               operator = s : [] ;\n...             }\n[ { key = 5; } { key = 6; } { key = 7; } ]\n</code></pre>\n<p>Dass Sets, deren <code>key</code> schon einmal vorgekommen ist, verworfen\nwerden, gilt schon f√ºr die Sets in der <code>startSet</code> Liste:</p><pre><code>nix-repl&gt; :p builtins.genericClosure\n...             { startSet =\n...                 [ { key = 5 ; }\n...                   { key = 6 ; }\n...                   { key = 7 ; }\n...                   { key = 5 ; }\n...                 ] ;\n...               operator = s : [] ;\n...             }\n[ { key = 5; } { key = 6; } { key = 7; } ]\n</code></pre>\n<p>Um die Wirkung der <code>operator</code> Funktion zu demonstrieren,\ninkrementieren wir einfach die <code>key</code> Werte.  Damit\n<code>built.genericClosure</code> trotzdem terminiert, m√ºssen wir das irgendwo\ndeckeln.  Ich schlage vor, wir belassen es bei <code>key &lt; 10</code>:</p><pre><code>nix-repl&gt; :p builtins.genericClosure\n...             { startSet =\n...                 [ { key = 5 ; }\n...                   { key = 6 ; }\n...                   { key = 7 ; }\n...                   { key = 5 ; }\n...                 ] ;\n...               operator = s :\n...                 [ { key =\n...                         if s.key &lt; 9\n...                         then s.key + 1\n...                         else s.key ;\n...                   }\n...                 ] ;\n...             }\n[ { key = 5; } { key = 6; } { key = 7; } { key = 8; } { key = 9; } ]\n</code></pre>\n<p>Das hei√üt, wir inkrementieren den <code>key</code> Wert so lange er\nkleiner als <code>9</code> ist.  Das Set mit <code>key = 9</code> wird noch erzeugt,\naber dar√ºber kommt nichts mehr.  Die Ausgabe ist so wie ich es\nerwartet habe.  Ich glaube, ich habe damit vollst√§ndig erfasst,\nwas <code>builtins.genericClosure</code> macht.  Einen guten Anwendungsfall\ndaf√ºr habe ich nicht, aber zumindest den vagen Eindruck, dass man\ndamit etwas n√ºtzliches machen kann, vielleicht irgend etwas in\nRichtung transitiver H√ºllen.</p><h3 id=\"builtinsgetattr\">builtins.getAttr</h3>\n<p>Liefert aus einem Set den Wert zu einem Schl√ºssel:</p><pre><code>nix-repl&gt; builtins.getAttr &quot;foo&quot; { foo = 123 ; }\n123\n</code></pre>\n<p>Wenn es den Schl√ºssel nicht gibt, l√∂st das einen Fehler aus:</p><pre><code>nix-repl&gt; builtins.getAttr &quot;bar&quot; { foo = 123 ; }\nerror: attribute &#39;bar&#39; missing for call to &#39;getAttr&#39;\n</code></pre>\n<p>Das selbe kann man nat√ºrlich schon mit dem <code>.</code> Operator machen:</p><pre><code>nix-repl&gt; s = { foo = 123 ; }\n\nnix-repl&gt; s.foo\n123\n</code></pre>\n<p>Aber es gibt einen Unterschied: <code>builtins.getAttr</code> nimmt den\nSchl√ºssel als String.  Dadurch kann man den Schl√ºssel dynamisch\nkonstruieren:</p><pre><code>nix-repl&gt; s = { foo = 123 ; }\n\nnix-repl&gt; builtins.getAttr ( &quot;f&quot; + &quot;o&quot; + &quot;o&quot; ) s\n123\n</code></pre>\n<p>Update: der <code>.</code> Operator akzeptiert auch Strings:</p><pre><code>nix-repl&gt; { foo = 123 ; }.&quot;foo&quot;\n123\n</code></pre>\n<p>Aber dynamisch konstruieren kann man den Schl√ºssel trotzdem nicht:</p><pre><code>nix-repl&gt; { foo = 123 ; }.( &quot;f&quot; + &quot;o&quot; + &quot;o&quot; )\nerror: syntax error, unexpected &#39;(&#39;, ...\n\nnix-repl&gt; { foo = 123 ; }.( &quot;foo&quot; )\nerror: syntax error, unexpected &#39;(&#39;, ...\n</code></pre>\n<h3 id=\"builtinsgetcontext\">builtins.getContext</h3>\n<p>Weder in der Nix Repl noch im Handbuch dokumentiert.</p><h3 id=\"builtinsgetenv-1\">builtins.getEnv</h3>\n<p>Liefert den Wert einer Umgebungsvariable als String:</p><pre><code>nix-repl&gt; builtins.getEnv &quot;HOME&quot;\n&quot;/home/aramis&quot;\n</code></pre>\n<p>F√ºr fehlende Umgebungsvariable wird der leere String wird der\nleere String gegeben:</p><pre><code>nix-repl&gt; builtins.getEnv &quot;sa0iboojav9ood5C&quot;\n&quot;&quot;\n</code></pre>\n<h3 id=\"builtinsgetflake\">builtins.getFlake</h3>\n<p>L√§dt eine Nix Flake herunter und gibt ihre Attribute zusammen\nmit ein paar Metadaten aus.</p><p>Flakes sind ein alternativer Mechanismus um Abh√§ngigkeiten zu\nbeschreiben und Software in den Nix Store herunterzuladen.\nNix Channels folgen in der Handhabung dem typischen\nPaketverwaltungsmodell von Linux Distros:  Es gibt Kan√§le, in denen\nversionierte Softwarepakete verf√ºgbar sind, die man bei Bedarf\nherunterladen kann.  Um seine Software auf dem neusten Stand zu\nhalten, ruft man zun√§chst aus seinen Kan√§len Informationen zu\nden aktuellen Versionen ab und installiert dann Updates f√ºr die\nSoftware, die nicht mehr auf dem neusten Stand ist.</p><p>So sieht das f√ºr die Debian/Ubuntu Paketverwaltung aus:</p><pre><code>$ apt update            # Aktualisiere Kan√§le\n$ apt upgrade           # Aktualisiere Softwarepakete\n</code></pre>\n<p>So sieht das f√ºr Nix aus:</p><pre><code>$ nix-channel --update  # Aktualisiere Kan√§le\n$ nix-env --upgrade     # Aktualisiere Softwarepakete\n</code></pre>\n<p>Mit Debian/Ubuntu verwendet man <code>apt</code> f√ºr beide Schritte.  Mit Nix\nverwendet man im ersten Schritt <code>nix-channel</code> und im zweiten Schritt\n<code>nix-env</code>, aber an den Flags sieht man schon, mit wes Geistes Kind\nman es hier zu tun hat.</p><p>Im Unterschied dazu, orientieren sich Flakes an Paketverwaltungen wie\nCargo (Rust) oder NPM (JS).  Es gibt keine Kan√§le.  Man deklariert\ndie Abh√§ngigkeiten einer Software als Git Repositories in einer\n<code>flake.nix</code> Datei.  W√§hrend der Installation der Abh√§ngigkeiten\nwird eine <code>flake.lock</code> Datei erzeugt, welche die Hashes der\nverwendeten Git Commits protokolliert und dadurch die Abh√§ngigkeiten\nsozusagen einfriert.</p><p>Flakes sind noch als experimentell markiert und m√ºssen in einer\nKonfigurationsdatei aktiviert werden bevor sie verwendet werden\nk√∂nnen:</p><pre><code>$ echo experimental-features = nix-command flakes  \n    &gt;&gt; ~/.config/nix/nix.conf\n</code></pre>\n<p>Ich habe mir, √ºber das hier aufgeschriebene hinaus, Flakes noch\nnicht genauer angeschaut.</p><h3 id=\"builtinsgroupby\">builtins.groupBy</h3>\n<p><code>builtings.groupBy f ls</code> gruppiert die Liste <code>ls</code> anhand der Funktion\n<code>f</code>:</p><pre><code>nix-repl&gt; isEven = n : n / 2 == n / 2.0\n\nnix-repl&gt; :p builtins.groupBy\n...             ( n : toString ( isEven n ) ) [ 1 2 3 4 5 6 7 8 9 ]\n{ &quot;&quot; = [ 1 3 5 7 9 ]; &quot;1&quot; = [ 2 4 6 8 ]; }\n</code></pre>\n<p>Dabei muss <code>f</code> stets einen String zur√ºckgeben.  Sonst funktioniert\ndas nicht:</p><pre><code>nix-repl&gt; :p builtins.groupBy isEven [ 1 2 3 4 5 6 7 8 9 ]\nerror: value is a Boolean while a string was expected\n</code></pre>\n<h3 id=\"builtinshasattr\">builtins.hasAttr</h3>\n<p>Pr√ºft ob ein Schl√ºssel in einem Set enthalten ist:</p><pre><code>nix-repl&gt; builtins.hasAttr &quot;foo&quot; {}\nfalse\n\nnix-repl&gt; builtins.hasAttr &quot;foo&quot; { foo = 123 ; }\ntrue\n</code></pre>\n<p>Offenbar gibt es auch einen <code>?</code> Operator, der dasselbe macht:</p><pre><code>nix-repl&gt; {} ? &quot;foo&quot;\nfalse\n\nnix-repl&gt; { foo = 123 ; } ? &quot;foo&quot;\ntrue\n</code></pre>\n<p>Der <code>?</code> Operator kann den zu pr√ºfenden Schl√ºssel nicht nur als\nString sondern auch als einfachen Bezeichner verarbeiten:</p><pre><code>nix-repl&gt; { foo = 123 ; } ? foo\ntrue\n\nnix-repl&gt; {} ? foo\nfalse\n</code></pre>\n<p>Der <code>?</code> Operator hat die selbe Beschr√§nkung wie der <code>.</code> Operator,\nn√§mlich dass der Schl√ºssel nicht dynamisch erzeugt werden kann:</p><pre><code>nix-repl&gt; { foo = 123 ; } ? ( &quot;f&quot; + &quot;o&quot; + &quot;o&quot; )\nerror: syntax error, unexpected &#39;(&#39;, ...\n\nnix-repl&gt; { foo = 123 ; } ? ( &quot;foo&quot; )\nerror: syntax error, unexpected &#39;(&#39;, ...\n</code></pre>\n<h3 id=\"builtinshascontext\">builtins.hasContext</h3>\n<p>Weder in der Nix Repl noch im Handbuch dokumentiert.</p><h3 id=\"builtinshashfile\">builtins.hashFile</h3>\n<p>Erzeugt einen Hash Wert aus einer Datei.  Erwartet werden zwei\nArgumente.  Das erste Argument ist der Hash-Algorithmus.  M√∂glich\nsind <code>&quot;md5&quot;</code>, <code>&quot;sha1&quot;</code>, <code>&quot;sha256&quot;</code> und <code>&quot;sha512&quot;</code>.  Das zweite\nArgument ist der Pfad zur Datei.  Der Pfad kann als Nix Pfad oder\nals String √ºbergeben werden.</p><pre><code>nix-repl&gt; builtins.hashFile &quot;md5&quot;\n...         /nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524\n&quot;ffab34ab46902e10183dc2a065e50ebd&quot;\n\nnix-repl&gt; builtins.hashFile &quot;md5&quot;\n...         &quot;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524&quot;\n&quot;ffab34ab46902e10183dc2a065e50ebd&quot;\n\nnix-repl&gt; builtins.hashFile &quot;sha1&quot;\n...         /nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524\n&quot;95936f2f3d784c7a90623acfbb9d093384f5a6a2&quot;\n\nnix-repl&gt; builtins.hashFile &quot;sha1&quot;\n...         &quot;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524&quot;\n&quot;95936f2f3d784c7a90623acfbb9d093384f5a6a2&quot;\n</code></pre>\n<p>Die Funktion verarbeitet beliebige Pfade, auch au√üerhalb des Nix\nStore.  Leider wei√ü ich jetzt immer noch nicht, was es mit dem Hash\n<code>97ggi3ryxkvdljycw05nq82bgs6kdxcx</code> im Store Path auf sich hat.</p><h3 id=\"builtinshashstring\">builtins.hashString</h3>\n<p>Erzeugt einen Hash Wert aus einem String.  Erwartet werden\nzwei Argumente.  Das erste Argument ist der Hash-Algorithmus.\nM√∂glich sind <code>&quot;md5&quot;</code>, <code>&quot;sha1&quot;</code>, <code>&quot;sha256&quot;</code> und <code>&quot;sha512&quot;</code>.\nDas zweite ist der zu verarbeitende String:</p><pre><code>nix-repl&gt; builtins.hashString &quot;md5&quot; &quot;foobar&quot;\n&quot;3858f62230ac3c915f300c664312c63f&quot;\n</code></pre>\n<h3 id=\"builtinshead\">builtins.head</h3>\n<p>Liefert das erste Element einer Liste:</p><pre><code>nix-repl&gt; builtins.head [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ]\n&quot;a&quot;\n</code></pre>\n<p>Wenn man sich das ganze im mathematichen Sinne als eine Abbildung von\nder Menge aller Listen auf die Menge aller m√∂glichen Listenelemente\nvorzustellen versucht, stellt man fest, dass es in der Sprechweise\nder Schulmathematik eine m√∂gliche Definitionsl√ºcke gibt: n√§mlich\nbei der leeren Liste:</p><pre><code>nix-repl&gt; builtins.head []\nerror: list index 0 is out of bounds\n</code></pre>\n<p>Die Fehlermeldung l√§sst vermuten, dass <code>builtins.head ls</code>\nintern in <code>builtins.elemAt ls 0</code> √ºbersetzt wird.  Jedenfalls\nl√∂st die Funktion f√ºr die leere Liste einen Fehler aus.  Es ist\nstrenggenommen nur eine partielle Funktion.  Das ist schade, wobei\nich hier noch mehr Verst√§ndnis daf√ºr habe als bei der <code>head</code>\nFunktion aus der Haskell Standardbibliothek, die das gleiche\nProblem hat.</p><h3 id=\"builtinsintersectattrs\">builtins.intersectAttrs</h3>\n<p>Erwartet zwei Sets und liefert ein Set mit den Schl√ºssel-Wert-Paaren\naus dem zweiten Set, deren Schl√ºssel auch im ersten Set vorkommen:</p><pre><code>nix-repl&gt; builtins.intersectAttrs\n...         { a = 1 ; b = 2 ; } { b = 3 ; c = 4 ; }\n{ b = 3; }\n</code></pre>\n<h3 id=\"builtinsisattrs\">builtins.isAttrs</h3>\n<p>Pr√ºft, ob es sich bei einem Wert um ein Set handelt:</p><pre><code>nix-repl&gt; builtins.isAttrs {}\ntrue\n\nnix-repl&gt; builtins.isAttrs 123\nfalse\n</code></pre>\n<h3 id=\"builtinsisbool\">builtins.isBool</h3>\n<p>Pr√ºft, ob es sich bei einem Wert um einen boolschen Wert handelt:</p><pre><code>nix-repl&gt; builtins.isBool false\ntrue\n\nnix-repl&gt; builtins.isBool 123\nfalse\n</code></pre>\n<h3 id=\"builtinsisfloat\">builtins.isFloat</h3>\n<p>Pr√ºft, ob es sich bei einem Wert um eine Flie√ükommazahl handelt:</p><pre><code>nix-repl&gt; builtins.isFloat 123.456\ntrue\n\nnix-repl&gt; builtins.isFloat 123\nfalse\n</code></pre>\n<h3 id=\"builtinsisfunction\">builtins.isFunction</h3>\n<p>Pr√ºft, ob es sich bei einem Wert um eine Funktion handelt:</p><pre><code>nix-repl&gt; builtins.isFunction ( x : x )\ntrue\n\nnix-repl&gt; builtins.isFunction 123\nfalse\n</code></pre>\n<h3 id=\"builtinsisint\">builtins.isInt</h3>\n<p>Pr√ºft, ob es sich bei einem Wert um eine Ganzzahl handelt:</p><pre><code>nix-repl&gt; builtins.isInt 123\ntrue\n\nnix-repl&gt; builtins.isInt &quot;123&quot;\nfalse\n</code></pre>\n<h3 id=\"builtinsislist\">builtins.isList</h3>\n<p>Pr√ºft, ob es sich bei einem Wert um eine Liste handelt:</p><pre><code>nix-repl&gt; builtins.isList []\ntrue\n\nnix-repl&gt; builtins.isList 123\nfalse\n</code></pre>\n<h3 id=\"builtinsispath\">builtins.isPath</h3>\n<p>Pr√ºft, ob es sich bei einem Wert um einen Nix Pfad handelt:</p><pre><code>nix-repl&gt; builtins.isPath ./.\ntrue\n\nnix-repl&gt; builtins.isPath 123\nfalse\n</code></pre>\n<h3 id=\"builtinsisstring\">builtins.isString</h3>\n<p>Pr√ºft, ob es sich bei einem Wert um eine Zeichenkette (String)\nhandelt:</p><pre><code>nix-repl&gt; builtins.isString &quot;&quot;\ntrue\n\nnix-repl&gt; builtins.isString 123\nfalse\n</code></pre>\n<h3 id=\"builtinslangversion\">builtins.langVersion</h3>\n<p>Undokumentiert.  Wahrscheinlich ist Nix (die Sprache) irgendwie\nversioniert:</p><pre><code>nix-repl&gt; builtins.langVersion\n6\n</code></pre>\n<h3 id=\"builtinslength\">builtins.length</h3>\n<p>Liefert die L√§nge einer Liste:</p><pre><code>nix-repl&gt; builtins.length [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ]\n3\n</code></pre>\n<h3 id=\"builtinslessthan\">builtins.lessThan</h3>\n<p>Die Funktion hinter dem <code>&lt;</code> Operator:</p><pre><code>nix-repl&gt; builtins.lessThan 3 4\ntrue\n\nnix-repl&gt; builtins.lessThan 4 3\nfalse\n</code></pre>\n<h3 id=\"builtinslisttoattrs\">builtins.listToAttrs</h3>\n<p>Verarbeitet eine Liste von Sets mit Schl√ºsseln <code>name</code> und <code>value</code>\nzu einem Set mit entsprechenden Schl√ºssel-Wert-Paaren:</p><pre><code>nix-repl&gt; builtins.listToAttrs\n...         [ { name = &quot;foo&quot; ; value = 123 ; }\n...           { name = &quot;bar&quot; ; value = 456 ; }\n...         ]\n{ bar = 456; foo = 123; }\n</code></pre>\n<h3 id=\"builtinsmapattrs\">builtins.mapAttrs</h3>\n<p>Eine Map-Funktion f√ºr Sets, die auf den Werten operiert und dabei\ndie Schl√ºssel ber√ºcksichtigen kann:</p><pre><code>nix-repl&gt; builtins.mapAttrs\n...         ( k : v : k + &quot;:&quot; + builtins.toString v )\n...         { a = 1 ; b = 2 ; c = 3 ; }\n{ a = &quot;a:1&quot;; b = &quot;b:2&quot;; c = &quot;c:3&quot;; }\n</code></pre>\n<h3 id=\"builtinsmatch\">builtins.match</h3>\n<p>Erwartet einen regul√§ren Ausdruck und einen String.  Der regul√§re\nAusdruck kann RegEx-Gruppen enthalten.  Als Ergebnis liefert\n<code>builtins.match</code> eine Liste der √úbereinstimmungen f√ºr diese\nRegEx-Gruppen.  Ohne RegEx-Gruppen ist das Ergebnis nat√ºrlich die\nleere Liste (bei √úbereinstimmung).  Wenn der String nicht auf den\nregul√§ren Ausdruck passt, ist das Ergebnis <code>null</code>:</p><pre><code>nix-repl&gt; builtins.match &quot;foo&quot; &quot;bar&quot;\nnull\n\nnix-repl&gt; builtins.match &quot;foo&quot; &quot;foo&quot;\n[ ]\n\nnix-repl&gt; builtins.match &quot;a(b)c(d)e&quot; &quot;abcde&quot;\n[ &quot;b&quot; &quot;d&quot; ]\n</code></pre>\n<p>RegEx-Gruppen sind Teile eines regul√§ren Ausdrucks, die durch\nKlammern hervorgehoben sind.  Man verwendet sie, um nicht nur zu\npr√ºfen ob ein String auf einen regul√§ren Ausdruck passt, sondern\nauch Teile aus dem String zu extrahieren. Beispielsweise k√∂nnte man\neinen regul√§ren Ausdruck f√ºr postalische Adressen konstruieren,\nder die Stra√üe, die Hausnummer, die Postleitzahl und die Stadt\nextrahiert.</p><h3 id=\"builtinsmul\">builtins.mul</h3>\n<p>Die Funktion hinter dem <code>*</code> Operator:</p><pre><code>nix-repl&gt; builtins.mul 3 5\n15\n</code></pre>\n<h3 id=\"builtinsnixpath\">builtins.nixPath</h3>\n<p>Weder in der Nix Repl noch im Handbuch dokumentiert.</p><pre><code>nix-repl&gt; :p builtins.nixPath\n[ { path = &quot;/home/aramis/.nix-defexpr/channels&quot;; prefix = &quot;&quot;; } ]\n</code></pre>\n<h3 id=\"builtinsnixversion\">builtins.nixVersion</h3>\n<p>Liefert die Nix Versionsnummer:</p><pre><code>nix-repl&gt; builtins.nixVersion\n&quot;2.10.3&quot;\n</code></pre>\n<p>Die Nix Versionsnummer wird auch ausgegeben wenn man die Repl\nstartet:</p><pre><code>$ nix repl\nWelcome to Nix 2.10.3. Type :? for help.\n\nnix-repl&gt;\n</code></pre>\n<h3 id=\"builtinsparsedrvname\">builtins.parseDrvName</h3>\n<p>Zerlegt einen Paketbezeichner der Form <code>&lt;Name&gt;-&lt;Version&gt;</code> in den\nNamen und die Version des Pakets auf.  Das Ergebnis wird als Set\nmit den Schl√ºsseln <code>name</code> und <code>version</code> gegeben:</p><pre><code>nix-repl&gt; builtins.parseDrvName &quot;nix-0.12pre12876&quot;\n{ name = &quot;nix&quot;; version = &quot;0.12pre12876&quot;; }\n</code></pre>\n<p>Die beiden Teile m√ºssen durch einen Bindestrich getrennt sein.\nDie Version muss mit Ziffern beginnen.  Sonst ist mindestens einer\nder beiden Werte der leere String:</p><pre><code>nix-repl&gt; builtins.parseDrvName &quot;&quot;\n{ name = &quot;&quot;; version = &quot;&quot;; }\n\nnix-repl&gt; builtins.parseDrvName &quot;foo123&quot;\n{ name = &quot;foo123&quot;; version = &quot;&quot;; }\n\nnix-repl&gt; builtins.parseDrvName &quot;foo-bar&quot;\n{ name = &quot;foo-bar&quot;; version = &quot;&quot;; }\n\nnix-repl&gt; builtins.parseDrvName &quot;foo-1bar&quot;\n{ name = &quot;foo&quot;; version = &quot;1bar&quot;; }\n</code></pre>\n<h3 id=\"builtinspartition\">builtins.partition</h3>\n<p>Trennt die Spreu vom Weizen:</p><pre><code>nix-repl&gt; :p builtins.partition ( n : n &gt; 3 ) [ 1 2 3 4 5 6 ]\n{ right = [ 4 5 6 ]; wrong = [ 1 2 3 ]; }\n</code></pre>\n<h3 id=\"builtinspath\">builtins.path</h3>\n<p>F√ºgt Daten zum Nix Store hinzu.  Die funktion nimmt ein Set\nals Argument entgegen.  Nur der Schl√ºssel <code>path</code> ist Pflicht.\nHier sind alle Schl√ºssel:</p><ul>\n<li><code>path</code>: der Pfad zu den Daten</li>\n<li><code>name</code>: der Pfadname im Nix Store</li>\n<li><code>filter</code>: die Funktion; filtert unerw√ºnschte Unterpfade heraus</li>\n<li><code>recursive</code>:<ul>\n<li><code>false</code>: f√ºgt den Pfad mit einem flachen Hash zum Store hinzu</li>\n<li><code>true</code>: f√ºgt den Pfad mit einem Hash der NAR Serialisierung\nzum Store hinzu</li>\n</ul>\n</li>\n<li><code>sha256</code>: der zu erwartende Hash f√ºr die Daten in <code>path</code></li>\n</ul>\n<p>NAR steht f√ºr <em>Nix Archive</em>.  Das ist ein Serialisierungsformat\nf√ºr Dateisystemobjekte (i.e. Dateien, Verzeichnisse, Symlinks).\nNAR ist vergleichbar mit Archivformaten wie TAR und ZIP.\nAllerdings kann es bei diesen Formaten f√ºr ein und dasselbe\nObjekt mehrere g√ºltige Serialisierungen geben, zum Beispiel\nweil die Reihenfolge der Serialisierung von Verzeichnisinhalten\nnicht definiert ist oder weil eine variable Menge an F√ºllbytes\nzwischen Segmenten der Serialisierung zul√§ssig ist oder weil\nauch Zeitstempel mit in die Serialisierung aufgenommen werden.\nDie Beziehung zwischen einem serialisierten Objekt und den Bytes\nseiner Serialisierung hat somit keinen Abbildungscharakter.\nDas macht diese Archivformate unbrauchbar wenn der Hash der\nSerialisierung als Hash f√ºr das serialisierte Objekt geeignet\nsein soll.  NAR ist speziell daf√ºr entwickelt worden,\nDateisystemobjekte f√ºr das Hashing zu serialisieren und\nl√§sst keinen Implementierungsspielraum, der die Serialisierung\neines Dateisystemobjektes in verschiedene Bytefolgen gestatten\nw√ºrde. (Quelle: <a href=\"https://edolstra.github.io/pubs/phd-thesis.pdf\">https://edolstra.github.io/pubs/phd-thesis.pdf</a>)</p><p>F√ºgt Daten zum Nix Store hinzu.  Die funktion nimmt ein Set\nals Argument entgegen.  Nur der Schl√ºssel <code>path</code> ist Pflicht.\nHier sind alle Schl√ºssel:</p><ul>\n<li><code>path</code>: der Pfad zu den Daten</li>\n<li><code>name</code>: der Pfadname im Nix Store</li>\n<li><code>filter</code>: die Funktion; filtert unerw√ºnschte Unterpfade heraus</li>\n<li><code>recursive</code>:<ul>\n<li><code>false</code>: f√ºgt den Pfad mit einem flachen Hash zum Store hinzu</li>\n<li><code>true</code>: f√ºgt den Pfad mit einem Hash der NAR Serialisierung\nzum Store hinzu</li>\n</ul>\n</li>\n<li><code>sha256</code>: der zu erwartende Hash f√ºr die Daten in <code>path</code></li>\n</ul>\n<p>NAR steht f√ºr <em>Nix Archive</em>.  Das ist ein Serialisierungsformat\nf√ºr Dateisystemobjekte (i.e. Dateien, Verzeichnisse, Symlinks).\nNAR ist vergleichbar mit Archivformaten wie TAR und ZIP.\nAllerdings kann es bei diesen Formaten f√ºr ein und dasselbe\nObjekt mehrere g√ºltige Serialisierungen geben, zum Beispiel\nweil die Reihenfolge der Serialisierung von Verzeichnisinhalten\nnicht definiert ist oder weil eine variable Menge an F√ºllbytes\nzwischen Segmenten der Serialisierung zul√§ssig ist oder weil\nauch Zeitstempel mit in die Serialisierung aufgenommen werden.\nDie Beziehung zwischen einem serialisierten Objekt und den Bytes\nseiner Serialisierung hat somit keinen Abbildungscharakter.\nDas macht diese Archivformate unbrauchbar wenn der Hash der\nSerialisierung als Hash f√ºr das serialisierte Objekt geeignet\nsein soll.  NAR ist speziell daf√ºr entwickelt worden,\nDateisystemobjekte f√ºr das Hashing zu serialisieren und\nl√§sst keinen Implementierungsspielraum, der die Serialisierung\neines Dateisystemobjektes in verschiedene Bytefolgen gestatten\nw√ºrde. (Quelle: <a href=\"https://edolstra.github.io/pubs/phd-thesis.pdf\">https://edolstra.github.io/pubs/phd-thesis.pdf</a>)</p><h3 id=\"builtinspathexists\">builtins.pathExists</h3>\n<p>Pr√ºft, ob ein Pfad im lokalen Dateisystem existiert:</p><pre><code>nix-repl&gt; builtins.pathExists /home/aramis\ntrue\n\nnix-repl&gt; builtins.pathExists /home/foo\nfalse\n</code></pre>\n<p>Kann auch Strings verarbeiten:</p><pre><code>nix-repl&gt; builtins.pathExists &quot;/&quot;\ntrue\n</code></pre>\n<p>Oben hatte ich ein paar Prozeduren aufgelistet, die Nix <em>impure</em>\nmachen.  Diese hier (und die nachfolgenden) h√§tte man auch mit\nauflisten k√∂nnen.</p><p>Pr√ºft, ob ein Pfad im lokalen Dateisystem existiert:</p><pre><code>nix-repl&gt; builtins.pathExists /home/aramis\ntrue\n\nnix-repl&gt; builtins.pathExists /home/foo\nfalse\n</code></pre>\n<p>Kann auch Strings verarbeiten:</p><pre><code>nix-repl&gt; builtins.pathExists &quot;/&quot;\ntrue\n</code></pre>\n<p>Oben hatte ich ein paar Prozeduren aufgelistet, die Nix <em>impure</em>\nmachen.  Diese hier (und die nachfolgenden) h√§tte man auch mit\nauflisten k√∂nnen.</p><h3 id=\"builtinsreaddir\">builtins.readDir</h3>\n<p>Liefert f√ºr einen Verzeichnispfad ein Set mit den\nVerzeichnisinhalten als Schl√ºssel und den jeweiligen Dateitypen\nals Werte:</p><pre><code>nix-repl&gt; builtins.readDir /home\n{ aramis = &quot;directory&quot;; }\n</code></pre>\n<p>Die m√∂glichen Werte f√ºr den Dateityp sind  <code>&quot;regular&quot;</code>,\n<code>&quot;directory&quot;</code>, <code>&quot;symlink&quot;</code> und <code>&quot;unknown&quot;</code>.</p><p>Liefert f√ºr einen Verzeichnispfad ein Set mit den\nVerzeichnisinhalten als Schl√ºssel und den jeweiligen Dateitypen\nals Werte:</p><pre><code>nix-repl&gt; builtins.readDir /home\n{ aramis = &quot;directory&quot;; }\n</code></pre>\n<p>Die m√∂glichen Werte f√ºr den Dateityp sind  <code>&quot;regular&quot;</code>,\n<code>&quot;directory&quot;</code>, <code>&quot;symlink&quot;</code> und <code>&quot;unknown&quot;</code>.</p><h3 id=\"builtinsreadfile\">builtins.readFile</h3>\n<p>Liefert den Inhalt einer Datei als String:</p><pre><code>$ echo hallo &gt; greeting.txt\n\n$ nix repl\nWelcome to Nix 2.10.3. Type :? for help.\n\nnix-repl&gt; builtins.readFile ./greeting.txt\n&quot;hallo\\n&quot;\n</code></pre>\n<p>Liefert den Inhalt einer Datei als String:</p><pre><code>$ echo hallo &gt; greeting.txt\n\n$ nix repl\nWelcome to Nix 2.10.3. Type :? for help.\n\nnix-repl&gt; builtins.readFile ./greeting.txt\n&quot;hallo\\n&quot;\n</code></pre>\n<h3 id=\"builtinsreplacestrings\">builtins.replaceStrings</h3>\n<p>Ersetzt alle Vorkommen eines Teilstrings:</p><pre><code>nix-repl&gt; builtins.replaceStrings [ &quot;o&quot; ] [ &quot;x&quot; ] &quot;foobar&quot;\n&quot;fxxbar&quot;\n\nnix-repl&gt; builtins.replaceStrings [ &quot;o&quot; &quot;a&quot; ] [ &quot;x&quot; &quot;y&quot; ] &quot;foobar&quot;\n&quot;fxxbyr&quot;\n</code></pre>\n<p>Ersetzt alle Vorkommen eines Teilstrings:</p><pre><code>nix-repl&gt; builtins.replaceStrings [ &quot;o&quot; ] [ &quot;x&quot; ] &quot;foobar&quot;\n&quot;fxxbar&quot;\n\nnix-repl&gt; builtins.replaceStrings [ &quot;o&quot; &quot;a&quot; ] [ &quot;x&quot; &quot;y&quot; ] &quot;foobar&quot;\n&quot;fxxbyr&quot;\n</code></pre>\n<h3 id=\"builtinssort\">builtins.sort</h3>\n<p>Sortiert eine Liste anhand einer Vergleichsfunktion:</p><pre><code>nix-repl&gt; builtins.sort\n...         ( a : b : a &lt; b )\n...         [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ]\n[ 1 1 2 3 3 3 4 5 5 5 6 7 8 9 9 9 ]\n\nnix-repl&gt; builtins.sort\n...         ( a : b : a &gt; b )\n...         [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ]\n[ 9 9 9 8 7 6 5 5 5 4 3 3 3 2 1 1 ]\n</code></pre>\n<p>Sortiert eine Liste anhand einer Vergleichsfunktion:</p><pre><code>nix-repl&gt; builtins.sort ( a : b : a &lt; b ) [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ]\n[ 1 1 2 3 3 3 4 5 5 5 6 7 8 9 9 9 ]\n\nnix-repl&gt; builtins.sort ( a : b : a &gt; b ) [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ]\n[ 9 9 9 8 7 6 5 5 5 4 3 3 3 2 1 1 ]\n</code></pre>\n<h3 id=\"builtinssplit\">builtins.split</h3>\n<p>Zerteilt einen String anhand eines regul√§ren Ausdrucks in\neine Liste.  Alles, was auf den regul√§ren Ausdruck passt,\nwird als Trennzeichen behandelt.  Der regul√§re Ausdruck kann\nRegEx-Gruppen enthalten.  An jeder Trennstelle wird eine Liste mit\nden √úbereinstimmungen f√ºr die RegEx-Gruppen an dieser Stelle in\ndie Ergebnisliste aufgenommen.  Ohne RegEx-Gruppen werden an den\nTrennstellen entsprechend leere Listen eingef√ºgt:</p><pre><code>nix-repl&gt; :p builtins.split &quot;a&quot; &quot;bacadaeafagahai&quot;\n[ &quot;b&quot; [ ] &quot;c&quot; [ ] &quot;d&quot; [ ] &quot;e&quot; [ ] &quot;f&quot; [ ] &quot;g&quot; [ ] &quot;h&quot; [ ] &quot;i&quot; ]\n\nnix-repl&gt; builtins.split &quot;a&quot; &quot;bcde&quot;\n[ &quot;bcde&quot; ]\n</code></pre>\n<p>Siehe <a href=\"#a05994c6afa9711449ac4d8bfdd8b0eb9c1e4996\"><code>builtins.match</code></a>\nf√ºr mehr zu RegEx-Gruppen.</p><p>Zerteilt einen String anhand eines regul√§ren Ausdrucks in\neine Liste.  Alles, was auf den regul√§ren Ausdruck passt,\nwird als Trennzeichen behandelt.  Der regul√§re Ausdruck kann\nRegEx-Gruppen enthalten.  An jeder Trennstelle wird eine Liste mit\nden √úbereinstimmungen f√ºr die RegEx-Gruppen an dieser Stelle in\ndie Ergebnisliste aufgenommen.  Ohne RegEx-Gruppen werden an den\nTrennstellen entsprechend leere Listen eingef√ºgt:</p><pre><code>nix-repl&gt; :p builtins.split &quot;a&quot; &quot;bacadaeafagahai&quot;\n[ &quot;b&quot; [ ] &quot;c&quot; [ ] &quot;d&quot; [ ] &quot;e&quot; [ ] &quot;f&quot; [ ] &quot;g&quot; [ ] &quot;h&quot; [ ] &quot;i&quot; ]\n\nnix-repl&gt; builtins.split &quot;a&quot; &quot;bcde&quot;\n[ &quot;bcde&quot; ]\n</code></pre>\n<p>Siehe <a href=\"#builtinsmatch\"><code>builtins.match</code></a> f√ºr mehr zu RegEx-Gruppen.</p><h3 id=\"builtinssplitversion\">builtins.splitVersion</h3>\n<p>Teilt einen String, der eine (Software) Version darstellt, in seine\nBestandteile auf.  Ich bin mir nicht 100%ig sicher, aber ich denke,\ndie Trennstellen sind Punkte <code>.</code>, Bindestriche <code>-</code> und √úberg√§nge\nzwischen Ziffern und Buchstaben:</p><pre><code>nix-repl&gt; builtins.splitVersion &quot;a.b-c123e&quot;\n[ &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;123&quot; &quot;e&quot; ]\n</code></pre>\n<p>Teilt einen String, der eine (Software) Version darstellt, in seine\nBestandteile auf.  Ich bin mir nicht 100%ig sicher, aber ich denke,\ndie Trennstellen sind Punkte <code>.</code>, Bindestriche <code>-</code> und √úberg√§nge\nzwischen Ziffern und Buchstaben:</p><pre><code>nix-repl&gt; builtins.splitVersion &quot;a.b-c123e&quot;\n[ &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;123&quot; &quot;e&quot; ]\n</code></pre>\n<h3 id=\"builtinsstoredir\">builtins.storeDir</h3>\n<p>Undokumentiert.  Liefert den Pfad zum Nix Store als String:</p><pre><code>nix-repl&gt; builtins.storeDir\n&quot;/nix/store&quot;\n</code></pre>\n<p>Undokumentiert.  Liefert den Pfad zum Nix Store als String:</p><pre><code>nix-repl&gt; builtins.storeDir\n&quot;/nix/store&quot;\n</code></pre>\n<h3 id=\"builtinsstorepath\">builtins.storePath</h3>\n<p>Alles, was ein Programm ben√∂tigt, um gebaut zu werden, soll sich\nim Nix Store befinden.  Entsprechend werden die Abh√§ngigkeiten,\ndie in Ableitungen (Derivations) deklariert sind, zun√§chst zum Nix\nStore hinzugef√ºgt.  Das geschieht normalerweise auch dann, wenn\nsich etwas schon im Nix Store befindet.  Mit <code>builtins.storePath</code>\nkann man das vermeiden.</p><p>Alles, was ein Programm ben√∂tigt, um gebaut zu werden, soll sich\nim Nix Store befinden.  Entsprechend werden die Abh√§ngigkeiten,\ndie in Ableitungen (Derivations) deklariert sind, zun√§chst zum Nix\nStore hinzugef√ºgt.  Das geschieht normalerweise auch dann, wenn\nsich etwas schon im Nix Store befindet.  Mit <code>builtins.storePath</code>\nkann man das vermeiden.</p><h3 id=\"builtinsstringlength\">builtins.stringLength</h3>\n<p>Liefert die L√§nge eines Strings:</p><pre><code>nix-repl&gt; builtins.stringLength &quot;asdf&quot;\n4\n</code></pre>\n<p>Liefert die L√§nge eines Strings:</p><pre><code>nix-repl&gt; builtins.stringLength &quot;asdf&quot;\n4\n</code></pre>\n<h3 id=\"builtinssub\">builtins.sub</h3>\n<p>Die Funktion hinter dem <code>-</code> Operator:</p><pre><code>nix-repl&gt; builtins.sub 7 5\n2\n</code></pre>\n<p>Die Funktion hinter dem <code>-</code> Operator:</p><pre><code>nix-repl&gt; builtins.sub 7 5\n2\n</code></pre>\n<h3 id=\"builtinssubstring\">builtins.substring</h3>\n<p>Selbsterkl√§rend:</p><pre><code>nix-repl&gt; builtins.substring 0 3 &quot;nixos&quot;\n&quot;nix&quot;\n</code></pre>\n<p>Selbsterkl√§rend:</p><pre><code>nix-repl&gt; builtins.substring 0 3 &quot;nixos&quot;\n&quot;nix&quot;\n</code></pre>\n<h3 id=\"builtinstail\">builtins.tail</h3>\n<p>Liefert eine Liste ohne das erste Element:</p><pre><code>nix-repl&gt; builtins.tail [ 1 2 3 ]\n[ 2 3 ]\n\nnix-repl&gt; builtins.tail []\nerror: &#39;tail&#39; called on an empty list\n</code></pre>\n<p>Liefert eine Liste ohne das erste Element:</p><pre><code>nix-repl&gt; builtins.tail [ 1 2 3 ]\n[ 2 3 ]\n\nnix-repl&gt; builtins.tail []\nerror: &#39;tail&#39; called on an empty list\n</code></pre>\n<h3 id=\"builtinstofile-1\">builtins.toFile</h3>\n<p>Schreibt einen String in eine Datei im Nix Store und gibt den Pfad\ndieser Datei zur√ºck:</p><pre><code>nix-repl&gt; builtins.toFile &quot;greeting&quot; &quot;hallo&quot;\n&quot;/nix/store/8fday1j2s9rpc28yirwbjp59a1wr3rx3-greeting&quot;\n</code></pre>\n<p>Die Datei kann dann beispielsweise als Input f√ºr Derivationen\nverwendet werden.  Damit lassen sich beispielsweise Build Skripte\ninline unterbringen.</p><h3 id=\"builtinstojson\">builtins.toJSON</h3>\n<p>√úbersetzt einen Nix Ausdruck in sein Json √Ñquivalent, aber mit\nein paar effektvollen Besonderheiten.  Strings, Integers, Floats,\nBools, null und Listen werden einfach in ihr Json √Ñquivalent\n√ºbersetzt.  Nix Sets werden zu Json Objekten.  Davon ausgenommen\nsind Derivationen: die werden in den entsprechenden Ausgabepfad\n√ºbersetzt (als Json String).  Nix Paths werden in den Nix Store\nkopiert und zu ihrem Zielpfad evaluiert (als Json String).</p><pre><code>nix-repl&gt; builtins.toJSON /home/aramis/todo.txt\n&quot;\\&quot;/nix/store/dmj65s7zfyzzypymaihy8yd1mrdz27pm-todo.txt\\&quot;&quot;\n\nnix-repl&gt; builtins.toJSON 123\n&quot;123&quot;\n\nnix-repl&gt; builtins.toJSON &quot;123&quot;\n&quot;\\&quot;123\\&quot;&quot;\n\nnix-repl&gt; builtins.toJSON []\n&quot;[]&quot;\n\nnix-repl&gt; builtins.toJSON {}\n&quot;{}&quot;\n</code></pre>\n<p>Ich frage mich, wie hier unterschieden wird zwischen Derivationen\nund anderen Sets.</p><h3 id=\"builtinstopath\">builtins.toPath</h3>\n<p>DEPRECATED.</p><p>Man soll stattdessen f√ºr absolute Pfade <code>/. + &quot;/path&quot;</code> und f√ºr\nrelative Pfade <code>./. + &quot;/path&quot;</code> verwenden.</p><h3 id=\"builtinstoxml\">builtins.toXML</h3>\n<p>√úbersetzt einen Nix Ausdruck in eine XML Darstellung:</p><pre><code>nix-repl&gt; builtins.toXML 123\n&quot;&quot;&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;\n&lt;expr&gt;\n  &lt;int value=\\&quot;123\\&quot; /&gt;\n&lt;/expr&gt;\n&quot;&quot;&quot;\n\nnix-repl&gt; builtins.toXML &quot;123&quot;\n&quot;&quot;&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;\n&lt;expr&gt;\n  &lt;string value=\\&quot;123\\&quot; /&gt;\n&lt;/expr&gt;\n&quot;&quot;&quot;\n\nnix-repl&gt; builtins.toXML []\n&quot;&quot;&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;\n&lt;expr&gt;\n  &lt;list&gt;\n  &lt;/list&gt;\n&lt;/expr&gt;\n&quot;&quot;&quot;\n\nnix-repl&gt; builtins.toXML {}\n&quot;&quot;&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;\n&lt;expr&gt;\n  &lt;attrs&gt;\n  &lt;/attrs&gt;\n&lt;/expr&gt;\n&quot;&quot;&quot;\n</code></pre>\n<p>Das ist daf√ºr da, mit einem Build Script auf eine strukturiertere\nWeise Daten auszutauschen als es allein mit Umgebungsvariablen\nm√∂glich ist.</p><p>Irgendwie verursacht XML in mir so etwas wie PTSD.</p><h3 id=\"builtinstraceverbose\">builtins.traceVerbose</h3>\n<p>Wenn die Flag <code>--trace-verbose</code> aktiv ist, entspricht\nein Aufruf von <code>builtins.trace</code> einem Aufruf von\n<a href=\"#cea058c12c239c26bf1984ea9ae775625dd569ac\"><code>builtins.trace</code></a>:</p><pre><code>$ nix repl --trace-verbose\nWelcome to Nix 2.10.3. Type :? for help.\n\nnix-repl&gt; builtins.traceVerbose [ 1 2 3 ] &quot;foo&quot;\ntrace: [ 1 2 3 ]\n&quot;foo&quot;\n</code></pre>\n<p>Ohne die Flag wertet <code>builtins.traceVerbose e1 e2</code> einfach nur zu\n<code>e2</code> aus:</p><pre><code>$ nix repl\nWelcome to Nix 2.10.3. Type :? for help.\n\nnix-repl&gt; builtins.traceVerbose [ 1 2 3 ] &quot;foo&quot;\n&quot;foo&quot;\n</code></pre>\n<h3 id=\"builtinstryeval\">builtins.tryEval</h3>\n<p>Darauf gehe ich im Abschnitt\n<a href=\"#e5969e35d6245cb82705919ad4a5065f5e4329ff\">Fehler</a> ein.</p><h3 id=\"builtinstypeof\">builtins.typeOf</h3>\n<p>Liefert einen String, der den Datentyp eines Ausdrucks bezeichnet.\nDie Datentypen sind <code>&quot;int&quot;</code>, <code>&quot;bool&quot;</code>, <code>&quot;string&quot;</code>, <code>&quot;path&quot;</code>,\n<code>&quot;null&quot;</code>, <code>&quot;set&quot;</code>, <code>&quot;list&quot;</code>, <code>&quot;lambda&quot;</code> und <code>&quot;float&quot;</code>:</p><pre><code>nix-repl&gt; builtins.typeOf 0\n&quot;int&quot;\n\nnix-repl&gt; builtins.typeOf false\n&quot;bool&quot;\n\nnix-repl&gt; builtins.typeOf &quot;&quot;\n&quot;string&quot;\n\nnix-repl&gt; builtins.typeOf /.\n&quot;path&quot;\n\nnix-repl&gt; builtins.typeOf null\n&quot;null&quot;\n\nnix-repl&gt; builtins.typeOf {}\n&quot;set&quot;\n\nnix-repl&gt; builtins.typeOf []\n&quot;list&quot;\n\nnix-repl&gt; builtins.typeOf ( x : x )\n&quot;lambda&quot;\n\nnix-repl&gt; builtins.typeOf 0.0\n&quot;float&quot;\n</code></pre>\n<h3 id=\"builtinsunsafediscardoutputdependency\">builtins.unsafeDiscardOutputDependency</h3>\n<p>Undokumentiert.</p><h3 id=\"builtinsunsafediscardstringcontext\">builtins.unsafeDiscardStringContext</h3>\n<p>Undokumentiert.</p><h3 id=\"builtinsunsafegetattrpos\">builtins.unsafeGetAttrPos</h3>\n<p>Undokumentiert.</p><h3 id=\"builtinszipattrswith\">builtins.zipAttrsWith</h3>\n<p>Das ist wieder so eine Funktion, die etwas ausf√ºhrlicher beschrieben\nwerden muss.</p><p>Sie nimmt eine zweiwertige Funktion <code>f</code> und eine Liste von\nSets entgegen.  Aus den Sets werden zun√§chst die Werte f√ºr die\njeweiligen Schl√ºssel in Listen gesammelt.  Aus den Schl√ºsseln und\nden zugeh√∂rigen Listen wird ein Set erstellt.  Auf dieses Set wird\n<code>builtins.mapAttrs f</code> angewendet.</p><p>Schauen wir uns das zun√§chst mit einer neutralen Funktion <code>f</code> an:</p><pre><code>nix-repl&gt; :p builtins.zipAttrsWith\n...             ( k : v : v )\n...             [ { x = 1 ; y = 2 ; }\n...               { x = 3 ; y = 4 ; z = 5 ; }\n...             ]\n{ x = [ 1 3 ]; y = [ 2 4 ]; z = [ 5 ]; }\n</code></pre>\n<p>Ich denke, hier sieht man ganz gut, was vor sich geht: alle\nSchl√ºssel werden eingesammelt und f√ºr jeden Schl√ºssel werden\ndie zugeh√∂rigen Werte in Listen akkumuliert.  Diese Listen\nsind naturgem√§√ü nichtleer (sonst g√§be es keinen zugeh√∂rigen\nSchl√ºssel).</p><p>Wir k√∂nnen dann mit <code>f</code> auf diesen Listen operieren.  Beispielsweise\nk√∂nnen wir z√§hlen, wie oft jeder Schl√ºssel vorkommt:</p><pre><code>nix-repl&gt; :p builtins.zipAttrsWith\n...             ( k : v : builtins.length v )\n...             [ { x = 1 ; y = 2 ; }\n...               { x = 3 ; y = 4 ; z = 5 ; }\n...             ]\n{ x = 2; y = 2; z = 1; }\n</code></pre>\n<p>Oder wir finden den jeweils gr√∂√üten Wert f√ºr jeden Schl√ºssel.\nDaf√ºr bauen wir uns zun√§chst eine <code>max</code> Funktion f√ºr nichtnegative\nZahlen:</p><pre><code>nix-repl&gt; max = ls :\n...         builtins.foldl&#39;\n...             ( a : b : if a &gt; b then a else b )\n...             0\n...             ls\n\nnix-repl&gt; max [ 1 2 3 4 5 4 3 2 1 ]\n5\n</code></pre>\n<p>Damit k√∂nnen wir die gr√∂√üten Schl√ºssel finden:</p><pre><code>nix-repl&gt; :p builtins.zipAttrsWith\n...             ( k : v : max v )\n...             [ { x = 1 ; y = 2 ; }\n...               { x = 3 ; y = 4 ; z = 5 ; }\n...             ]\n{ x = 3; y = 4; z = 5; }\n</code></pre>\n<hr>\n<p>Damit ist meine erste Erkundung der Nix Expression Language\nabgeschlossen.  Vielleicht gibt es hier und da noch einen\nunbeleuchteten Aspekt, aber im gro√üen und ganzen habe ich\neinen guten √úberblick und ein gutes Gef√ºhl f√ºr die Sprache.\nSyntaktisch erinnert sie mich weniger an Haskell aber vielleicht\nein bisschen an OCaml und an Coqs Gallina Sprache.  Semantisch sind\nwir eher im Erlang/Ruby/JavaScript-Land: dynamische Typisierung,\npolymorphe Listen usw.</p><p>Damit kann ich Nix (die Sprache) zun√§chst abhaken.  Als n√§chstes\narbeite ich G. Gonzalez‚Äô Vortrag <em>Nix: under the hood</em> durch,\num den Nix Store und die Nix CLI-Befehle besser kennenzulernen.</p>",
            "author": {
                "name": "Aram√≠s Concepci√≥n Dur√°n"
            },
            "tags": [
            ],
            "date_published": "2022-12-01T09:38:00+01:00",
            "date_modified": "2025-04-07T06:53:16+02:00"
        },
        {
            "id": "https://nojs.de/digital-gardening/",
            "url": "https://nojs.de/digital-gardening/",
            "title": "Digital Gardening",
            "content_html": "<p>Online kursierte vor einiger Zeit unter dem Schlagwort <em>Digital\nGardening</em> eine alternative Vision f√ºr das Web jenseits des\nsequentiellen Publizierens √† la Twitter, Instagram, Weblog und so\nweiter: statt fertige, datierte Inhalte online zu stellen und Hot\nTakes in den Socials zu posten, k√∂nnen wir im Web Wissensammlungen\nanfertigen.  Allgemein oder thematisch, lose oder strukturiert,\nallein oder kollaborativ ‚Äî die M√∂glichkeiten sind zahlreich und\nes gibt dabei keinen Zwang zur Tagesaktualit√§t und Reichweite.</p><p>Die Idee ist genaugenommen keine neue.  Solche Inhalte haben fr√ºher\neinen gro√üen Teil des Web ausgemacht.  Dann haben Google, Facebook\nusw. das Web √ºbernommen und daraus eine Einkaufspromenade gemacht.\nAber jetzt scheint eine neue Generation die alten Freiheitsgrade\nwiederzuentdecken.  Neben dem urspr√ºnglichen World Wide Web m√ºsste\neine Genealogie des Digital Gardening mindestens auch die folgenden\nWegsteine enthalten.</p><p><strong>Niklas Luhmanns Zettelkasten.</strong>  Luhmann hat Hypertext\nhandschritlich auf nummerierten Karteikarten so produktiv gemacht\nwie kein zweiter und auf dieser Basis eine umfassende Theorie\nder Gesellschaft erarbeitet.  Luhmanns Lebenswerk zeigt, dass\ntextvermitteltes Denken effektiv und effizient ist, wenn verf√ºgbare\nund bew√§hrte Werkzeuge mit Disziplin, Kontinuit√§t und Geschick\neingesetzt werden.</p><p><strong>ToDo Apps und Note Taking Apps.</strong>  Evernote, Org Mode, Roam\nResearch, Obsidian, Logseq: beim Einsatz solcher Anwendungen muss\nman aufpassen: es bedarf einer echten Aufgabe, eines konkreten\nZiels oder irgendeiner anderen Substanz, an der sich die ToDos und\nNotes ausrichten.  Sonst bleibt das ganze Note Taking und ToDoing\nrein mastorbatorisch.  Es ist nicht schwer, in diese Falle zu\ntappen, der Software die Schuld daf√ºr zu geben und gleich die\nn√§chste auszuprobieren.  So dreht man sich nur im Kreis ohne je\nsinnstiftende Arbeit zu verrichten.</p><p><strong>Digital Humanities.</strong>  Dagegen sind die Wikis, digitalen Archive\nund Online-Editionen der Digitial Humanities echte Bem√ºhungen,\neinen digitalen Bestand an Texten und anderen medialen Artefakten\naufzubauen, hypertextuell zu verflechten und f√ºr die Wissenschaften\nproduktiv zu machen oder der breiteren √ñffentlichkeit zur Verf√ºgung\nzu stellen.</p><p><strong>Engelbarts Dynamic Knowledge Repository.</strong>  Neben der Computermaus\ngeht auf Douglas Engelbart die Vorstellung zur√ºck, dass der\nComputer ‚Äì wenn wir ihn richtig einsetzen ‚Äì unsere kollektive\nIntelligenz exponentiell steigern wird.  Zentral ist dabei die Idee\neines Wissensspeichers, der nicht nur einen statischen Wissensvorrat\nenth√§lt, sondern durch eine dialoghafte Interaktion zwischen Mensch\nund Computer zu einem Katalysator f√ºr das Denken wird.</p><p>F√ºr die meisten von uns wird Digital Gardening bescheidener und\npers√∂nlicher sein, so auch f√ºr mich: wenn ich etwas, lerne,\nlese, konstruiere, ein Problem bearbeite usw.: dann fertige ich\ndazu gern Notizen an und versuche, sie so zu verlinken, dass ich\nsie im passenden Arbeitskontext wiederfinden kann.  Die Datenbasis\ndaf√ºr sind Textdateien in einem Git-versionierten Verzeichnis.\nIn diesem Garten gedeihen vielf√§ltige Gew√§chse: Stichwortlisten,\nLinksammlungen, Protokolle, HowTos, Zusammenfassungen, Taxonomien,\nund manchmal auch Texte wie dieser.</p><p><strong>Links zum Thema</strong></p><ul>\n<li><a href=\"https://maggieappleton.com/garden-history\">A Brief History of Digital Gardens</a></li>\n<li><a href=\"https://stackingthebricks.com/how-blogs-broke-the-web/\">How the Blog Broke the Web</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=ckv_CjyKyZY\">The Garden and the Stream: a Technopastoral</a></li>\n<li><a href=\"https://www.theatlantic.com/magazine/archive/1945/07/as-we-may-think/303881/\">As We May Think</a></li>\n</ul>\n",
            "author": {
                "name": "Aram√≠s Concepci√≥n Dur√°n"
            },
            "tags": [
            ],
            "date_published": "2022-11-30T09:13:00+01:00",
            "date_modified": "2025-04-07T06:53:03+02:00"
        }
    ]
}
