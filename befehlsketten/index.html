<!DOCTYPE html><html lang="de"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Befehlsketten - Aramís Concepción Durán</title><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://nojs.de/befehlsketten/"><link rel="alternate" type="application/atom+xml" href="https://nojs.de/feed.xml" title="Aramís Concepción Durán - RSS"><link rel="alternate" type="application/json" href="https://nojs.de/feed.json" title="Aramís Concepción Durán - JSON"><meta property="og:title" content="Befehlsketten"><meta property="og:site_name" content="Aramís Concepción Durán"><meta property="og:description" content=""><meta property="og:url" content="https://nojs.de/befehlsketten/"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://nojs.de/media/website/59de3f1dd701ffa954c008012966b9d97d6911b5.png" type="image/x-icon"><link rel="stylesheet" href="https://nojs.de/assets/css/style.css?v=11bee19e86e8eda2cf9a60efd975666d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://nojs.de/befehlsketten/"},"headline":"Befehlsketten","datePublished":"2025-09-21T13:43+02:00","dateModified":"2025-09-21T21:15+02:00","description":"","author":{"@type":"Person","name":"Aramís Concepción Durán","url":"https://nojs.de/authors/aramis-concepcion-duran/"},"publisher":{"@type":"Organization","name":"Aramís Concepción Durán"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://nojs.de/">Aramís Concepción Durán</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Befehlsketten</h1><div class="feed__meta content__meta"><time datetime="2025-09-21T13:43" class="feed__date">2025-09-21</time></div></div></header></div><div class="entry-wrapper content__entry"><p>Es gibt ein paar wunderbare Dinge, die in der Welt der grafischen Benutzeroberflächen fehlen, aber auf der Linux-Kommandozeile zum Standardrepertoire gehören. Ein Beispiel dafür sind Befehlsketten: dabei verknüpft man die Eingaben und Ausgaben verschiedener Programme so, dass sie zusammenarbeiten um etwas zu berechnen.</p><p>Ich möchte das an einer konkreten Befehlskette demonstrieren:</p><pre><code>apt list --installed | cut -d/ -f1 | sort | uniq | fzf -e
</code></pre><p>Bevor wir die auseinandernehmen, gebe ich eine ganz knappe Einführung.</p><h2 id="ganz-knappe-einführung">Ganz knappe Einführung</h2><p>Die Arbeit mit der Kommandozeile (i.e. Terminal, i.e. Konsole) ist ein textbasiertes Ping-Pong-Spiel mit dem Computer: man setzt am sogenannten Prompt einen Textbefehl ab, dann macht der Computer irgendetwas damit und gibt ggf. eine textuelle Rückmeldung. Wenn er damit fertig ist, zeigt er wieder den Prompt an und wartet auf den nächsten Textbefehl.</p><p>Das ist eine textbasierte Alternative zur grafischen Interaktion mit dem Computer, bei der man hauptsächlich via Maus oder Touchpad den Cursor über den Bildschirm bewegt, visuelle Elemente bspw. mit einem Klick aktiviert, die Reaktion des Computers wahrnimmt und dann fortfährt. Nur Bei Bedarf führt man die Hand zur Tastatur und gibt Text ein.</p><p>Gegenüber der grafischen Benutzeroberfläche ist die Kommandozeile eine zugegeben etwas altbackene Form der Bedienung. Andererseits sind klassische GUIs mit Maus oder Touchpad auch nicht mehr die Norm, denn die meisten Bildschirme sind heute Touch-Bildschirme.</p><h2 id="verkettung-mit-dem-pipe-operator">Verkettung mit dem Pipe-Operator</h2><p>Ich möchte hier keine Einführung in die Kommandozeile geben, aber wenn du ein Grundverständnis dafür hast, wie man auf ihr Befehle eingibt und die Rückmeldung interpretiert, genügt das.</p><p>Befehle sind kleine Programme, die Datenströme verarbeiten. Ein Eingabestrom wird konsumiert und verarbeitet. Dabei werden vielleicht irgendwelche Nebeneffekte hervorgerufen (Dateien erzeugen oder löschen, Netzwerkanfragen absenden, Raketen starten, …). Schließlich wird ein Ausgabestrom befüllt.</p><p>Manche Programme sind nicht an einem Eingabestrom interessiert. Bspw. holt sich <code>ls</code> über Systemaufrufe die Informationen über das aktuelle Verzeichnis und seine Inhalte. Die Auflistung, die <code>ls</code> erzeugt, wird aber über einen Ausgabestrom weitergegeben.</p><p>Wenn du einen einzelnen Befehl absetzt, wird der Ausgabestrom so umgeleitet, dass die Ausgabe direkt unter dem abgesetzten Befehl erscheint. Bspw. gibst du <code>ls</code> ein, bestätigst mit der Eingabetaste und erhältst dann direkt darunter die gewünschte Auflistung der Verzeichnisinhalte.</p><pre><code>$ ls
&#39;W6 Wertarbeit Einfädeln W6 N 1800, 1615, 1235⧸61 [WE0sv2XWF54].mkv&#39;
&#39;W6 Wertarbeit Nähmaschine N 1235⧸61 [GyE0OaKJe14].mkv&#39;
&#39;W6 Wertarbeit Nähmaschine N 1235⧸61 Jahr 2016 [pq_l9jE4vE4].webm&#39;
W6-N-123561-Betriebsanleitung.pdf
$
</code></pre><p>Anderer Befehl, selbes Prinzip:</p><pre><code>$ echo hallo
hallo
$
</code></pre><p>Allerdings kannst du mit dem Pipe-Operator <code>|</code> den Ausgabestrom eines Programms zum Eingabestrom des nächsten Programms machen. So lässt sich bspw. die Ausgabe von <code>echo hallo</code> mit dem Textprozessor <code>awk</code> in Großschreibung überführen:</p><pre><code>$ echo hallo | awk &#39;{ print toupper($0) }&#39;
HALLO
$ 
</code></pre><p>Das Beispiel ist trivial, aber vielleicht erkennt man daran schon ganz gut, welche Möglichkeiten sich auftun, wenn man ein kleines Repertpoire an solchen Bausteinen im Kopf hat, die sich gut miteinander kombinieren lassen.</p><h2 id="installierte-softwarepakte-auflisten">Installierte Softwarepakte auflisten</h2><p>Jetzt können wir uns der Befehlskette vom Anfang widmen.</p><pre><code>apt list --installed | cut -d/ -f1 | sort | uniq | fzf -e
</code></pre><p>Der Befehl <code>apt list --installed</code> druckt eine Liste aller installierten Softwarepakete aus, aber die Ausgabe ist sperrig und viel zu lang um daraus schlau zu werden.</p><pre><code>$ apt list --installed

WARNING: apt does not have a stable CLI interface. Use with caution in scripts.

Listing...
abiword-common/jammy,jammy,now 3.0.5~dfsg-1 all [installed,automatic]
abiword-plugin-grammar/jammy,now 3.0.5~dfsg-1 amd64 [installed,automatic]
abiword/jammy,now 3.0.5~dfsg-1 amd64 [installed]
accountsservice/jammy-updates,jammy-security,now 22.07.5-2ubuntu1.5 amd64 [installed,automatic]
acl/jammy,now 2.3.1-1 amd64 [installed,automatic]
acpi-support/jammy,now 0.144 amd64 [installed]
acpid/jammy,now 1:2.0.33-1ubuntu1 amd64 [installed,automatic]
adduser/jammy,jammy,now 3.118ubuntu5 all [installed]
adwaita-icon-theme/jammy,jammy,now 41.0-1ubuntu1 all [installed,automatic]
...
... (Hier kommt noch seitenweise mehr Ausgabetext)
...
$
</code></pre><p>Ich bin pro Zeile nur an dem Namen des Paketes interessiert. Die Informationen nach dem Schrägstrich möchte ich verwerfen. Das geht mit <code>cut -d/ -f1</code>, was so viel bedeutet wie “trenne die Zeilen am Schrägstrich auf und gib mir jeweils nur das erste Feld, also den Text vor dem Schrägstrich”:</p><pre><code>$ apt list --installed | cut -d/ -f1

WARNING: apt does not have a stable CLI interface. Use with caution in scripts.

Listing...
abiword-common
abiword-plugin-grammar
abiword
accountsservice
acl
acpi-support
acpid
adduser
adwaita-icon-theme
...
... (Hier kommt noch seitenweise mehr Ausgabetext)
...
$ 
</code></pre><p>Das sieht schon viel besser aus, aber es ist noch nicht ideal: wenn ich die ungekürzte Ausgabe zeigen würde, könnten wir sehen, dass es eine Reihe von Paketen gibt, die mehrfach aufgelistet werden. An dem Ausschnitt sieht man das ganz gut:</p><pre><code>...
libxmlb2
libxmu6
libxmuu1
libxpm4            &lt;---
libxpm4            &lt;---
libxrandr2         &lt;---
libxrandr2         &lt;---
libxrender1        &lt;---
libxrender1        &lt;---
libxres1
libxs-parse-keyword-perl
libxshmfence1      &lt;---
libxshmfence1      &lt;---
libxslt1.1         &lt;---
libxslt1.1         &lt;---
libxss1            &lt;---
libxss1            &lt;---
libxt6
libxtables12
libxtst6
libxv1             &lt;---
libxv1             &lt;---
libxvidcore4
libxvmc1
libxxf86dga1
libxxf86vm1        &lt;---
libxxf86vm1        &lt;---
libxxhash0
libyajl2
libyaml-0-2
...
</code></pre><p>Die Redundanz hängt vermutlich damit zusammen, dass in den Paketquellen aus guten Gründen manchmal mehrere Varianten eines Paketes verfügbar sind. Wir können die redundanten Zeilen entfernen mit <code>uniq</code>. Das verarbeitet seine Eingabe zeilenweise und nimmt nur nicht-redundante Zeilen in die Ausgabe auf. Allerdings vergleicht <code>uniq</code> nur benachbarte Zeilen auf Redundanz. Deswegen habe ich es mir zur Angewohnheit gemacht, <code>uniq</code> immer zusammen mit <code>sort</code> aufzurufen, um die Zeilen vorher alphabetisch zu sortieren, also : <code>sort | uniq</code>. Hier ist das unnötig, aber ich folge trotzdem meiner Gewohnheit. Wenn wir die Befehlskette entsprechend ergänzen, sieht sie so aus:</p><pre><code>apt list --installed | cut -d/ -f1 | sort | uniq
</code></pre><p>Die Ausgabe von <code>apt list --installed</code> ist dann sauber auf die eigentlichen Paketnamen reduziert, garantiert alphabetisch sortiert und um Redundanzen bereinigt. Das ist sehr gut, aber die Liste ist immer noch viel zu lang für eine Bildschirmausgabe.</p><p>Hier kommt <code>fzf</code> ins Spiel, der “general-purpose command-line fuzzy finder”. <code>fzf</code> konsumiert seine Eingabe zeilenweise und präsentiert dem User eine Auflistung dieser Zeilen zusammen mit einem darunterliegenden Suchprompt um die Auflistung einzugrenzen.</p><p>Das Suchverhalten von <code>fzf</code> ist standardmäßig nicht ganz nach meinem Geschmack: es sucht geordnete Teilmengen auf Zeichenebene. Beispielsweise findet es die Zeichenkette <code>&quot;Elefanten&quot;</code> wenn ich nach <code>&quot;Ente&quot;</code> suche (wegen <strong>E</strong>lefa<strong>nte</strong>n), aber wenn ich eine Ente suche möchte ich keine Elefanten haben. Wenn man <code>fzf</code> mit der Flag <code>-e</code> (für <code>--exact</code>) aufruft, ändert sich das Suchverhalten so, dass man besser gezielt nach bestimmten Paketnamen suchen kann.</p><p>Damit ist die Befehlskette vollständig:</p><pre><code>apt list --installed | cut -d/ -f1 | sort | uniq | fzf -e
</code></pre><p>Sie listet mir alle installierten Pakete auf und lässt mich interaktiv nach Paketnamen suchen. So kann ich für einzelne Pakete bequem prüfen, ob sie installiert sind.</p><p>Wenn ich <code>--installed</code> weglasse, erhalte ich stattdessen eine Auflistung aller <strong>verfügbaren</strong> Pakete. Damit kann ich bequem prüfen, ob bestimmte Software dem Namen nach in den Paketquellen enthalten ist.</p><h2 id="fazit">Fazit</h2><p>Das wirkt bestimmt alles recht umständlich. Ich höre schon den Einwand, dass es völlig absurd ist, sich diese ganze Komplexität aufzuladen, anstatt einfach das GUI-Programm für die Paketverwaltung zu öffnen und sich darin die installierten Softwarepakete auflisten zu lassen. Das stimmt! Aber es ist nicht der entscheidende Punkt.</p><p>Irgendjemand hat dieses GUI-Programm für genau diesen Zweck geschrieben. Die Bausteine der Befehlskette sind aber generisch (abgesehen von <code>apt</code>). Text manipulieren, Zeilen sortieren und filtern, Listen duchsuchen: das sind alles generische Operationen, die nichts mit Paketverwaltung zu tun haben, aber miteinander kombiniert werden können für diesen Anwendungsfall (und für viele andere).</p><p>Es gibt genug Anwendungsfälle, für die noch niemand ein dediziertes GUI-Programm geschrieben hat. Auf der Kommandozeile können wir uns dann trotzdem eine Lösung zusammenstricken; und wenn das einmal zur Gewohnheit geworden ist, wird es vielleicht auch zu einer Präferenz.</p><p>Dann ist es auch nicht mehr so umständlich wie es auf den ersten Blick scheint. Ich leite mir <code>apt list --installed | cut -d/ -f1 | sort | uniq | fzf -e</code> nicht jedes Mal neu her, sondern ich gebe am Prompt meiner Fish-Shell nur <code>apt</code> ein und dann erscheint schon die ganze Befehlskette als Vorschlag, den ich mit einem Tastendruck akzeptiere.</p></div><footer class="content__footer"><div class="entry-wrapper"><div class="content__actions"></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://nojs.de/json-serialisierung-von-linq-expressions/" class="content__nav-link" rel="prev"><div><span>Previous</span> JSON-Serialisierung von LINQ-Expressions</div></a></div></div></div></nav></footer></article></main><footer class="footer"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://nojs.de/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://nojs.de/assets/js/scripts.min.js?v=ffcbea6c02c8178d10092962b235a5b0"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>