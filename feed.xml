<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Aram√≠s Concepci√≥n Dur√°n</title>
    <link href="https://nojs.de/feed.xml" rel="self" />
    <link href="https://nojs.de" />
    <updated>2025-05-20T23:05:52+02:00</updated>
    <author>
        <name>Aram√≠s Concepci√≥n Dur√°n</name>
    </author>
    <id>https://nojs.de</id>

    <entry>
        <title>JSON-Serialisierung von LINQ-Expressions</title>
        <author>
            <name>Aram√≠s Concepci√≥n Dur√°n</name>
        </author>
        <link href="https://nojs.de/json-serialisierung-von-linq-expressions/"/>
        <id>https://nojs.de/json-serialisierung-von-linq-expressions/</id>

        <updated>2025-05-11T10:35:46+02:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>Ich sehe hin und wieder C# Code, der via <a href="https://www.nuget.org/packages/mongodb.driver">MongoDB.Driver</a> Daten aus MongoDB-Collections aggregiert, aufgerufen √ºber eine Web-API und eine vorgeschaltete Connector-Klasse mit statischen Wrapper-Methoden f√ºr die Bedienung der API-Endpunkte.</p><p>Wenn die Daten nicht nur paginiert sondern auch gefiltert werden sollen, stellt sich nat√ºrlich die Frage, wie man auf dem Hinweg das Filterkriterium kodiert und serialisiert.  Bisher habe ich die folgende Antwort gesehen: ad-hoc ein DTO zusammenstricken, das jeweils eine Property enth√§lt f√ºr die konkreten Filteroptionen, die jetzt (oder vielleicht sp√§ter) ben√∂tigt werden.  Ein Gedanke dabei ist sicherlich, dass man dieses Datentransferobjekt im Nachhinein erweitern kann sobald neue Filteranforderungen auftauchen.</p><p>F√ºr die Posts in einem Blog k√∂nnte das so aussehen:</p><pre><code>Class PostsRequest
{
    string? Author { get; set; }
    DateTime? MinCreated { get; set; }
    List&lt;string&gt;? Tags { get; set; }
}
</code></pre>
<p>Der Controller-Code nimmt dieses Objekt entgegen und konstruiert daraus einen Filter f√ºr die Aggregation der Daten:</p><ol>
<li>Erzeuge einen leeren Filter.</li>
<li>Wenn <code>r.Author is not null</code>, f√ºge <code>x =&gt; x.Author == r.Author</code> hinzu.</li>
<li>Wenn <code>r.MinCreated is not null</code>, f√ºge <code>x =&gt; x.Created &gt;= r.MinCreated</code> hinzu.</li>
<li>Wenn <code>r.Tags.IsNotNullOrEmpty()</code>, f√ºge <code>x.Tags.Contains(r.Tags)</code> hinzu (oder so √§hnlich).</li>
</ol>
<p>Aber was ist wenn ich mehrere Autoren angeben m√∂chte?  Dann muss <code>PostsRequest</code> entsprechend angepasst und <code>Author</code> von <code>string?</code> auf <code>List&lt;string&gt;?</code> umgestellt werden.  Der Server-Code, der den eigentlichen Filter konstruiert, muss daf√ºr ebenfalls angepasst werden.  Bekomme ich dann die Posts jeweils aller angegebenen Autoren?  Oder nur die Posts, die von allen angegebenen Autoren gemeinsam verfasst wurden?  Oder beides?  Hoffentlich ist <code>PostsRequest</code> entsprechend dokumentiert.  Hoffentlich passt die Dokumentation zur tats√§chlichen Implementierung des Filters.  Hoffentlich hat niemand im Nachhinein den Filter ver√§ndert und dabei vergessen, auch die Dokumentation anzupassen.  Was ist wenn ich alle obigen F√§lle ben√∂tige?  F√ºge ich dann Properties f√ºr alle F√§lle zu <code>PostsRequest</code> hinzu?  Oder eine Art Steuer-Property, die festlegt, wie <code>r.Author</code> vom Server-Code zu interpretieren ist?  Was ist wenn ich <code>MaxCreated</code> ben√∂tige?  Oder <code>MinCreated</code> aber nicht inklusiv sondern exklusiv?  Was ist wenn ich ein noch komplexeres Filterkriterium ben√∂tige?</p><p>Dieser Ansatz ist die reine H√∂lle.  Er verkompliziert und verengt eine Sache, die eigentlich eine sehr simple und allgemeine L√∂sung haben sollte: ich gebe der Connector-Methode ein Pr√§dikat <code>Func&lt;Post, bool&gt;</code> und sie holt mir Eintr√§ge vom Typ <code>Post</code> aus der Datenbank, die auf dieses Pr√§dikat passen!</p><p>Damit verschwindet die ganze Sperrigkeit des <code>PostsRequest</code> Ansatzes, weil ich als Aufrufer der Connector-Methode selbst mein Filterpr√§dikat angebe, und zwar in der allgemeinen Form <code>Func&lt;Post,bool&gt;</code>, ohne durch die unpassende Struktur und Semantik eines Request-Datentyps eingeschr√§nkt zu sein; ohne raten zu m√ºssen, was der eigentliche Filter-Code macht, der sich hinter der API auf dem Server versteckt; ohne dass der serverseitige Filter-Code immer wieder angepasst werden muss.</p><p>Die Sache hat nat√ºrlich einen Haken, der wahrscheinlich auch der Grund daf√ºr sein wird, dass ich stattdessen Request-DTOs sehe: Wie serialisiert man eigentlich eine <code>Func&lt;Post, bool&gt;</code> um sie via HTTP an eine Web-API zu √ºbertragen und auf der Gegenseite korrekt wieder zu deserialisieren? ü§î</p><p>Es gibt daf√ºr tats√§chlich eine L√∂sung.  Die <code>FilterDefinitionBuilder</code> Klasse in <code>MongoDB.Driver</code> exponiert eine <code>Where</code> Methode:</p><pre><code>public FilterDefinition&lt;T&gt; Where(Expression&lt;Func&lt;T, bool&gt;&gt; expression)
</code></pre>
<p>Damit k√∂nnen wir aus einer <code>Expression&lt;Func&lt;Post, bool&gt;&gt;</code> eine <code>FilterDefinition&lt;Post&gt;</code> erzeugen, die der MongoDB-Treiber in seiner Aggregation verwenden kann.  Dabei repr√§sentiert <code>Expression&lt;Func&lt;Post, bool&gt;&gt;</code> einen AST f√ºr den unkompilierten Code einer Funktion <code>Func&lt;Post, bool&gt;</code>.  Ein AST bringt uns der Serialisierung schon ein ganzes St√ºck n√§her.  Allerdings kommt das ASP.NET Model Binding mit diesem Datentyp nicht zurecht.  Wir m√ºssen uns also selbst um die Serialisierung und Deserialisierung k√ºmmern.</p><p>Immerhin m√ºssen wir den Serializer nicht selbst schreiben.  Sascha Kiefer war so freundlich, daf√ºr das NuGet-Paket <a href="https://www.nuget.org/packages/Serialize.Linq">Serialize.Linq</a> bereitzustellen.  Wir m√ºssen lediglich im Connector-Code unsere Expression serialisieren bevor wie sie √ºbertragen, bzw. im Controller-Code h√§ndisch den <code>Request.Body</code> auslesen und deserialisieren:</p><pre><code>// Connector

Expression&lt;Func&lt;T, bool&gt;&gt; expression = x =&gt; pred(x);

ExpressionSerializer expressionSerializer =
    new Serialize.Linq.Serializers.ExpressionSerializer(
        new Serialize.Linq.Serializers.JsonSerializer()
    );

var expressionPayload =
    expressionSerializer.SerializeText(expression);

// Controller

string expressionPayload =
    await new StreamReader(Request.Body).ReadToEndAsync();

ExpressionSerializer expressionSerializer =
    new Serialize.Linq.Serializers.ExpressionSerializer(
        new Serialize.Linq.Serializers.JsonSerializer()
    );

var expression =
    (Expression&lt;Func&lt;T, bool&gt;&gt;)
    expressionSerializer.DeserializeText(expressionPayload);
</code></pre>
<p>Damit spart man sich einen gro√üen Haufen sperrigen Behelfs-Boilerplate-Code f√ºr DTOs und serverseitige Filterkonstruktion.  Gleichzeitig beh√§lt man alle Freiheitsgrade eines allgemeinen logischen Pr√§dikates.</p><p>Allerdings muss man dabei ein bisschen aufpassen: der MongoDB-Treiber unterst√ºtzt keine beliebigen Expressions.  Er unterst√ºtzt alle Logik, die man braucht, um ein Filterpr√§dikat zu formulieren, aber keinen beliebigen C#-Code, der sich prinzipiell nicht nach MongoDB √ºbersetzen l√§sst, wie z.B. <code>DateTime.Now</code> oder <code>Guid.NewGuid()</code> oder Inline-Funktionen.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Tsch√ºssi, MC Post!</title>
        <author>
            <name>Aram√≠s Concepci√≥n Dur√°n</name>
        </author>
        <link href="https://nojs.de/tschuessi-mc-post/"/>
        <id>https://nojs.de/tschuessi-mc-post/</id>

        <updated>2025-04-06T12:44:24+02:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <figure class="post__image"><img loading="lazy" src="../media/files/808fa6fa1a890f20da764515f6b9f6019dcd2131.jpg" alt=""  data-is-external-image="true"></figure><p>Ich bin nicht mehr im MC Post aktiv.</p><p>Als Trial-Sparte haben wir ‚Äì w√§hrend meiner aktiven Zeit im Verein ‚Äì zwei L√§ufe zur Ostdeutschen Meisterschaft im Motorrad-Trial veranstaltet.  Ich hab gelernt, dass es Freude macht, Sportveranstaltungen zu planen und durchzuf√ºhren.  Wenn am Veranstaltungstag alles l√§uft, ist das wirklich ein sch√∂nes Gef√ºhl.  Ich h√§tte mir gew√ºnscht, Motorrad-Trial im Verein weiter auszubauen, daneben auch Fahrrad-Trial zu etablieren und eine Jugendsportgruppe daf√ºr aufzubauen.</p><p>Leider war nichts davon m√∂glich.</p><p>Der Verein hat massive Probleme, die viel mit informellen Beziehungs- und Machtstrukturen zu tun haben.  Der feste Kern des Vereins funktioniert wie eine Schulhofclique und ist ein sozialpsychologisches Lehrbuchbeispiel f√ºr Eigengruppenbevorzugung und Fremdgruppenabwertung.  Ich muss an der Stelle wirklich beherzt auf die Bremse treten, um das nicht weiter auszuf√ºhren.  Es gab von Anfang an starke Signale in diese Richtung und aus der Reihe der Trial-Fahrer explizite Warnungen, die ich mit meinem naiven Optimismus √ºberdeckt habe.</p><p>Aber nach zwei Jahren bin ich auch zu dem Schluss gekommen, dass es keinen Zweck hat.  Der Verein ist in einer Art Pattsituation.  Er kann nicht wachsen.  Er kann seinen Mitgliederstamm nicht verj√ºngern.  Er kann seine Bekanntheit in der Stadt nicht steigern.  In Leipzig leben √ºber 600.000 Menschen, nicht wenige davon motorsportbegeistert, aber niemand wei√ü, dass mitten in der Stadt Motorradrennsport betrieben wird.  Mit etwas Geschick m√ºsste es m√∂glich sein, zu einem Speedway-Rennen 10.000 Leipziger als Zuschauer ins Motodrom zu locken, aber jede Initiative in diese Richtung wird vom Verein durch Selbstsabotage vereitelt.  Stattdessen begn√ºgt man sich mit mittleren dreistelligen Besucherzahlen und erkl√§rt das damit, dass die Kids heute nur noch Youtube schauen oder Computerspiele zocken.  Es ist absurd!</p><p>Es w√ºrde mich √ºberraschen, wenn es den Verein in 3, 4, 5 Jahren √ºberhaupt noch gibt.  H√∂chstwahrscheinlich wird dann RB Leipzig auf dem Gebiet des ehemaligen Motodroms aktiv sein oder selbiges als Ausgleichsfl√§che wiederaufforsten.  Wer den kommunalpolitischen Buschfunk verfolgt, wei√ü, dass das intern schon l√§ngst wieder diskutiert und projektiert wird. Um das noch mal zu verhindern, h√§tte man in den letzten Jahren aus dem Knick kommen m√ºssen.</p><p>Aber das macht alles nix!  Ich hab aus der Zeit beim MC Post wertvolle Erfahrungen und Bekanntschaften/Freundschaften mitgenommen.  Und wer wei√ü: vielleicht mache ich demn√§chst auch mal als Teilnehmer bei einem Motorrad-Trial-Wettbewerb mit.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>ADTs, GADTs, Typklassen</title>
        <author>
            <name>Aram√≠s Concepci√≥n Dur√°n</name>
        </author>
        <link href="https://nojs.de/adts-gadts-typklassen/"/>
        <id>https://nojs.de/adts-gadts-typklassen/</id>

        <updated>2023-07-07T12:42:00+02:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>Ich habe vor Kurzem <em>funktionale Abh√§ngigkeiten</em> kennengelernt und
hatte gleich den Impuls, dar√ºber zu schreiben.  Das ist eine gute
Gelegenheit, um etwas ausf√ºhrlicher auf Konzepte der Typebene
in Sprachen wie Haskell, Purescript, Elm und Ocaml einzugehen.</p><h2 id="einfache-datentypen">Einfache Datentypen</h2>
<p>Die meisten Sprachen bringen einen Vorrat an einfachen Datentypen
mit: numerische Datentypen f√ºr ganze Zahlen und Gleitkommazahlen,
Datentypen f√ºr einzelne Buchstaben und andere Schriftzeichen,
einen Datentyp mit den zwei Wahrheitswerten ‚Äúfalsch‚Äù und ‚Äúwahr‚Äù.</p><p>In den Details gibt es gro√üe Unterschiede zwischen den Sprachen,
je nachdem, wo sie ihre Schwerpunkte setzen und welche Form der
Programmierung sie unterst√ºtzen.  Beispielsweise hat C keinen
speziellen Datentyp f√ºr Wahrheitswerte, Python und Javascript
unterscheiden nicht streng zwischen einzelnen Schriftzeichen und
Zeichenketten, Javascript unterscheidet nicht zwischen ganzen Zahlen
und Gleitkommazahlen, TCL kennt nur Zeichenketten, ‚Ä¶</p><p>Ein paar einfache Datentypen in Haskell:</p><ul>
<li><code>Int</code>: ganze Zahlen wie <code>-3</code>, <code>0</code>, <code>123</code>, <code>999999999</code>, ‚Ä¶</li>
<li><code>Float</code>: Gleitkommazahlen wie <code>-123.45</code>, <code>1.0</code>, <code>3.141592653</code>, ‚Ä¶</li>
<li><code>Char</code>: Zeichen wie <code>&#39;a&#39;</code>, <code>&#39;Œ≤&#39;</code>, <code>&#39;7&#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;?&#39;</code>, <code>&#39;üôÇ&#39;</code>, ‚Ä¶</li>
<li><code>Bool</code>: die Wahrheitswerte <code>True</code> und <code>False</code>.</li>
</ul>
<h2 id="die-gr√∂√üe-einfacher-datentypen">Die Gr√∂√üe einfacher Datentypen</h2>
<p>Man kann einen Datentyp auffassen als die Menge seiner Werte.
Hier als Beispiel der Datentyp <code>Bool</code> in Mengenschreibweise:</p><pre><code>Bool = { False , True }
</code></pre>
<p>Die Gr√∂√üe eines Datentyps ist die Anzahl seiner Werte.
Der Datentyp <code>Bool</code> enth√§lt genau zwei Werte.  Damit ist seine
Gr√∂√üe 2.</p><p>Das gleiche Spiel kann man mit allen einfachen Datentypen spielen.
Der kleinste <code>Int</code> Wert auf meinem Rechner ist die ganze Zahl
<code>-9223372036854775808</code> und der gr√∂√üte <code>Int</code> Wert die ganze Zahl
<code>9223372036854775807</code>.  Daraus ergibt sich f√ºr den Datentyp <code>Int</code>
die Gr√∂√üe <code>2^64</code>.</p><p>Die Gr√∂√üe eines einfachen Datentyps h√§ngt letztlich auch damit
zusammen, wie viele Bits mindestens ben√∂tigt werden um einen
seiner Werte zu codieren.  Ein <code>Int</code> Wert ist auf meinem Rechner
in 64 Bits codiert.  Daraus ergibt sich, dass <code>2^64</code> verschiedene
<code>Int</code> Werte codiert werden k√∂nnen.  In Sprachen wie C, die daf√ºr
gemacht sind, m√∂glichst effiziente Programme zu schreiben und
verh√§ltnism√§√üig nah an der Hardware zu programmieren, bedeutet
ein Datentyp im Grunde nicht mehr als die Anzahl von Bits, die
einer seiner Werte im Speicher mindestens ben√∂tigt.</p><p>Bei <code>Char</code> und <code>Float</code> ist die Berechnung der Gr√∂√üe etwas
komplizierter.  vom Datentyp <code>Char</code> gibt es insgesamt <code>1114112</code>
Werte.  F√ºr <code>Float</code> wei√ü ich es nicht, aber es l√§sst sich
grunds√§tzlich ausrechnen.</p><h2 id="zusammengesetzte-datentypen">Zusammengesetzte Datentypen</h2>
<p>Zusammengesetzte Datentypen sind bspw. Arrays, Listen, Strings,
Tupel, Records und Structs.  Das sind allesamt Datentypen, die sich
‚Äì wie der Name sagt ‚Äì auf irgendeine Art aus anderen Datentypen
zusammensetzen.</p><p>Ein Record-Datentyp f√ºr ganzzahlige Punkte in der Ebene k√∂nnte
so aussehen:</p><pre><code>-- Purescript
type Point = { x :: Int , y :: Int }
</code></pre>
<p>Ein Tupel-Datentyp f√ºr den selben Zweck:</p><pre><code>-- Haskell
(Int,Int)
</code></pre>
<p>Der Record-Datentyp hat den Vorteil, dass die Felder mit x und y
bezeichnet sind.  Dadurch ist es vermutlich etwas schwerer, sie
zu verwechseln.  Au√üerdem k√∂nnen wir direkt √ºber die Feldnamen
auf ihre Werte zugreifen.  Beim Tupel-Datentyp verlassen wir uns
auf die Position der Felder f√ºr ihre Unterscheidung.  Der Zugriff
auf die Felder erfolgt √ºber Pattern-Matching in Case Expressions
oder √ºber spezielle Zugriffsfunktionen wie <code>fst</code> und <code>snd</code>.
Daf√ºr deckt sich die Tupel-Schreibweise mit der Schreibweise f√ºr
Punkte in der Ebene, die auch sonst √ºblich ist.  Das sind aber rein
ergonomische Unterschiede.  Strukturell unterscheiden sich diese
beiden Datentypen nicht voneinander: in beiden F√§llen besteht ein
Punkt aus zwei <code>Int</code> Werten.</p><h2 id="die-gr√∂√üe-zusammengesetzter-datentypen">Die Gr√∂√üe zusammengesetzter Datentypen</h2>
<p>Es gibt auf meinem Rechner <code>2^64</code> Werte vom Datentyp <code>Int</code>.
F√ºr den Datentyp <code>Point</code> ergeben sich damit <code>2^64 * 2^64</code> also
<code>2^128</code> Werte.  Das selbe gilt f√ºr den Datentyp <code>(Int,Int)</code>.
Solche Datentypen, die sich aus anderen Datentypen zusammensetzen,
so dass ihre Gr√∂√üe das Produkt der Gr√∂√üen der beteiligten
Datentypen ist, hei√üen <strong>Produkttypen</strong>.  Array-Datentypen und
C-Structs sind auch Produkttypen.  Ein bisschen komplexer ist es
bei Listen und Strings.  Mehr dazu weiter unten.</p><p>In allen herk√∂mmlichen Sprachen kann man Produkttypen definieren,
aber oft fehlt die M√∂glichkeit, <strong>Summentypen</strong> zu definieren.
Das sind Datentypen, die sich aus anderen Datentypen zusammensetzen,
so dass ihre Gr√∂√üe die Summe der Gr√∂√üen der beteiligten
Datentypen ist.</p><h2 id="algebraische-datentypen">Algebraische Datentypen</h2>
<p>Algebraische Datentypen (ADTs) vereinen in sich Produkttypen und
Summentypen: jeder ADT ist eine Summe von Produkten.</p><p><strong>Summen</strong></p><p>Einer der einfachsten ADTs ist der Datentyp <code>Bool</code> in Haskell:</p><pre><code>-- Haskell
data Bool = False | True
</code></pre>
<p><code>False</code> und <code>True</code> sind sogenannte Wertekonstruktoren (oder einfach
nur Werte).  Den Balken m√ºssen wir lesen wie ein exklusives Oder:
jeder Wert vom Datentyp <code>Bool</code> ist entweder <code>False</code> oder <code>True</code>.
Andere als diese zwei <code>Bool</code> Werte gibt es nicht.</p><p>ADTs k√∂nnen beliebig viele Wertekonstruktoren haben:</p><pre><code>-- Haskell

data Ampel = Gr√ºn | Gelb | Rot

data K√§se = Gouda | Cheddar | Brie | Camembert | Gruy√®re

data T = A | B | C | D | E | F | G | H | I | J | K
</code></pre>
<p>Wir k√∂nnen auch einen ADT mit genau einem Wertekonstruktor
definieren:</p><pre><code>-- Haskell
data Eindeutig = Einheit
</code></pre>
<p>Hier hat nur der Wert <code>Einheit</code> den Datentyp <code>Eindeutig</code>.
Damit besteht zwischen dem Datentyp und dem Wert eine
Eins-zu-eins-Beziehung.  Sogar der Spezialfall eines ADT mit
keinen Wertekonstruktoren ist m√∂glich.  Wir geben einfach keine
Wertekonstruktoren an:</p><pre><code>-- Haskell
data Nichts
</code></pre>
<p>Damit hat der Datentyp <code>Nichts</code> keine Werte.  Wir haben daher keine
M√∂glichkeit, einen Wert vom Datentyp <code>Nichts</code> zu erzeugen oder eine
Funktion anzuwenden, die auf <code>Nichts</code> operiert.  Leere Datentypen
sind nicht nutzlos, aber darauf werde ich hier nicht weiter eingehen.
Stattdessen m√∂chte ich auf eine Sache hinweisen, die Verwirrung
stiften kann.  Betrachte daf√ºr die folgende Typdefinition:</p><pre><code>-- Haskell

data Tasche
    = T√ºte
    | Beutel
    | Rucksack
    | G√ºrteltasche
    | Tasche
</code></pre>
<p>Hier definieren wir den Datentyp <code>Tasche</code> mit den Werten  <code>T√ºte</code>,
<code>Beutel</code>, <code>Rucksack</code>, <code>G√ºrteltasche</code> und <code>Tasche</code>.  Es sticht
ins Auge, dass der Name <code>Tasche</code> zweimal auftaucht: einmal als
der Datentyp <code>Tasche</code>, einmal als der Wertekonstruktor <code>Tasche</code>.
F√ºr den Compiler ist das kein Problem.  Er unterscheidet streng
zwischen Datentypen und Wertekonstruktoren und kann sie nicht
verwechseln, auch wenn sie den selben Namen haben.  Das Beispiel ist
zwar an den Haaren herbeigezogen, aber es ist tats√§chlich manchmal
sinnvoll, einem Datentyp und einem seiner Wertekonstruktoren den
selben Namen zu geben.  Weiter unten wird uns so etwas begegnen.</p><p><strong>Wertekonstruktoren mit Feldern</strong></p><p>Bisher haben wir einfache Wertekonstruktoren wie <code>False</code>, <code>Gouda</code>,
<code>Rucksack</code>, <code>A</code> usw. gesehen.  Wertekonstruktoren k√∂nnen aber
typisierte Felder haben.  Hier ein Beispiel:</p><pre><code>-- Haskell
data Lampe = Leuchtet Bool
</code></pre>
<p>Der Datentyp <code>Lampe</code> hat den Wertekonstruktor <code>Leuchtet</code> mit einem
Feld vom Datentyp <code>Bool</code>.  Bisher haben wir die Begriffe <em>Wert</em>
und <em>Wertekonstruktor</em> als Synonyme behandelt.  Das √§ndert sich
sobald Felder ins Spiel kommen.  Der Wertekonstruktor <code>Leuchtet</code>
ist allein noch kein Wert vom Datentyp <code>Lampe</code>.  Wir m√ºssen ihn
um einen <code>Bool</code> Wert erg√§nzen, um einen Wert vom Datentyp <code>Lampe</code>
zu erzeugen.</p><pre><code>-- Haskell Repl

&gt; data Lampe = Leuchtet Bool

&gt; :type Leuchtet
Leuchtet :: Bool -&gt; Lampe

&gt; lampeAn = Leuchtet True

&gt; :type lampeAn
lampeAn :: Lampe
</code></pre>
<p><strong>Produkte</strong></p><p>Wertekonstruktoren k√∂nnen mehr als ein Feld haben.  Hier ein
Beispiel:</p><pre><code>-- Haskell
data Datum = Datum Int Int Int  -- Tag Monat Jahr
</code></pre>
<p>Der Datentyp <code>Datum</code> hat einen Wertekonstruktor <code>Datum</code> mit drei
Feldern vom Datentyp <code>Int</code>.  So ein Datentyp  entspricht den normalen
Produkttypen, die wir oben schon kennengelernt haben.</p><p><strong>Summen von Produkten</strong></p><p>In einem ADT lassen sich Produkte und Summen kombinieren.  Hier ein
Datentyp mit drei Wertekonstruktoren, die jeweils ein Feld vom
Datentyp <code>Bool</code> haben:</p><pre><code>-- Haskell
data MyType = X Bool | Y Bool | Z Bool
</code></pre>
<p>Daraus ergeben sich die folgenden konkreten Werte:</p><ul>
<li><code>X False</code></li>
<li><code>X True</code></li>
<li><code>Y False</code></li>
<li><code>Y True</code></li>
<li><code>Z False</code></li>
<li><code>Z True</code></li>
</ul>
<p>Hier ein Datentyp mit f√ºnf Wertekonstruktoren und unterschiedlichen
Anzahlen von Feldern:</p><pre><code>-- Haskell

data Zubrot
    = K√§se Bool         -- vegan ja/nein
    | Wurst Bool        -- vegan ja/nein
    | Marmelade Int Int -- Frucht- und Zuckergehalt in %
    | Margarine
    | Butter
</code></pre>
<h2 id="die-gr√∂√üe-algebraischer-datentypen">Die Gr√∂√üe algebraischer Datentypen</h2>
<p>Die Gr√∂√üe eines ADT ist die Summe der Gr√∂√üen seiner
Wertekonstruktoren.  Die Gr√∂√üe eines Wertekonstruktors ist das
Produkt der Gr√∂√üen seiner Feldtypen.  Ein Wertekonstruktor ohne
Felder hat die Gr√∂√üe 1.  Ein Datentyp ohne Wertekonstruktoren
hat die Gr√∂√üe 0.</p><p>Wir berechnen die Gr√∂√üe f√ºr ein paar ADTs:</p><pre><code>|Nichts| == 0

|Eindeutig| == |Einheit| == 1

|Bool| == |False| + |True| == 1 + 1 == 2

|Ampel| == |Gr√ºn| + |Gelb| + |Rot| == 1 + 1 + 1 == 3

|Lampe| == |Leuchtet Bool| == |Bool| == 2

|Datum| == |Datum Int Int Int|
        == |Int| * |Int| * |Int|
        == 3^64 * 3^64 * 3^64
        == 3^192

|MyType| == |X Bool| + |Y Bool| + |Z Bool|
         == |Bool| + |Bool| + |Bool|
         == 2 + 2 + 2
         == 6

|Zubrot| == |K√§se Bool| + |Wurst Bool| + |Marmelade Int Int|
          + |Margarine| + |Butter|
         == |Bool| + |Bool| + |Int| * |Int| + 1 + 1
         == 2 + 2 + 2^64 * 2^64 + 1 + 1
         == 2^128 + 6
</code></pre>
<p>Weiter unten werden wir auch unendlich gro√üe ADTs sehen.</p><h2 id="der-mehrwert-algebraischer-datentypen">Der Mehrwert algebraischer Datentypen</h2>
<p>Mit ADTs k√∂nnen wir neue Datentypen jeder beliebigen Gr√∂√üe
erzeugen und die Datentypen, die wir schon vorliegen haben, sowohl
additiv als auch multiplikativ zu neuen Datentypen verkn√ºpfen.
F√ºr jede Datenstruktur, die sich so beschreiben l√§sst, k√∂nnen
wir einen ADT definieren.  Ich m√∂chte an zwei Beispielen zeigen,
welchen Mehrwert das hat.</p><p><strong>Beispiel 1: Verkehrsampel</strong></p><p>Ein Datentyp f√ºr die drei Zust√§nde einer aktiven Ampel k√∂nnte
so definiert sein:</p><pre><code>--Haskell
data Ampel = Gr√ºn | Gelb | Rot
</code></pre>
<p>Viele herk√∂mmliche Sprachen scheitern schon daran, einen genau
dreiwertigen Datentyp zu erzeugen.</p><p>Wenn wir entscheiden m√ºssen, ob jemand f√ºr das √úberfahren einer
Ampel im Stra√üenverkehr einen Bu√ügeldbescheid erhalten soll oder
nicht, k√∂nnen wir das wie folgt modellieren:</p><pre><code>-- Haskell

bu√ügeldbescheid :: Ampel -&gt; Bool
bu√ügeldbescheid ampel = case ampel of
    Gr√ºn -&gt; False
    Gelb -&gt; False
    Rot -&gt; True
</code></pre>
<p>Hier ist <code>bu√ügeldbescheid</code> eine Funktion von <code>Ampel</code> nach <code>Bool</code>.
Die drei Werte des Datentyps <code>Ampel</code> entsprechen den drei Zust√§nden
einer aktiven Ampel.  Mit anderen als diesen drei Werten m√ºssen
wir uns beim Implementieren nicht auseinandersetzen.  Stattdessen
k√∂nnen wir uns voll und ganz auf das Wesentliche konzentrieren: die
Zuordnung der tats√§chlichen Ampelzust√§nde nach <code>Bool</code>.  Auch beim
Verwenden der Funktion ohne Kenntnis ihrer Implementierung m√ºssen
wir uns keine Gedanken √ºber andere als diese drei Werte machen,
denn die Funktion akzeptiert nur diese drei und der Compiler sichert
das f√ºr uns ab.</p><p>Ganz anders sieht das aus, wenn wir bei der Modellierung des selben
Sachverhaltes ohne ADTs bzw. ohne Summentypen auskommen m√ºssen.
Wir sind dann gezwungen, auf bestehende Datentypen zur√ºckzugreifen.
Zum Beispiel so:</p><pre><code>-- Haskell

gr√ºn = 0
gelb = 1
rot = 2

bu√ügeldbescheid :: Int -&gt; Bool
bu√ügeldbescheid ampel =
    ampel /= gr√ºn &amp;&amp; ampel /= gelb
</code></pre>
<p>Man kann so programmieren, aber die Funktion hat jetzt f√ºr den
Compiler einen Definitionsbereich aus <code>2^64</code> Werten.  Drei davon
k√ºmmern uns: n√§mlich <code>0</code>, <code>1</code> und <code>2</code> bzw. <code>gr√ºn</code>, <code>gelb</code>
und <code>rot</code>.  Die √ºbrigen 18446744073709551613 Werte sind f√ºr den
modellierten Sachverhalt √ºberfl√ºssig.  Aber k√∂nnen wir uns darauf
verlassen, dass kein anderer Wert an die Funktion √ºbergeben wird?
So wie sie jetzt implementiert ist, werden die 18446744073709551613
√ºberfl√ºssigen Werte auf <code>True</code> abgebildet.  Das k√∂nnte zur Folge
haben, dass Bu√ügeldbescheide an Personen versendet werden, die
nicht bei Rot gefahren sind, weil jemand den Aufruf der Funktion
vermasselt hat, oder weil jemand die Dokumentation nicht richtig
gelesen hat, oder weil die Implementierung sich zwischenzeitlich
ge√§ndert hat: bei einem Refactoring wurde der R√ºckgabewert f√ºr
die 18446744073709551613 √ºberfl√ºssigen Werte ver√§ndert und schon
tritt ein Fehler auf, den es vorher nicht gab.</p><p>Hier liegt ein Fehlerpotenzial vor, das es nicht gibt wenn man ADTs
verwendet um die Definitions- und Wertebereiche der Funktionen,
Prozeduren und Methoden so festzulegen, dass sie genau zum
modellierten Sachverhalt passen.</p><p><strong>Beispiel 2: unbekanntes Alter</strong></p><p>Stellen wir uns vor, dass wir einen Datentyp f√ºr das Alter von
Personen als ganze Zahl in Jahren ben√∂tigen.  Es liegt auf der
Hand, daf√ºr den Datentyp <code>Int</code> zu verwenden.  Noch besser w√§re
ein Datentyp f√ºr nat√ºrliche Zahlen, aber darum k√ºmmern wir uns
jetzt nicht.</p><p>Komplizierter ist es, wenn wir ber√ºcksichtigen m√ºssen, dass das
Alter einer Person unbekannt sein kann.  Wie bilden wir das ab?
Ich zeige erst, wie hier ein ADT helfen kann.  Dann kritisiere
ich, wie das in Sprachen ohne ADTs gel√∂st wird.  Also, hier mein
Vorschlag f√ºr einen passenden Datentyp:</p><pre><code>-- Haskell
data Alter = AlterUnbekannt | Alter Int
</code></pre>
<p>Ein Wert vom Datentyp <code>Alter</code> ist entweder <code>AlterUnbekannt</code> oder
<code>Alter</code> mit einem <code>Int</code> Feld.  Stellen wir uns die drei Personen
Marit, Marta und Max vor.  Marit ist 30, Marta ist 11 und von Max
kennen wir das Alter nicht.</p><pre><code>-- Haskell

maritAlter :: Alter
maritAlter = Alter 30

martaAlter :: Alter
martaAlter = Alter 11

maxAlter :: Alter
maxAlter = AlterUnbekannt
</code></pre>
<p>Auf diese Weise unterscheiden wir sauber zwischen einem bekannten und
einem unbekannten Alter.  Eine Funktion, die Altersklassen bestimmt,
k√∂nnte so aussehen:</p><pre><code>-- Haskell

data Altersklasse
    = Minderj√§hrig
    | Vollj√§hrig
    | AltersklasseUnbekannt

altersklasse :: Alter -&gt; Altersklasse
altersklasse Alter = case alter of
    Alter n -&gt; if n &lt; 18 then Minderj√§hrig else Vollj√§hrig
    AlterUnbekannt -&gt; AltersklasseUnbekannt
</code></pre>
<p>Schauen wir uns die Altersklassen von Marit, Marta und Max an:</p><pre><code>-- Haskell Repl

&gt; altersklasse maritAlter
Vollj√§hrig

&gt; altersklasse martaAlter
Minderj√§hrig

&gt; altersklasse maxAlter
AltersklasseUnbekannt
</code></pre>
<p>Dadurch, dass unser Datentyp <code>Alter</code> ganz ausdr√ºcklich auch den Wert
<code>AlterUnbekannt</code> hat, m√ºssten wir uns schon besondere M√ºhe geben,
um diesen Fall bei der Berechnung der Altersklasse unter den Tisch
fallen zu lassen.</p><p>Aber wie w√ºrden wir das ohne ADTs modellieren?  Hier noch mal der
zu modellierende Sachverhalt: wir m√ºssen das Alter von Personen
codieren und dabei ber√ºcksichtigen, dass ein Alter unbekannt sein
kann.  In Sprachen ohne ADTs gibt es f√ºr die Codierung solcher
Sonderf√§lle zwei verschiedene L√∂sungsans√§tze.</p><p><strong>Ansatz 1 ohne ADTs: Numerische Fehlercodes</strong></p><p>Bilde Sonderf√§lle wie Fehlercodes auf Werte ab, die zum selben
Datentyp geh√∂ren wie die modellierte Gr√∂√üe, aber offensichtlich
kein Wert der modellierten Gr√∂√üe sind.  Das setzt voraus, dass
der Datentyp zus√§tzlichen Platz daf√ºr bietet.  Ein gutes Beispiel
daf√ºr ist die Java String-Methode <code>indexOf</code>, die man verwendet um
nach Substrings zu suchen.  Wenn der Substring gefunden wurde, wertet
<code>indexOf</code> zu dem Index aus, bei dem der Substring beginnt.  Wenn der
Substring nicht gefunden wurde, wertet <code>indexOf</code> zu <code>-1</code> aus:</p><pre><code>// Java
&quot;abc&quot;.indexof(&quot;c&quot;)  // Wertet aus zu: 2
&quot;abc&quot;.indexOf(&quot;d&quot;)  // Wertet aus zu: -1 
</code></pre>
<p>Die Idee dahinter ist, dass Indizes nat√ºrliche Zahlen sind und
dass daher mit dem R√ºckgabewert <code>-1</code> offensichtlich kein Index
gemeint sein kann.  In unserem Fall k√∂nnte der Ansatz so aussehen:</p><pre><code>-- Haskell

maritAlter :: Int
maritAlter = 30

martaAlter :: Int
martaAlter = 11

maxAlter :: Int
maxAlter = -1
</code></pre>
<p>Wenn wir jetzt die Altersklassen berechnen und dabei nicht genau
aufpassen, k√∂nnte die folgende Funktion zustande kommen:</p><pre><code>-- Haskell

data Altersklasse = Minderj√§hrig | Vollj√§hrig

altersklasse :: Int -&gt;  Altersklasse
altersklasse alter =
    if alter &lt; 18 then Minderj√§hrig else Vollj√§hrig
</code></pre>
<p>Die Altersklassen f√ºr Marit, Marta und Max sehen dann wie folgt aus:</p><pre><code>-- Haskell Repl

&gt; altersklasse maritAlter
Vollj√§hrig

&gt; altersklasse martaAlter
Minderj√§hrig

&gt; altersklasse maxAlter
Minderj√§hrig
</code></pre>
<p>Das ist nat√ºrlich Murks.  Wir wissen gar nicht, ob Max minderj√§hrig
ist, weil wir sein Alter nicht kennen.  Der Fehler ist aber
nachvollziehbar: bei der Implementierung von <code>altersklasse</code> legen
wir fest, dass Personen minderj√§hrig sind wenn ihr Alter in Jahren
kleiner als 18 ist, denn genau so ist Minderj√§hrigkeit definiert.
Um den Fehler zu vermeiden, m√ºssen wir wissen, dass hier auch
negative Zahlen zu ber√ºcksichtigen sind und dass <code>-1</code> das Fehlen
der Altersinformation repr√§sentiert:</p><pre><code>-- Haskell

data Altersklasse
    = Minderj√§hrig
    | Vollj√§hrig
    | AltersklasseUnbekannt

altersklasse :: Int -&gt;  Altersklasse
altersklasse alter =
    if alter &lt; 0 then AltersklasseUnbekannt
    else if alter &lt; 18 then Minderj√§hrig
    else Vollj√§hrig
</code></pre>
<p>Wir gehen hier noch einen Schritt weiter und bilden alle negativen
Zahlen auf <code>AltersklasseUnbekannt</code> ab.  Dadurch sind wir schon
auf der sicheren Seite wenn weitere Fehlercodes dazukommen.
Die Altersklassen f√ºr Marit, Marta und Max stimmen jetzt wieder:</p><pre><code>-- Haskell Repl

&gt; altersklasse maritAlter
Vollj√§hrig

&gt; altersklasse martaAlter
Minderj√§hrig

&gt; altersklasse maxAlter
AltersklasseUnbekannt
</code></pre>
<p>Javas <code>indexOf</code> Methode hat die gleiche Schw√§che.  Wenn wir
bspw. in vielen Strings den gleichen Substring suchen, um seinen
durchschnittlichen Index zu berechnen, d√ºrfen wir nicht vergessen,
den Wert <code>-1</code> gesondert zu verarbeiten.  Sonst berechnen wir
ein falsches Ergebnis.  Besser ist es, wenn wir zwischen der
erfolgreichen und der gescheiterten Suche so unterscheiden, dass
auch der Compiler diese Unterscheidung absichert.  Andernfalls liegt
die volle Verantwortung f√ºr diese Unterscheidung bei der Person,
die programmiert.</p><p><strong>Ansatz 2 ohne ADTs: Nullreferenzen</strong></p><p>Verwende Referenzdatentypen und stelle fehlende Werte dar als
Nullreferenzen.  Ein gutes Beispiel daf√ºr ist die Prozedur <code>strstr</code>
aus der C-Standard-Bibliothek:</p><pre><code>// C
char *result = strstr(myString, mySubstr);
</code></pre>
<p>Wenn <code>mySubstr</code> in <code>myString</code> enthalten ist, dann enth√§lt <code>result</code>
jetzt eine Referenz auf die Speicheradresse der Anfangsposition von
<code>mySubstr</code> innerhalb von <code>myString</code>.  Andernfalls enth√§lt <code>result</code>
jetzt die Nullreferenz <code>NULL</code>.</p><p>In Sprachen, die es erlauben, Nullreferenzen so zu verwenden,
muss man h√∂llisch aufpassen: es kann passieren, dass man glaubt,
einen Wert zu verarbeiten obwohl man eine Nullreferenz verarbeitet.
Das f√ºhrt leicht zu Laufzeitfehlern.  In Haskell, Purescript,
etc. kann ich das nicht demonstrieren, weil es in diesen Sprachen
keine Referenzdatentypen und keine Nullreferenzen gibt.  Deswegen
hier ein bisschen Java Code:</p><pre><code>// Main.java

class Alter {
    int wert;
    public Alter(int wert) {
        this.wert = wert;
    }
    public int get() {
        return this.wert;
    }
}
class Person {
    public Alter alter;
    enum Altersklasse { minderj√§hrig, vollj√§hrig }
    public Altersklasse altersklasse() {
        if (this.alter.get() &lt; 18) {
            return Altersklasse.minderj√§hrig;
        } else {
            return Altersklasse.vollj√§hrig;
        }
    }
}
class Main {
    public static void main(String[] args) {
        Person marit = new Person();
        Person marta = new Person();
        Person max = new Person();

        marit.alter = new Alter(30);
        marta.alter = new Alter(11);

        System.out.println(marit.altersklasse());
        System.out.println(marta.altersklasse());
        System.out.println(max.altersklasse());
    }
}
</code></pre>
<p>Ich wickle das Alter einer Person hier in einen Datentyp <code>Alter</code> ein,
weil Basisdatentypen wie <code>int</code> in Java keine Referenzdatentypen sind.
Das passiert wenn wir das Programm compilieren und ausf√ºhren:</p><pre><code>$ javac Main.java
$ java Main
vollj√§hrig
minderj√§hrig
Exception in thread &quot;main&quot; java.lang.NullPointerException
        at Person.altersklasse(Main.java:21)
        at Main.main(Main.java:14)
</code></pre>
<p>Wir haben f√ºr Max kein Alter festgelegt.  Sobald wir seine
Altersklasse abrufen, terminiert das Programm mit einer
<code>NullPointerException</code>.  Selbstverst√§ndlich l√§sst sich das
beheben, indem wir die Aufz√§hlung <code>Altersklasse</code> und die Methode
<code>altersklasse</code> anpassen, so wie wir es auch weiter oben gemacht
haben.  Die volle Verantwortung daf√ºr, solche Laufzeitfehler zu
vermeiden, liegt hier wieder bei der Person, die programmiert.</p><p>Welcher dieser beiden Ans√§tze ist besser?  Das kommt darauf an, ob
uns die Vermeidung von Laufzeitfehlern oder die Vermeidung falscher
Ergebnisse wichtiger ist.  Bei der Haskell-Funktion <code>altersklasse :: Alter -&gt; Altersklasse</code>, mit der wir begonnen haben, er√ºbrigt sich
diese Abw√§gung: Nullreferenzen gibt es nicht und um das numerische
Alter mit einem Fehlercode zu erg√§nzen, f√ºhren wir einen neuen
Datentyp ein, der durch zwei Wertekonstruktoren sauber unterscheidet
zwischen einem bekannten und einem unbekannten Alter.</p><h2 id="parametrische-algebraische-datentypen">Parametrische algebraische Datentypen</h2>
<p>Parametriche ADTs sind ADTs, die in ihrer Definition einen
sogenannten <em>Typparameter</em> enthalten.  Das ist ein Platzhalter,
der durch einen konkreten Datentyp ersetzt werden muss, damit
aus dem parametrischen ADT ein konkreter Datentyp wird.  Solche
Datentypen, die erst noch konkretisiert werden m√ºssen, nennt man
auch <em>generische Datentypen</em>.  Um das Konzept zu demonstrieren,
schauen wir uns noch mal den oben definierten Datentyp <code>Alter</code> an.
Wir steigen an der Stelle von Haskell auf Purescript um, damit wir
weiter unten Record-Literale verwenden k√∂nnen:</p><pre><code>-- Purescript
data Alter = AlterUnbekannt | Alter Int
</code></pre>
<p>Wir haben diesen Datentyp eingef√ºhrt, um zu modellieren, dass das
Alter einer Person manchmal bekannt und manchmal unbekannt ist.
Aber dieses Problem kann auch bei anderen Daten auftreten.
Wir k√∂nnten daf√ºr jedes mal einen spezifischen Datentyp einf√ºhren:</p><pre><code>-- Purescript
data Name = NameUnbekannt | Name String
data Alter = AlterUnbekannt | Alter Int
data Wohnort = WohnortUnbekannt | Wohnort String
data Beruf = BerufUnbekannt | Beruf String
...
</code></pre>
<p>Ein beispielhafter Record f√ºr Marta mit diesen Datentypen k√∂nnte
so aussehen:</p><pre><code>-- Purescript
marta =
    { name : Name &quot;Marta&quot;
    , alter : Alter 11
    , wohnort : WohnortUnbekannt
    , beruf : BerufUnbekannt
    }
</code></pre>
<p>Wir m√ºssen aber nicht jeden Datentyp separat auf diese Weise
erweitern.  Stattdessen k√∂nnen wir einen generischen Datentyp
festlegen, der jeden existierenden Datentyp um die M√∂glichkeit
eines fehlenden Wertes erweitert:</p><pre><code>-- Purescript
data Vielleicht a = Unbekannt | Wert a
</code></pre>
<p>Damit k√∂nnen wir jeden Datentyp so erweitern, dass ein Wert dieses
Typs entweder vorhanden oder abhanden ist.  Wenn wir das Alter
einer Person kennen, sieht das so aus:</p><pre><code>-- Purescript
alter :: Vielleicht Int
alter = Wert 23
</code></pre>
<p>Wenn wir das Alter nicht kennen, sieht das so aus:</p><pre><code>-- Purescript
alter :: Vielleicht Int
alter = Unbekannt
</code></pre>
<p>Das gleiche Spiel mit dem Wohnort:</p><pre><code>-- Purescript
wohnort :: Vielleicht String
wohnort = Wert &quot;Leipzig&quot;
</code></pre>
<p>Oder wenn der Wohnort unbekannt ist:</p><pre><code>-- Purescript
wohnort :: Vielleicht String
wohnort = Unbekannt
</code></pre>
<p>Beachte, dass das Alter den Datentyp <code>Int</code> hat aber der Wohnort
den Datentyp <code>String</code>.  Trotzdem konnten wir in beiden F√§llen
den generischen Datentyp <code>Vielleicht a</code> einsetzen. Wir haben damit
den Datentyp <code>Int</code> auf <code>Vielleicht Int</code> und den Datentyp <code>String</code>
auf <code>Vielleicht String</code> erweitert.  Ein ganzer Record f√ºr Marta
k√∂nnte so aussehen:</p><pre><code>-- Purescript

marta =
    { name : Wert &quot;Marta&quot;
    , alter : Wert 11
    , wohnort : Wert &quot;Leipzig&quot;
    , beruf : Wert &quot;Sch√ºlerin&quot;
    }
</code></pre>
<p>Damit sind die vier spezifischen Datentypen, die wir oben definiert
haben, √ºberfl√ºssig, weil wir sie ersetzen konnten durch einen
einzigen generischen Datentyp, der die selbe Aufgabe erf√ºllt.</p><p>In der Praxis w√ºrde man einen Datentyp wie <code>Vielleicht a</code> nicht
definieren, sondern den Datentyp <code>Maybe a</code> verwenden, der genau
f√ºr diesen Zweck schon vordefiniert ist und die selbe Struktur hat.
Zum Vergleich hier die beiden Datentypen:</p><pre><code>-- Purescript
data Vielleicht a = Unbekannt | Wert a
data Maybe a = Nothing | Just a
</code></pre>
<p>Es geh√∂rt zum guten Programmierstil, die vordefinierten Datentypen
zu verwenden wenn die Struktur passt.  Das erh√∂ht die Lesbarkeit.
Es kann zwar manchmal sinnvoll sein, trotzdem eigene Datentypen
zu verwenden, um zu verdeutlichen, worum es geht, aber je mehr man
beim Lesen von Code schon kennt, desto verst√§ndlicher ist der Code.</p><h2 id="unendlich-gro√üe-datentypen">Unendlich gro√üe Datentypen</h2>
<p>Bisher haben wir nur ADTs mit endlicher Gr√∂√üe betrachtet.  Es gibt
aber auch ADTs, die unendlich gro√ü sind.  Das ist zum Beispiel
der Fall bei ADTs, die rekursiv √ºber sich selbst definiert sind.
Ein gutes Beispiel daf√ºr sind verkettete Listen:</p><pre><code>-- Purescript
List a = Nil | Cons a ( List a )
</code></pre>
<p><code>Nil</code> ist der gebr√§uchliche Name f√ºr die leere Liste.  Das hat
historische Gr√ºnde.  <code>Cons</code> nimmt einen Wert und eine Liste und
konstruiert daraus wieder eine Liste.  Die Idee dabei ist, dass man
mit der leeren Liste beginnt und von ihr ausgehend <code>Cons</code> verwendet
und durch das sukzessive Hinzuf√ºgen weiterer Werte immer gr√∂√üere
Listen konstruiert.  Hier demonstrieren wir schrittweise den Aufbau
einer Liste mit den ersten Ziffern der Kreiszahl Pi 3,1415‚Ä¶</p><pre><code>-- Purescript

list0 = Nil
list1 = Cons 5 Nil
list2 = Cons 1 ( Cons 5 Nil )
list3 = Cons 4 ( Cons 1 ( Cons 5 Nil ) )
list4 = Cons 1 ( Cons 4 ( Cons 1 ( Cons 5 Nil ) ) )
list5 = Cons 3 ( Cons 1 ( Cons 4 ( Cons 1 ( Cons 5 Nil ) ) ) )
</code></pre>
<p>Haskell unterst√ºtzt f√ºr verkettete Listen eine kompaktere und
freundlichere Syntax, mit der man z.B. <code>list5</code> schreiben kann
als <code>[3,1,4,1,5]</code>.  Aber letztlich erfolgt die Konstruktion von
verketteten Listen auch in Haskell genau so wie oben beschrieben.</p><p><code>List a</code> ist generisch (bzw. parametrisch).  Diese Beispiele haben
allesamt den Datentyp <code>List Int</code>.  Nat√ºrlich k√∂nnen wir auch Listen
von Bools oder Floats oder Strings etc. konstruieren.  Die Werte
einer Liste m√ºssen aber allesamt den selben Datentyp haben.</p><p>Aus der Definition des generischen Listendatentyps folgt, dass
man aus einer Liste der Gr√∂√üe <code>n</code> immer eine Liste der Gr√∂√üe
<code>n+1</code> konstruieren kann indem man noch ein Element hinzuf√ºgt.
Daraus ergibt sich, dass Listendatentypen unendlich gro√ü sind.
Der Datentyp <code>String</code> ist in Standard-Haskell ein Typalias f√ºr
<code>List Char</code> und damit auch unendlich gro√ü.  In Purescript werden
Strings wahrscheinlich irgendwie auf Javascript-Strings abgebildet.
Auch davon gibt es unendlich viele, da man sie durch Verkettung
beliebig verl√§ngern kann.</p><h2 id="einfache-datentypen-sind-adts">Einfache Datentypen sind ADTs</h2>
<p>Ich habe es hier noch nicht erw√§hnt, aber bestimmt ist es schon
aufgefallen: die Namen von Datentypen und von Wertekonstruktoren
in einer Typdefinition mit dem <code>data</code> Schl√ºsselwort beginnen in
Haskell und in Purescript immer mit einem Gro√übuchstaben.  In Elm
ist es auch so, mit dem Unterschied, dass das Schl√ºsselwort in
Elm nicht <code>data</code>  sondern <code>type</code> ist.</p><p>W√§hrend f√ºr den Datentyp <code>Bool</code> mit den Werten <code>False</code>
und <code>True</code> in Haskell eine normale Typdefinition <a href="https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Types.html#Bool">vordefiniert
ist</a>,
ist der Datentyp <code>Boolean</code> mit den Werten <code>false</code> und <code>true</code>
in Purescript in den Compiler integriert.  Purescript ist
daf√ºr gemacht, nach Javascript zu compilieren.  Um die zu
√ºberbr√ºckende Kluft zwischen den Purescript-Datentypen und den
Javascript-Datentypen, die nach der Compilation √ºbrigbleiben,
m√∂glichst klein zu halten, orientieren sich die vordefinierten
Datentypen in Purescript an den Datentypen, die auch in Javascript
verf√ºgbar sind.  Deswegen gibt es in Purescript statt <code>Bool</code>
den Datentyp <code>Boolean</code> mit den Werten <code>false</code> und <code>true</code>, die vom
Compiler in die gleichnamigen Javascript-Werte <code>false</code> und <code>true</code>
√ºbersetzt werden.  Das gleiche macht der Purescript-Compiler mit
Zahlenliteralen, Arrays und Records.</p><p>Trotz der Sonderbehandlung durch den Compiler, h√§tte man die
Wahrheitswerte auch in Purescript <code>False</code> und <code>True</code> nennen k√∂nnen.
Ich vermute, dass man sich bewusst f√ºr die Kleinschreibung
entschieden hat, um kenntlich zu machen, dass es sich um keine
gew√∂hnlichen Wertekonstruktoren aus einer <code>data</code> Typdefinition
handelt.</p><p>Es gibt noch mehr vordefinierte Datentypen ‚Äì auch in Haskell
‚Äì deren Werte nicht √ºber eine herk√∂mmliche Typdefinition mit
Wertekonstruktoren erzeugt worden sind, sondern auf besondere Weise
vom Compiler unterst√ºtzt werden.  Die numerischen Datentypen sind
das beste Beispiel daf√ºr.  Eine Sonderbehandlung numerischer
Datentypen und Werte durch den Compiler ist schon f√ºr die
syntaktische Unterst√ºtzung der gew√∂hnlichen Zahlenliterale wie
<code>-123.45</code>, <code>0.0</code> und <code>99999</code> n√∂tig, aber auch f√ºr die effiziente
Arithmetik auf diesen Datentypen.</p><p>In Haskell kommt noch dazu, dass Zahlenliterale wie <code>1</code> und <code>1.0</code>
√ºberladen sind.  <code>1</code> kann in Haskell sowohl f√ºr den <code>Int</code> Wert
<code>1</code> als auch f√ºr den <code>Float</code> wert <code>1.0</code> stehen.  Es kommen sogar
noch weitere Datentypen in Frage:</p><pre><code>-- Haskell Repl

&gt; 1 :: Int
1

&gt; 1 :: Integer
1

&gt; 1 :: Float
1.0

&gt; 1 :: Double
1.0

&gt; import Numeric.Natural

&gt; 1 :: Natural
1
</code></pre>
<p><code>Integer</code> ist ein Datentyp f√ºr ganze Zahlen, der beliebig gro√üe
Zahlen aufnehmen kann, solange der Speicherplatz es zul√§sst.
<code>Natural</code> ist ein Datentyp f√ºr nat√ºrliche Zahlen.  Zahlenliterale
in Gleitkommaschreibweise sind in Haskell ebenso √ºberladen:</p><pre><code>-- Haskell Repl

&gt; 1.0 :: Int
1

&gt; 1.0 :: Integer
1

&gt; 1.0 :: Float
1.0

&gt; 1.0 :: Double
1.0

&gt; import Numeric.Natural

&gt; 1.0 :: Natural
1
</code></pre>
<p>Trotz ihrer Besonderheiten, k√∂nnen wir solche Datentypen auch
als ADTs auffassen.  Die Wahrheitswerte <code>false</code> und <code>true</code>
werden in Purescript zwar klein geschrieben, aber das ist
nur Syntax.  Davon abgesehen k√∂nnen wir komplett ignorieren,
dass der Datentyp <code>Boolean</code> nicht auf einer herk√∂mmlichen <code>data</code>
Typdefinition basiert.  Es folgt daraus nichts, worauf wir beim
Programmieren achtgeben m√ºssten.  So ist es auch mit den numerischen
Datentypen: Zahlenliterale wie <code>-3.1415</code> und <code>42</code> sind zwar keine
gew√∂hnlichen Wertekonstruktoren, aber wir k√∂nnen jeden numerischen
Datentyp auffassen als einen Summentyp mit all seinen Werten als
Wertekonstruktoren ohne Typfelder:</p><pre><code>-- Pseudo-Haskell
data Natural = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | ...
</code></pre>
<p>Prinzipiell k√∂nnten wir die ganzen numerischen Datentypen
und die gesamte Zahlenarithmetik auch aus gew√∂hnlichen <code>data</code>
Typdefinitionen nachbauen.  Wir m√ºssen uns daf√ºr nur streng an
die Konstruktionsregeln halten.  F√ºr nat√ºrliche Zahlen sind das
die Peano-Axiome.  Ein selbstgebauter Datentyp f√ºr nat√ºrliche
Zahlen k√∂nnte so aussehen:</p><pre><code>-- Haskell

data Nat = Null | Nachfolger Nat

plus :: Nat -&gt; Nat -&gt; Nat
plus a b = case a of
    Nachfolger n -&gt; plus n ( Nachfolger b ) 
    Null -&gt; b

mal :: Nat -&gt; Nat -&gt; Nat
mal a b = case a of
    Null -&gt; Null
    Nachfolger Null -&gt; b
    Nachfolger n -&gt; plus b ( mal n b )
</code></pre>
<p>F√ºr fast alle praktischen Anwendungen w√§re das v√∂llig unbrauchbar.
Ohne die spezielle Syntax f√ºr Zahlenliterale w√§re es sehr sehr
umst√§ndlich und m√ºhsam, Zahlen aufzuschreiben und zu lesen.
Die Zahlenarithmetik w√§re damit unendlich langsam.  Worum es mir
hier geht, ist, dass sich numerische Datentypen, Arrays, Records,
Strings usw. zumindest rein formal auch als algebraische Datentypen
auffassen lassen.  Das verdeutlicht, wie flexibel ADTs sind: jeder
Datentyp, der sich als ein Summentyp aus Produkttypen darstellen
l√§sst, kann als ADT beschrieben werden.</p><h2 id="isomorphismen-und-aliase">Isomorphismen und Aliase</h2>
<p>Bisher haben wir neue Datentypen mit dem <code>data</code> Schl√ºsselwort
definiert.  Wir k√∂nnten es dabei belassen.  Es gibt aber noch zwei
weitere Schl√ºsselw√∂rter, mit denen sich Datentypen definieren
lassen: <code>newtype</code> und <code>type</code>.</p><p><strong>Isomorphismen</strong></p><p>Mit dem <code>newtype</code> Schl√ºsselwort lassen sich neue Datentypen
definieren, die genau einen Wertekonstruktor mit genau einem Feld
haben.  Damit ist <code>newtype</code> auf den ersten Blick √ºberfl√ºssig, denn
dasselbe k√∂nnen wir auch mit dem <code>data</code> Schl√ºsselwort erledigen:</p><pre><code>-- Haskell
data T1 = K1 Bool
newtype T2 = K2 Bool
</code></pre>
<p>Wenn man dasselbe auch mit dem <code>data</code> Schl√ºsselwort machen kann,
warum gibt es dann f√ºr diesen Spezialfall ein zus√§tzliches
Schl√ºsselwort?  Um das beanworten zu k√∂nnen, m√ºssen wir wissen,
dass die Verwendung von Datentypen mit gewissen Laufzeitkosten
verbunden ist.  Beispielsweise einen <code>Int</code> Wert in einen <code>Maybe</code>
Kontext zu stecken und an anderer Stelle wieder aus diesem
<code>Maybe</code> Kontext zu befreien: das sind Rechenoperationen, die
zur Laufzeit des Programms stattfinden und ein kleines bisschen
Speicher und Rechenzeit kosten.  Wir nehmen das normalerweise gern
in Kauf, weil uns ein korrektes Programm ohne Laufzeitfehler in den
meisten F√§llen viel wichtiger ist als ein Programm, das m√∂glichst
schnell und speichereffizient arbeitet, aber der Sonderfall eines
Datentyps <code>T</code> aus genau einem Wertekonstruktor mit genau einem
Feld ist hier deswegen interessant, weil bei so einem Datentyp eine
Eins-zu-eins-Beziehung zwischen den Werten von <code>T</code> und den Werten
des Feldtyps besteht.  Hier ein Beispiel:</p><pre><code>-- Haskell
data WrapInt = Wrap Int
</code></pre>
<p>Dann gilt die Eins-zu-eins-Beziehung:</p><pre><code>...
Wrap -3 &lt;--&gt; -3 
Wrap -2 &lt;--&gt; -2 
Wrap -1 &lt;--&gt; -1 
Wrap 0  &lt;--&gt; 0 
Wrap 1  &lt;--&gt; 1 
Wrap 2  &lt;--&gt; 2 
Wrap 3  &lt;--&gt; 3 
Wrap 4  &lt;--&gt; 4 
Wrap 5  &lt;--&gt; 5 
Wrap 6  &lt;--&gt; 6 
Wrap 7  &lt;--&gt; 7 
...
</code></pre>
<p>In der Mathematik nennt man so eine Eins-zu-eins-Beziehung einen
Isomorphismus.  Wenn ein Isomorphismus zwischen Datentypen besteht,
ist es schade um den Speicher und die Rechenzeit, die es zur
Laufzeit des Programms kostet, Werte zwischen diesen Datentypen
zu konvertieren.  Hier kommt <code>newtype</code> ins Spiel.  Ein Beispiel:</p><pre><code>-- Haskell
newtype Password = Password String
</code></pre>
<p>Es kann sinnvoll sein, f√ºr Passw√∂rter einen eigenen Datentyp
einzuf√ºhren.  Am Ende ist nat√ºrlich jedes Passwort einfach nur
ein String, aber wenn wir auf der Typebene zwischen <code>String</code> und
<code>Password</code> streng unterscheiden, k√∂nnen wir z.B. die Erzeugung von
schlechen Passw√∂rtern verhindern.  Daf√ºr legen wir ein eigenes
Modul an, das den Datentyp <code>Password</code> und bspw. eine sorgf√§ltig
geschriebene Funktion <code>makePassword : IO Password</code> enth√§lt.  Der
entscheidende Trick ist, dass wir den Wertekonstruktor <code>Password</code>
nicht exportieren.  Dadurch ist Code au√üerhalb dieses Moduls
gezwungen, die Funktion <code>makePassword</code> zu verwenden, um an einen
<code>Password</code> Wert zu kommen.</p><p>Wir k√∂nnen semantisch (fast) exakt dasselbe auch mit dem <code>data</code>
Schl√ºsselwort erreichen, aber wenn wir das <code>newtype</code> Schl√ºsselwort
verwenden, entfernt der Compiler alle <code>Password</code> Wertekonstruktoren,
so dass zur Laufzeit des Programms nur noch gew√∂hnliche <code>String</code>
Werte √ºbrigbleiben.  Dadurch entfallen der Speicher und die
Rechenzeit, die es sonst zur Laufzeit des Programms gekostet h√§tte,
Werte zwischen diesen Datentypen zu konvertieren.</p><p><em>√úbrigens gibt es doch einen semantischen Unterschied zwischen
<code>data</code> und <code>newtype</code>, der die Auswertungsstrategie betrifft:
Wertekonstruktoren werden bei <code>data</code> verz√∂gert ausgewertet und bei
<code>newtype</code> strikt ausgewertet.  Was das bedeutet, m√∂chte ich hier
nicht erl√§utern.  Der Text ist schon lang genug und der Unterschied
ist ohnehin marginal: beide Auswertungsstrategien f√ºhren auf den
gleichen Wert, wenn sie erfolgreich auswerten.  Es gibt aber F√§lle
in denen die verz√∂gerte Auswertung Erfolg hat aber die strikte
Auswertung scheitert.  Daher der semantische Unterschied.</em></p><p><strong>Aliase</strong></p><p>Das <code>type</code> Schl√ºsselwort f√ºhrt einen Typalias bzw. ein
Typsynonym ein.  Das ist einfach nur ein weiterer Name f√ºr einen
existierenden Datentyp.  Beispielsweise sind herk√∂mmliche Strings
in Haskell nichts weiter als verlinkte Listen von <code>Char</code> Werten.
Entsprechend ist der Datentyp <code>String</code> wie folgt definiert:</p><pre><code>-- Haskell
type String = List Char
</code></pre>
<p>Das Beispiel <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/src/GHC.Base.html#String">stimmt nicht
ganz</a>:
der Datentyp <code>List Char</code> wird in idiomatischem Haskell als <code>[Char]</code>
geschrieben.  Darauf m√∂chte ich hier aber nicht n√§her eingehen.
Leider gibt es in Haskell ein paar Schrulligkeiten wie diese, die die
Sprache unn√∂tig und ohne substaniellen Mehrwert verkomplizieren.
Deswegen bin ich wirklich froh, dass es mittlerweile Alternativen
wie Purescript gibt.</p><h2 id="typklassen">Typklassen</h2>
<p>Typklassen werden unterst√ºtzt in Haskell und in Purescript.
Sie haben nichts zu tun mit Klassen in der OOP.  Ein Konzept
aus anderen Sprachen, das mit Typklassen vergleichbar ist, sind
Interfaces.  Jede Typklasse benennt eine Reihe von Funktionen.
Ein Datentyp kann zu einer Typklasse hinzugef√ºgt werden, wenn er
alle Funktionen der Typklasse implementiert.  Hier ein Beispiel
f√ºr eine Typklasse mit einer zu implementierenden Funktion:</p><pre><code>-- Purscript
class Eq a where
    eq :: a -&gt; a -&gt; Boolean
</code></pre>
<p>Ein Datentyp <code>a</code> der Klasse <code>Eq</code> muss also die Funktion <code>eq</code>
implementieren, die zwei Werte vom Datentyp <code>a</code> aufnimmt und einen
<code>Boolean</code> Wert berechnet.  <code>Eq</code> (f√ºr equality) ist sowohl in
Purescript als auch in Haskell eine vordefinierte Typklasse f√ºr
die Datentypen, auf denen die Gleichheitsfunktion <code>eq</code> bzw. der
Gleichheitsoperator <code>==</code> gegeben sein soll.</p><p>Eine Funktion, die wie <code>eq</code> auf mehreren Datentypen
operieren kann, nennt man eine polymorphe Funktion.  Wenn der
Polymorphismus √ºber Typklassen hergestellt wird, spricht man
von Typklassenpolymorphismus.  <em>Generisch</em>, <em>parametrisch</em> und
<em>polymorph</em> sind hier eng verwandte Begriffe.  Wenn es um Datentypen
geht, spricht man von generischen oder parametrischen Datentypen.
Bei Funktionen spricht man von generischen oder polymorphen
Funktionen.</p><p>Den Code f√ºr die <code>Eq</code> Typklasse im Purescript Prelude k√∂nnen wir
hier nachlesen:</p><p><a href="https://github.com/purescript/purescript-prelude/blob/v6.0.1/src/Data/Eq.purs#L35-L36">https://github.com/purescript/purescript-prelude/blob/v6.0.1/src/Data/Eq.purs#L35-L36</a></p><p>Er stimmt mit der oben angegebenen Definition √ºberein.  Direkt
darunter befindet sich die Definition f√ºr den Gleichheitsoperator:</p><pre><code>infix 4 eq as ==
</code></pre>
<p>Die Zeile legt fest, dass der Infix-Operator <code>==</code> ein Alias f√ºr
die Funktion <code>eq</code> ist und in der Operatorrangfolge an vierter
Stelle steht.  Wenn <code>==</code> ein Alias f√ºr <code>eq</code> ist und <code>eq</code> eine
Funktion der Typklasse <code>Eq</code> ist, dann muss ein Datentyp die Klasse
<code>Eq</code> implementieren, damit der Operator <code>==</code> f√ºr seine Werte
verf√ºgbar ist.  Probieren wir das aus:</p><pre><code>-- Purescript Repl

&gt; 123 == 123
true

&gt; 123 == 124
false

&gt; &quot;abc&quot; == &quot;abc&quot;
true

&gt; &quot;abc&quot; == &quot;bcd&quot;
false

&gt; false == false
true

&gt; false == true
false
</code></pre>
<p>Demnach implementieren die Datentypen <code>Int</code>, <code>String</code> und <code>Boolean</code>
die Typklasse <code>Eq</code>.  Unser selbst definierter Datentyp <code>Bool</code>
implementiert <code>Eq</code> noch nicht:</p><pre><code>-- Purescript Repl

&gt; data Bool = False | True

&gt; False == False
...
No type class instance was found for

  Data.Eq.Eq Bool
...
</code></pre>
<p>Das k√∂nnen wir aber mit einer Instanzdeklaration nachholen.
Mit einer Instanzdeklaration f√ºgt man einen Datentyp zu einer
Typklasse hinzu.  Anschlie√üend kann man die Funktionen und
Operatoren der Typklasse auf Werte von diesem Datentyp anwenden:</p><pre><code>-- Purescript

instance Eq Bool where
    eq a b = case [a,b] of
        [False,False] -&gt; true
        [True,True] -&gt; true
        _ -&gt;false

-- Purescript Repl

&gt; False == False
true
</code></pre>
<p>Damit ist gekl√§rt, was Typklassen sind: ein Formalismus um
polymorphe Funktionen zu beschreiben.  Oft h√§ngt an den Funktionen
einer Typklasse eine bestimmte Erwartungshaltung hinsichtlich ihrer
Semantik, die vom Typsystem nicht erfasst wird.  Beispielsweise
h√§tten wir <code>eq</code> auch so angeben k√∂nnen:</p><pre><code>-- Purescript

eq a b = case [a,b] of
    [False,False] -&gt; False
    [True,True] -&gt; False
    _ -&gt;True
</code></pre>
<p>Damit w√ºrde <code>eq</code> nicht mehr auf Gleichheit pr√ºfen sondern
auf Ungleichheit.  Der Compiler w√ºrde die Definition trotzdem
akzeptieren, weil der Datentyp passt.  Aber der Gleichheitsoperator
<code>==</code> w√ºrde sich f√ºr diesen Datentyp anders verhalten als erwartet
und damit f√ºr reichlich Verwirrung sorgen.</p><p>Man kann zwischen Typklassen auch Abh√§ngigkeiten definieren:</p><pre><code>-- Purescript
class (A T, B T, C T) &lt;= D T ...
</code></pre>
<p>Das bedeutet, dass ein Datentyp <code>T</code> nur dann zur Typklasse <code>D</code>
geh√∂ren kann, wenn er auch zu den Typklassen <code>A</code>, <code>B</code> und <code>C</code>
geh√∂rt.  In Haskell sind solche Abh√§ngigkeiten auch m√∂glich.
Die Syntax ist fast identisch.  Nur der Doppelpfeil wird in Haskell
umgekehrt notiert: <code>=&gt;</code>.  Wenn links vom Pfeil nur eine Typklasse
steht, k√∂nnen die Klammern entfallen.</p><p>Elm unterst√ºtzt keine Typklassen.  In Haskell und Purescript sind
zum Beispiel die arithmetischen Operatoren auf den verschiedenen
numerischen Datentypen √ºber Typklassen implementiert:</p><pre><code>-- Purescript Repl

&gt; :type (+)
forall (a :: Type). Semiring a =&gt; a -&gt; a -&gt; a

&gt; :type (-)
forall (a :: Type). Ring a =&gt; a -&gt; a -&gt; a

&gt; :type (*)
forall (a :: Type). Semiring a =&gt; a -&gt; a -&gt; a

&gt; :type (/)
forall (a :: Type). EuclideanRing a =&gt; a -&gt; a -&gt; a
</code></pre>
<p>Demnach ist der Operator <code>+</code> in Purescript auf den Datentypen
gegeben, die zur Typklasse <code>Semiring</code> geh√∂ren, der Operator
<code>-</code> auf den Datentypen, die zur Typklasse <code>Ring</code> geh√∂ren, usw.
Sowohl Haskell als auch Purescript haben eine mathematisch
interessante Typklassenhierarchie, aber wenn man sich f√ºr
Begriffe wie <em>Halbring</em>, <em>Ring</em> und <em>euklidischer Ring</em> nicht
interessiert, kann man sie ignorieren: sich mit diesen Begriffen
herumzuschlagen, ist <strong>keine</strong> Voraussetzung daf√ºr, in diesen
Sprachen zu programmieren!!!</p><p>Typische Idiome der funktionalen Programmierung, wie <code>map</code>, <code>foldr</code>,
<code>foldl</code>, <code>traverse</code>, oder der monadische <em>bind</em> Operator <code>&gt;&gt;=</code> sind
ebenfalls √ºber entsprechende Typklassen als polymorphe Funktionen
definiert.  Hier operiert <code>map</code> auf zwei verschiedenen Datentypen:</p><pre><code>-- Purescript Repl

&gt; map (_*2) [1,2,3]
[2,4,6]

&gt; import Data.Maybe

&gt; map (_*2) (Just 3)
(Just 6)
</code></pre>
<p>Es kommt selten vor, dass ich eigene Typklassen schreibe, weil es
mir produktiver erscheint, konkreten Code zu schreiben und dabei
nicht dar√ºber nachzudenken, wo sich strukturelle √úbereinstimmungen
verbergen k√∂nnten, aus denen sich vielleicht polymorphe Funktionen
ableiten lassen.  Probleme, bei denen ich Typklassen vielleicht
einsetzen w√ºrde, sind Serialisierung und Persistenz.  Beispielsweise
k√∂nnte die Serialisierung und Deserialisierung zwischen einem
Datentyp <code>a</code> und Json √ºber zwei polymorphe Funktionen ablaufen:</p><pre><code>-- Purescript
class JsonSerializable a where
    toJson :: a -&gt; String
    fromJson :: String -&gt; Maybe a
</code></pre>
<p>Dazu w√ºrde ich noch fordern, dass f√ºr alle Instanzdeklarationen
gelten sollte:</p><pre><code>fromJson ( toJson value ) == Just value
map toJson ( fromJson string ) == Just string
</code></pre>
<p>Diese Regeln kann man zwar nicht vom Compiler absichern lassen,
aber eine <code>JsonSerializable</code> Instanz, die sie nicht einh√§lt,
ist offensichtlich unbrauchbar.</p><p>Eine Typklasse f√ºr die Persistenz in einer Datenbank k√∂nnte
so aussehen:</p><pre><code>-- Haskell
class Db a where
    insert :: a -&gt; IO String
    update :: String -&gt; a -&gt; IO ()
    read :: String -&gt; IO ( Maybe a )
</code></pre>
<p>Ich muss unbedingt dazusagen, dass ich mir dar√ºber maximal drei
Minuten Gedanken gemacht habe.  Es ist sehr wahrscheinlich, dass
ich hier irgendetwas entscheidendes vergessen oder √ºbersehen habe.
Als Beispiel sollte uns das an dieser Stelle trotzdem gen√ºgen.
Ich beschreibe kurz die Funktionen:</p><ul>
<li><code>insert</code> persistiert einen Wert vom Datentyp <code>a</code> als neuen Record
in der Datenbank und liefert einen String, den wir sp√§ter als
Schl√ºssel verwenden k√∂nnen, um diesen Wert zu aktualisieren
oder wieder auszulesen.</li>
<li><code>update</code> nimmt einen String als Schl√ºssel entgegen und
aktualisiert den entsprechenden Record in der Datenbank mit einem
Wert vom Datentyp <code>a</code>.</li>
<li><code>read</code> nimmt einen Schl√ºssel entgegen und liefert den
entsprechenden Wert vom Datentyp <code>a</code> aus der Datenbank.  Weil wir
nicht garantieren k√∂nnen, dass jeder Schl√ºssel auf einen
g√ºltigen Record in der Datenbank verweist, ist dieser Wert in
einen <code>Maybe</code> Kontext eingeschlossen.</li>
</ul>
<p>Ich h√§tte wirklich Lust, herauszufinden, ob das ein gutes Design
oder zu naiv ist, aber erst muss ich diesen Text fertig schreiben.</p><p>Im n√§chsten Abschnitt gehe ich auf Multiparameter-Typklassen ein.
Vorher m√∂chte ich noch eine Bemerkung zu Typklassen im Allgemeinen
loswerden: Typklassenpolymorphie ist ein produktives Konzept,
aber es lohnt sich nicht immer, auf Typklassen und polymorphe
Funktionen zu setzen.  Wenn die Polymorphie einem formalen Kalk√ºl
folgt, so wie es bei der Typklasse <code>Eq</code> und bei den arithmetischen
Operationen der Fall ist, oder wenn es darum geht, Datentypen um
Funktionalit√§t zu erweitern wie bei der Typklasse <code>JsonSerialize</code>,
dann sind Typklassen sinnvoll.  Aber man sollte nicht versuchen,
Typklassenpolymorphie zu erzwingen: manchmal ist der Code besser
ohne Typklassen.  Elm kommt ganz ohne Typklassen aus.</p><h2 id="multiparameter-typklassen">Multiparameter-Typklassen</h2>
<p><em>Eine Vorbemerkung: Man muss bei den Programmierkonzepten der
Typebene, die ich hier vorstelle, ein bisschen darauf achten, dass
man den Ball flach h√§lt.  Wenn man mit einem vordefinierten Datentyp
gut auskommt, muss man daf√ºr keinen ADT definieren.  Wenn es keinen
Grund daf√ºr gibt, einen parametrischen ADT zu definieren, sollte
man es bei einem parameterlosen ADT belassen.  Wenn man sich nicht
ganz sicher ist, ob man eine polymorphe oder mehrere monomorphe
Funktionen definieren sollte, ist es besser, auf Polymorphie zu
verzichten.  Dieser Appell gilt umso mehr f√ºr die Konzepte, die
jetzt folgen.  Mit einem guten Verst√§ndnis f√ºr ADTs, parametrische
ADTs und einfache Typklassen ist man schon sehr gut aufgestellt.
Solange man diese Konzepte nicht richtig verinnerlicht hat, muss
man sich mit den Konzepten, die jetzt noch folgen, nicht befassen.</em></p><p>Typklassen k√∂nnen mehr als einen Typparameter haben.  Auf die Weise
k√∂nnen die polymorphen Funktionen einer Typklasse Beziehungen
zwischen Datentypen beschreiben.  Die Typklasse <code>Db</code> von gerade
eben bietet sich an, um zu zeigen, wof√ºr das n√ºtzlich sein kann.
Mich st√∂rt an dieser Typklasse ein bisschen, dass der Datentyp f√ºr
die Schl√ºssel auf <code>String</code> festgelegt ist.  Warum nicht <code>Int</code>? Oder
ein spezieller Datentyp <code>Uuid</code> f√ºr sogenannte <em>Universally Unique
Identifiers</em>?  Also erweitern wir diese einfache Typklasse zu einer
Typklasse mit zwei Typparametern:</p><pre><code>-- Haskell
class Db key value where
    insert :: value -&gt; IO key
    update :: key -&gt; value -&gt; IO ()
    read :: key -&gt; IO ( Maybe value )
</code></pre>
<p>Auf diese Weise sind wir f√ºr die Schl√ºssel nicht auf den Datentyp
<code>String</code> festgelegt, sondern k√∂nnen daf√ºr einen Datentyp frei
w√§hlen.  Hier noch ein Beispiel f√ºr eine Multiparameter-Typklasse
aus dem Purescript-Buch:</p><pre><code>-- Purescript
class Stream stream element where
    uncons :: stream -&gt; Maybe { head :: element , tail :: stream }
</code></pre>
<p>Die Idee dabei ist, dass ein Wert vom Datentyp <code>stream</code> ein
Datenstrom aus Werten vom Datentyp <code>element</code> ist.  Die Funktion
<code>uncons</code> trennt diesen Datenstrom auf in den ersten Wert (<code>head</code>)
und den Rest des Datenstroms (<code>tail</code>).  Auf die Weise lassen sich die
Werte in einem Datenstrom durch wiederholtes Aufrufen von <code>uncons</code>
der Reihe nach verarbeiten.  Sobald der Datenstrom leer ist, liefert
<code>uncons</code> den Wert <code>Nothing</code>.  Wir f√ºgen die Datentypen <code>String</code>
und <code>Char</code> zur Typklasse <code>Stream</code> hinzu, indem wir eine passende
<code>uncons</code> Funktion angeben:</p><pre><code>-- Purescript
instance Stream String Char where
    uncons = String.uncons
</code></pre>
<p>Dass die Funktion <code>String.uncons</code> hier genau passt, ist g√ºnstig
f√ºr uns.  Als n√§chstes f√ºgen wir den generischen Datentyp <code>Array a</code> zusammen mit dem entsprechenden Datentyp <code>a</code> zur Typklasse
<code>Stream</code> hinzu.  Auch hier gibt es wieder eine passende <code>uncons</code>
Funktion f√ºr Arrays:</p><pre><code>-- Purescript
instance Stream ( Array a ) a where
    uncons = Array.uncons
</code></pre>
<p>Jetzt k√∂nnen wir mit der polymorphen <code>uncons</code> Funktion der <code>Stream</code>
Typklasse sowohl <code>Char</code> Werte aus <code>String</code> Datenstr√∂men als auch
<code>a</code> Werte aus <code>Array a</code> Datenstr√∂men entnehmen.</p><h2 id="funktionale-abh√§ngigkeiten">Funktionale Abh√§ngigkeiten</h2>
<p>Es w√§re jetzt naheliegend, aus <code>uncons</code> eine <code>tail</code> Funktion
abzuleiten:</p><pre><code>-- Purescript
tail :: String -&gt; Maybe String
tail stream = map _.tail ( uncons stream )
</code></pre>
<p>Wir wenden erst <code>uncons</code> auf das Argument an.  Dann wenden
wir die Feldfunktion <code>_.tail</code> auf das Zwischenergebnis an.
Das Zwischenergebnis ist in einen <code>Maybe</code> Kontext eingebettet.
Deswegen m√ºssen wir <code>map</code> einsetzen, um die Feldfunktion auf den
Wert im Kontext anzuwenden.  Das ist eine sinnvolle Definition.
Trotzdem ist der Compiler nicht mit ihr zufrieden:</p><pre><code>No type class instance was found for Main.Stream String t
</code></pre>
<p>Was funktioniert hier nicht?  Daf√ºr m√ºssen wir (ganz grob)
verstehen, wie der Compiler mit polymorphen Funktionen umgeht.  Die
beiden Instanzdeklarationen haben wir nicht ohne Grund hinzugef√ºgt.
Wenn wir die polymorphe Funktion <code>uncons</code> aufrufen, versucht der
Compiler, die passenden Datentypen zu ermitteln, um pr√ºfen zu
k√∂nnen, ob ihm f√ºr diese Datentypen eine Instanzdeklaration
bekannt ist.  Wir wollen hier nat√ºrlich auf die Instanz <code>Stream String Char</code> hinaus.  Ein Blick in obige Fehlermeldung verr√§t,
dass die Typinferenz bei <code>Stream String t</code> h√§ngen bleibt.
Der Compiler ist offenbar nicht in der Lage, f√ºr den Typparameter
<code>t</code> zu inferieren, dass es sich um den Datentyp <code>Char</code> handeln muss.
Ich wei√ü nicht, wo genau es klemmt, aber es stimmt, dass wir bei der
Definition unserer neuen <code>tail</code> Funktion dem Compiler nirgendwo einen
Hinweis darauf geben, dass es sich bei <code>t</code> um <code>Char</code> handeln muss.</p><p>Wenn wir das polymorphe <code>uncons</code> durch <code>String.uncons</code> ersetzen,
ist der Compiler zufrieden, aber dann k√∂nnen wir uns die Typklasse
gleich sparen.  Wenn wir <code>uncons</code> um eine Typannotation erg√§nzen,
die ausdr√ºcklich auf <code>Char</code> hinweist, ist der Compiler ebenfalls
zufrieden:</p><pre><code>-- Purescript
tail :: String -&gt; Maybe String
tail stream = do
    let f :: String -&gt; Maybe { head :: Char , tail :: _ }
        f = uncons
    map _.tail ( f stream )
</code></pre>
<p>Aber sch√∂n oder sinnvoll ist das auch nicht.  Welchen Wert hat
die Typklassenpolymorphie, wenn wir sie erst einf√ºhren und sie
dann zur H√§lfte wieder zur√ºcknehmen?</p><p>Interessanterweise k√∂nnen wir den Compiler auch zufriedenstellen,
indem wir die Definition der Typklasse <code>Stream</code> wie folgt anpassen:</p><pre><code>-- Purescript
class Stream stream element | stream -&gt; element where
    uncons :: stream -&gt; Maybe { head :: element , tail :: stream }
</code></pre>
<p>Hinzugekommen ist der Teil <code>| stream -&gt; element</code> vor dem <code>where</code>
Schl√ºsselwort.  Man nennt das eine <em>funktionale Abh√§ngigkeit</em>.
Wir vereinbaren dadurch mit dem Compiler, dass sich aus dem Datentyp
f√ºr den Typparameter <code>stream</code> stets eindeutig ergeben muss,
welcher Datentyp f√ºr den Typparameter <code>element</code> einzusetzen ist.
Das hat bei mir zun√§chst f√ºr Kopfkratzen gesorgt.  Dann ist mir
aufgefallen, dass wir nur eine einzige Instanzdeklaration der Form
<code>Stream String ...</code> angegeben haben, n√§mlich <code>Stream String Char</code>.
Damit ist die funktionale Abh√§ngigkeit stets erf√ºllt wenn wir f√ºr
<code>stream</code> den Datentyp <code>String</code> einsetzen: f√ºr <code>element</code> kommt dann
nur der Datentyp <code>Char</code> in Frage.  Die andere Instanzdeklaration
<code>Stream ( Array a ) a</code> erf√ºllt ebenfalls die Forderung nach
funktionaler Abh√§ngigkeit, denn wenn <code>Array a</code> (und damit <code>stream</code>)
auf einen konkreten Datentyp festgelegt ist, dann ist auch <code>a</code>
selbst (und damit <code>element</code>) eindeutig auf einen Datentyp festgelegt.
Der Compiler ist damit zufriedengestellt solange wir keine weiteren
Instanzdeklarationen hinzuf√ºgen, die diese Eindeutigkeit verletzen.</p><h2 id="verallgemeinerte-algebraische-datentypen-gadts">Verallgemeinerte algebraische Datentypen (GADTs)</h2>
<p>Weiter oben haben wir schon eine Verallgemeinerung der einfachen ADTs
kenngenlernt: die parametrischen ADTs.  Verallgemeinerung bedeutet,
dass das Verallgemeinerte zum Spezialfall des Verallgemeinernden
wird.  Bei den parametrischen ADTs besteht der Spezialfall
eines einfachen, parameterlosen ADT darin, dass die Anzahl seiner
Typparameter 0 ist: jeder parameterlose ADT ist ein parametrischer
ADT mit 0 Typparametern!</p><p>Die Sprache wird bei solchen Dingen oft etwas ungenau.  Wenn wir
von einem parametrischen ADT sprechen, meinen wir nat√ºrlich
einen ADT mit mindestens einem Typparameter, sonst m√ºssten wir
den allgemeineren Begriff nicht bem√ºhen.  Aber wenn jemand √ºber
einen ADT sagt: <em>‚Äúdas ist kein parametrischer sondern ein einfacher
ADT‚Äù</em>, dann ist das genaugenommen ein Widerspruch und damit falsch.
Im Gespr√§ch sollte man das nicht zum Anlass nehmen, gleich mit dem
Belehrfinger zu fuchteln, aber man sollte im Hinterkopf behalten,
dass genaugenommen der konkretere Begriff in dem allgemeineren
Begriff enthalten ist.</p><p>GADTs (<em>generalized algebraic data types</em>) sind wiederum eine
Verallgemeinerung der parametrischen ADTs.  Also ist jeder
parameterlose und jeder parametrische ADT stets auch ein GADT.
Aber auch √ºber ADTs und GADTs wird h√§ufig so gesprochen als
seien es disjunkte Konzepte.  Zum Beispiel enth√§lt der englische
Wikipedia-Artikel √ºber GADTs in seiner aktuellen Form (2023-06)
den folgenden Code-Kommentar:</p><pre><code>-- A parametric ADT that is not a GADT
</code></pre>
<p>Im Haskell-Wiki und in der GHC-Dokumentation gibt es √§hnliche
Formulierungen.  Das ist nicht schlimm, aber auch hier sollten
wir im Hinterkopf behalten, dass formal der konkretere Begriff im
allgemeineren Begriff enthalten ist.</p><p><strong>Neue Syntax</strong></p><p>GADTs bringen in Haskell neben der Verallgemeinerung auch eine
eigene Syntax mit.  Ich m√∂chte zun√§chst herk√∂mmliche ADTs in
dieser GADT-Syntax aufschreiben.  Dann schauen wir uns an, worin
genau die Verallgemeinerung besteht.  Hier noch mal <code>Bool</code> in der
herk√∂mmlichen ADT-Syntax:</p><pre><code>-- Haskell
data Bool
    = False
    | True
</code></pre>
<p>So w√ºrde man <code>Bool</code> in der GADT-Syntax schreiben:</p><pre><code>-- Haskell
data Bool where
    False :: Bool
    True :: Bool
</code></pre>
<p>Der <code>Ampel</code> Datentyp in herk√∂mmlicher ADT-Syntax:</p><pre><code>-- Haskell
data Ampel
    = Gr√ºn
    | Gelb
    | Rot
</code></pre>
<p>Der <code>Ampel</code> Datentyp in GADT-Syntax:</p><pre><code>-- Ampel in GADT-Syntax
data Ampel where
    Gr√ºn :: Ampel
    Gelb :: Ampel
    Rot :: Ampel
</code></pre>
<p>Herk√∂mmliche ADTs in GADT-Syntax aufzuschreiben, ist kein
Gedankenexperiment: die Beispiele sind g√ºltiger Haskell Code und
k√∂nnen genau so verwendet werden.  Bei der GADT-Syntax f√§llt gleich
auf, dass die Wertekonstruktoren mit Typannotationen versehen sind.
Bei parameterlosen ADTs in GADT-Syntax sind diese Typannotationen
√ºberfl√ºssig: selbstverst√§ndlich haben hier alle Wertekonstruktoren
den selben Datentyp.  Schauen wir uns als n√§chstes ein paar echte
parametrische ADTs in GADT-Syntax an.  Hier noch mal <code>Maybe a</code>
in der herk√∂mmlichen Syntax:</p><pre><code>-- Haskell
data Maybe a
    = Nothing
    | Just a
</code></pre>
<p>Zum Vergleich, <code>Maybe a</code> in GADT-Syntax:</p><pre><code>-- Haskell
data Maybe a where
    Nothing :: Maybe a
    Just :: a -&gt; Maybe a
</code></pre>
<p>Der Wertekonstrukor <code>Just</code> ist interessant.  Er hat den Datentyp
<code>a -&gt; Maybe a</code>.  Das ist immer der Fall, auch wenn wir den Datentyp
in der herk√∂mmlichen ADT-Syntax aufschreiben, aber hier schreiben
wir den Datentyp explizit hin.  Hier noch mal der Datentyp <code>List</code>,
diesmal in Haskell:</p><pre><code>-- Haskell
List a
    = Nil
    | Cons a ( List a )
</code></pre>
<p>In GADT-Syntax:</p><pre><code>-- Haskell
List a where
    Nil :: List a
    Cons :: a -&gt; List a -&gt; List a
</code></pre>
<p>Die neue Syntax f√ºr GADTs ist ein Wink mit dem Zaunspfahl bzgl. der
Verallgemeinerung, um die es geht.  Bei einem herk√∂mmlichen
parametrischen ADT kann jeder Typparameter stets nur f√ºr alle
Wertekontruktoren gemeinsam auf einen Datentyp festgelegt werden.
Bei einem GADT kann jeder  Typparameter f√ºr verschiedene
Wertekonstruktoren auf verschiedene Datentypen festgelegt werden.
Hier ein GADT mit drei Wertekonstruktoren:</p><pre><code>-- Haskell
data MyGadt a where
    MyInt :: Int -&gt; MyGadt Int
    MyBool :: Bool -&gt; MyGadt Bool
    MyString :: String -&gt; MyGadt String
</code></pre>
<p>Das besondere an einem GADT wie diesem ist, dass die
Wertekonstruktoren den Datentyp jeweils unterschiedlich
konkretisieren: der Wertekonstruktor <code>MyInt</code> erzeugt immer
einen <code>MyGadt Int</code>, der Wertekonstruktor <code>MyBool</code> erzeugt
immer einen <code>MyGadt Bool</code> und der Wertekonstruktor <code>MyString</code>
erzeugt immer einen <code>MyGadt String</code>.  Aber <code>MyGadt</code> hat nur diese
drei Wertekonstruktoren.  Daraus ergibt sich ein entscheidender
Sachverhalt: der Typparameter <code>a</code> kann hier konstruktionsbedingt
nur die Datentypen <code>Int</code>, <code>Bool</code> oder <code>MyString</code> annehmen.</p><p>Bei einem GADT k√∂nnen wir die Typparameter durch seine
Wertekonstruktoren so einschr√§nken, dass konstruktionsbedingt
nur noch ganz bestimme Datentypen auf die Typparameter passen.
Mehr noch: wir k√∂nnen die Wertekonstruktoren so entwerfen, dass
sie Beziehungen zwischen den verschiedenen Konkretisierungen eines
generischen Datentyps beschreiben.  Es ist ein bisschen so als
w√ºrden wir mit einem GADT nicht nur einen Datentyp beschreiben,
sondern eine ganze Gruppe von Datentypen und ihre Beziehungen
zueinander.  Wer schon mal eine kleine formale Sprache entworfen
und in eine Reihe von Datentypen gegossen hat oder einen Parser
f√ºr eine formale Sprache geschrieben hat, m√ºsste hier hellh√∂rig
werden.  Tats√§chlich eignen sich GADTs sehr gut daf√ºr, DSLs oder
ganze Programmiersprachen zu beschreiben.  Grunds√§tzlich geht
das auch mit herk√∂mmlichen ADTs, aber mit GADTs lassen sich
solche Beschreibungen kompakter formulieren und mehr Invarianten
auf der Typebene festhalten.  Als Beispiel daf√ºr schauen wir uns
die kleine arithmetische Sprache an, die der Wikipedia-Artikel zu
GADTs enth√§lt:</p><pre><code>-- Haskell
data Expr a where
    EInt :: Int -&gt; Expr Int
    EBool :: Bool -&gt; Expr Bool
    EEqual :: Expr Int -&gt; Expr Int -&gt; Expr Bool
</code></pre>
<p>Der Wertekonsturktor <code>EInt</code> erzeugt immer einen <code>Expr Int</code> Wert.
Die Wertekonstruktoren <code>EBool</code> und <code>EEqual</code> erzeugen immer einen
<code>Expr Bool</code> Wert.  Deswegen kann der Typparameter <code>a</code> hier nur die
Typen <code>Int</code> und <code>Bool</code> annehmen.  Dazu geh√∂rt noch die <code>eval</code>
Funktion, die einen <code>Expr a</code> Ausdruck in einen Wert vom Typ <code>a</code>
√ºberf√ºhrt:</p><pre><code>-- Haskell
eval :: Expr a -&gt; a
eval expr = case expr of
    EInt n -&gt; n
    EBool b -&gt; b
    EEqual a b -&gt; eval a == eval b
</code></pre>
<p>Damit sollte das folgende Programm <code>False</code> ausgeben:</p><pre><code>-- Haskell
main = do
    let v1 = EInt 123
    let v2 = EInt 124
    let result = EEqual v1 v2
    putStrLn ( show ( eval result ) )
</code></pre>
<p>Eine Sache, die mich ein bisschen daran st√∂rt, ist dass wir
<code>EEqual</code> nicht auf <code>Expr Bool</code> Werte anwenden k√∂nnen.  Das ist
aber leicht behoben:</p><pre><code>-- Haskell

data Expr a where
    EInt :: Int -&gt; Expr Int
    EBool :: Bool -&gt; Expr Bool
    EEqual :: Eq a =&gt; Expr a -&gt; Expr a -&gt; Expr Bool

eval :: Expr a -&gt; a
eval expr = case expr of
    EInt n -&gt; n
    EBool b -&gt; b
    EEqual a b -&gt; eval a == eval b
</code></pre>
<p>Damit sollte auch das folgende Programm compilieren und <code>False</code>
ausgeben:</p><pre><code>-- Haskell
main = do
    let v1 = EBool False
    let v2 = EBool True
    let result = EEqual v1 v2
    putStrLn ( show ( eval result ) )
</code></pre>
<p>Wie w√ºrde man das ohne GADTs modellieren?  Keine Ahnung!  Aber wir
k√∂nnen uns anschauen, was √ºbrigbleibt, wenn wir <code>Expr</code> auf einen
parametrischen ADT reduzieren:</p><pre><code>-- Haskell
data Expr a
    = EInt Int
    | EBool Bool
    | EEqual ( Expr a ) ( Expr a )
</code></pre>
<p>Wenn wir den so angepassten Datentyp in der GADT-Syntax aufschreiben,
sehen wir besser, was sich ge√§ndert hat:</p><pre><code>-- Haskell
data Expr a where
    EInt :: Int -&gt; Expr a
    EBool :: Bool -&gt; Expr a
    EEqual :: Expr a -&gt; Expr a -&gt; Expr a
</code></pre>
<p>Der Datentyp ist so v√∂llig unbrauchbar.  Es gibt jetzt keine
Beziehung mehr zwischen dem Typparameter <code>a</code> und den Feldtypen von
<code>EInt</code> und <code>EBool</code>:</p><pre><code>-- Haskell

v1 :: Expr Int
v1 = EBool True

v2 :: Expr String
v2 = EInt 123
</code></pre>
<p>Der Wertekonstruktor <code>EEqual</code> ist so auch unbrauchbar.  Wenn <code>EEqual</code>
einen <code>Expr Bool</code> Wert erzeugen soll, muss er auch auf zwei <code>Expr Bool</code> Werten operieren.  Schauen wir uns trotzdem an, wie weit wir
bei der <code>eval</code> Funktion kommen:</p><pre><code>-- Haskell
eval :: Expr a -&gt; a
eval expr = case expr of
    EInt n -&gt; undefined
    EBool b -&gt; undefined
    EEqual e1 e2 -&gt; undefined
</code></pre>
<p>Was sollen wir z.B. f√ºr <code>EInt n</code> berechnen?  Der Wert <code>n</code> hat
hier den Datentyp <code>Int</code>, aber <code>eval</code> operiert auf einem <code>Expr a</code>
Wert und erzeugt einen <code>a</code> Wert.  Wir br√§uchten eine Funktion
<code>Int -&gt; a</code> f√ºr beliebige Datentypen <code>a</code>.  Das w√§re zwar rein
formal m√∂glich (also typisierbar) aber wie sollen wir f√ºr jeden
m√∂glichen Datentyp ad hoc und aus dem Nichts einen Wert herzaubern?
Die gleiche Frage stellt sich f√ºr <code>EBool b</code>.  Bei <code>EEqual e1 e2</code> ist
das Problem noch gravierender, weil wir nur dann zu einem <code>Bool</code> Wert
auswerten k√∂nnen, wenn <code>e1</code> und <code>e2</code> vom Datentyp <code>Expr Bool</code> sind.
Die ganze Konstruktion ist also v√∂llig unbrauchbar.</p><p>Wenn wir <code>Expr</code> in einen parameterlosen ADT umbauen, kommt z.B. das
heraus:</p><pre><code>-- Haskell
data Expr
    = EInt Int
    | EBool Bool
    | EEqual Expr Expr
</code></pre>
<p>Das erscheint mir auf den ersten Blick schon sinnvoller.  Schauen wir
uns an, wie <code>eval</code> aussehen k√∂nnte:</p><pre><code>-- Haskell
eval :: Expr -&gt; a
eval expr = case expr of
    EInt n -&gt; undefined
    EBool b -&gt; undefined
    EEqual e1 e2 -&gt; case ( e1 , e2 ) of
        ( EInt n1 , EInt n2 ) -&gt; undefined
        ( EBool b1 , EBool b2 ) -&gt; undefined
        _ -&gt; undefined
</code></pre>
<p>Das ist wieder eine Sackgasse.  Wir k√∂nnen <code>eval</code> zwar von <code>Expr -&gt; a</code> konkretisieren auf <code>Expr -&gt; Bool</code> oder auf <code>Expr -&gt; Int</code>,
aber das findet immer f√ºr die gesamte Funktion inklusive aller
Case-Zweige statt.  Wir k√∂nnen nicht in einem Case-Zweig nach
<code>Bool</code> und im n√§chsten nach <code>Int</code> auswerten.  √úberhaupt m√ºssen
wir ja nach <code>a</code> auswerten, auch wenn f√ºr <code>a</code> weder <code>Bool</code> noch
<code>Int</code> eingesetzt worden ist.  Wenn wir f√ºr <code>a</code> einen konketen
Wert einsetzen, wird die Sache einfacher.  F√ºr einige Anwendungen
gen√ºgt sicherlich eine Funktion <code>eval :: Expr -&gt; String</code>:</p><pre><code>-- Haskell
eval :: Expr -&gt; String
eval expr = case expr of
    EInt n -&gt; show n
    EBool b -&gt; show b
    EEqual e1 e2 -&gt; case ( e1 , e2 ) of
        ( EInt n1 , EInt n2 ) -&gt; show ( n1 == n2 )
        ( EBool b1 , EBool b2 ) -&gt; show ( b1 == b2 )
        _ -&gt; show False
</code></pre>
<p>Andernfalls sehe ich nicht, wie man hier ohne GADTs auskommen
k√∂nnte.  Ich hoffe, ich konnte demonstrieren, was man mit GADTs
anstellen kann.  F√ºr mich ist das Konzept noch relativ neu.</p><h2 id="epilog">Epilog</h2>
<p>Dieser Text ist f√ºr mich in erster Linie eine Art Selbsttest:
kann ich mein Verst√§ndnis der Konzepte, die ich hier vorstelle,
ausformulieren und aufschreiben, so dass ich hinterher damit
zufrieden bin, auch wenn ich den Text zwischenzeitlich f√ºr ein
paar Wochen beiseite gelegt habe?  Wenn nicht, werde ich weiter
daran arbeiten (sofern ich Zeit und Lust dazu habe).  Mein Bezug zu
diesem Thema ist ein praktischer.  Bisher bin ich noch nicht dazu
gekommen, mich ernsthaft mit B√ºchern √ºber Typentheorie zu befassen.
Insofern hoffe ich, dass sich hier kein Bl√∂dsinn eingeschlichen hat.
Das w√§re mir wirklich peinlich.  Wenn der Text noch jemandem au√üer
mir selbst nutzt, freut mich das umso mehr.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Negation in Haskell und Purescript</title>
        <author>
            <name>Aram√≠s Concepci√≥n Dur√°n</name>
        </author>
        <link href="https://nojs.de/negation-in-haskell-und-purescript/"/>
        <id>https://nojs.de/negation-in-haskell-und-purescript/</id>

        <updated>2023-02-17T12:40:00+01:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>Haskell fetzt!  Allerdings ist Haskell in seiner Nische (rein
funktionale ML-Sprachen) l√§ngst nicht mehr allein.  Die moderneren
Abk√∂mmlinge dieser Familie bringen hier und da interessante
Verbesserungen mit.  Ein sch√∂nes Beispiel daf√ºr ist die <code>not</code>
Funktion in Purescript.</p><h2 id="werte-negieren">Werte negieren</h2>
<p>In Haskell negiert <code>not</code> den Wert eines boolschen Ausdrucks:</p><pre><code>-- Haskell GHCi Session
‚Äã
&gt; not True
False
‚Äã
&gt; not False
True
</code></pre>
<p>In Purescript gilt das gleiche:</p><pre><code>-- Purescript PSCi Session
‚Äã
&gt; not true
false
‚Äã
&gt; not false
true
</code></pre>
<p>Das ist nicht weiter kompliziert.</p><h2 id="funktionen-negieren">Funktionen negieren</h2>
<p>Grunds√§tzlich m√ºssten sich auf die gleiche Weise auch Funktionen
negieren lassen, die nach <code>Bool</code> abbilden.  F√ºr eine Funktion <code>f :: a -&gt; Bool</code> w√§re <code>not f</code> dann ebenfalls eine Funktion <code>a -&gt; Bool</code>,
so dass <code>( not f ) x</code> ‚Ä¶</p><ul>
<li>zu <code>True</code> auswertet wenn <code>f x</code> zu <code>False</code> auswertet, bzw.</li>
<li>zu <code>False</code> auswertet wenn <code>f x</code> zu <code>True</code> auswertet.</li>
</ul>
<p>Haskells <code>not</code> kann das nicht leisten.  Um das zu demonstrieren,
definieren wir eine <code>even</code> Funktion, die entscheidet, ob eine ganze
Zahl gerade ist:</p><pre><code>-- Haskell GHCi Session
‚Äã
&gt; even n = modBy 2 n == 0

&gt; even 0
True
‚Äã
&gt; even 1
False
‚Äã
&gt; even 2
True
‚Äã
&gt; even 3
False
</code></pre>
<p><em>Anmerkung:</em> Mein Haskell ist nicht ganz idiomatisch.  <code>modBy</code> ist
<a href="https://git.sr.ht/~aramis/ulme/tree/0ee5e975/item/src/Ulme.hs#L387">selbstdefiniert</a>.</p><p>Wir m√ºssten also eine <code>odd</code> Funktion definieren k√∂nnen, die
entscheidet, ob eine ganze Zahl ungerade ist, indem wir <code>even</code> mit
<code>not</code> negieren.  Wenn wir versuchen, das in Haskell umzusetzen,
scheitern wir:</p><pre><code>-- Haskell GHCi Session
‚Äã
&gt; odd = not even
&lt;interactive&gt;: error:
    ‚Ä¢ Couldn&#39;t match expected type ‚ÄòBool‚Äô with actual type ‚Äòa0 -&gt; Bool‚Äô
    ‚Ä¢ ...
</code></pre>
<p>In Purescript ist das gar kein Problem.  Hier ist die <code>even</code>
Funktion in Purescript:</p><pre><code>-- Purescript PSCi Session
‚Äã
&gt; even n = mod n 2 == 0
‚Äã
&gt; even 0
true
‚Äã
&gt; even 1
false
‚Äã
&gt; even 2
true
‚Äã
&gt; even 3
false
</code></pre>
<p>Wenn wir <code>even</code> mit <code>not</code> negieren, erhalten wir ohne Probleme unsere
<code>odd</code> Funktion:</p><pre><code>-- Purescript GHCi Session
‚Äã
&gt; odd = not even
‚Äã
&gt; odd 0
false
‚Äã
&gt; odd 1
true
‚Äã
&gt; odd 2
false
‚Äã
&gt; odd 3
true
</code></pre>
<h2 id="wie-ist-das-umgesetzt">Wie ist das umgesetzt?</h2>
<p>In Haskell ist <code>not</code> eine Funktion <code>Bool -&gt; Bool</code>.
In Purescript ist <code>not</code> eine Funktion <code>HeytingAlgebra a =&gt; a -&gt; a</code>.  Die Heyting-Algebra ist offenbar eine
Verallgemeinerung der booleschen Algebra.  Auf den <a href="https://github.com/purescript/purescript-prelude/blob/v6.0.1/src/Data/HeytingAlgebra.purs#L78">ersten
Blick</a>
spricht nichts dagegen, <code>not</code> auf die gleiche Weise auch
in Haskell zu verallgemeinern.  Vielleicht nehme ich
das mal in Angriff und versuche <code>not</code> in meinem <a href="https://git.sr.ht/~aramis/ulme">DIY
Prelude</a> entsprechend anzupassen.</p><h2 id="bonus">Bonus</h2>
<p>Dann ist mir noch ein sch√∂nes Beispiel daf√ºr eingefallen, dass man
manchmal in der Lage ist, zu erkennen, zu welchem Wert ein Ausdruck
auswerten m√ºsste, obwohl der Compiler auf dem Schlauch steht:</p><pre><code>foldr (+) 0 ( repeat 0 )
</code></pre>
<p>Der Ausdruck terminiert weder in Haskell noch in Purescript, weil
<code>repeat</code> eine unendliche Sequenz erzeugt.  Anschaulich ist v√∂llig
klar, dass er zu <code>0</code> auswerten m√ºsste, denn wir summieren einfach
nur Nullen auf.  Formal l√§sst sich das auch leicht rechtfertigen:
wenn wir eine unendliche Summe √ºber einem Monoid bilden, wobei
alle Summanden das neutrale Element sind, dann ergibt die Summe
schon per Definition ebenfalls das neutrale Element.</p><p>Es gibt weitere Beispiele dieser Art.  Der folgende Ausdruck
terminiert auch nicht, m√ºsste aber zum leeren String <code>&quot;&quot;</code> auswerten.
Anschaulich ist das auch wieder v√∂llig klar.  Formal gilt das
gleiche wie oben.</p><pre><code>foldr (++) &quot;&quot; ( repeat &quot;&quot; )
</code></pre>
<p><em>Hinweis:</em> <code>(++)</code> ist hier ein Alias f√ºr <code>(&lt;&gt;)</code>.</p><p>Der folgende Ausdruck terminiert auch nicht, m√ºsste aber in Haskell
zur leeren Liste <code>[]</code> auswerten.</p><pre><code>foldr (++) [] ( repeat [] )
</code></pre>
<p>Spannend ist die Frage, wie man das umsetzen k√∂nnte. Alle Beispiele
haben die Form:</p><pre><code>foldr mappend mempty ( repeat mempty )
</code></pre>
<p>Wenn die Faltung in der Lage w√§re, diese Form zu erkennen, k√∂nnte
sie in diesem Fall zu <code>mempty</code> auswerten.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Closures</title>
        <author>
            <name>Aram√≠s Concepci√≥n Dur√°n</name>
        </author>
        <link href="https://nojs.de/closures/"/>
        <id>https://nojs.de/closures/</id>

        <updated>2023-01-18T12:39:00+01:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>Ich spiele gerade ein bisschen mit Go herum, weil ich mich
aus meiner funktionalen Ecke heraustrauen und etwas mehr mit
imperativen, C-artigen Sprachen befassen m√∂chte.  Rust h√§tte
mich auch interessiert, scheint aber ein Fass ohne Boden zu sein.
Go ist modern, trotzdem stabil, recht kompakt und weitverbreitet.
Die Liste der gro√üen und popul√§ren Softwareprojekte, die auf Go
setzen, ist beachtlich.</p><p>In der <a href="https://go.dev/tour/">Go-Tour</a> gibt es einen Abschnitt zu
Closures.  Ich nutze die Gelegenheit, um f√ºr mich zu kl√§ren was
Closures sind.  Ich hab den Begriff bisher nie wirklich verstanden.</p><p>Eine Closure (i.e. ein Funktionsabschluss) ist eine Funkion, die
Referenzen auf ihren Erstellungskontext enth√§lt, wobei dieser
Kontext au√üerhalb der Funktion nicht mehr sichtbar und nicht mehr
referenzierbar ist.</p><p>Ein Beisiel aus dem Haskell Wiki:</p><pre><code>&gt; f x = \ y -&gt; x + y
&gt; g = f 3
&gt; g 4
7
</code></pre>
<p>Wenn wir <code>g</code> definieren, wird der Wert <code>3</code> an den Parameter <code>x</code>
gebunden, so dass <code>g = \ y -&gt; 3 + y</code> gilt.  Auf den Kontext, in dem
die Bindung <code>x = 3</code> vorliegt, k√∂nnen wir aber nicht mehr zugreifen,
obwohl er weiter existiert solange <code>g</code> existiert.  Eine Closure liegt
vor weil die Bindung <code>x = 3</code> im Kontext des Lambda-Ausdrucks erfolgt
aber innerhalb des Lambda-Ausdrucks verwendet wird.  Dadurch lebt
der Kontext √ºber die Definition hinaus weiter, weil er f√ºr die
Auswertung ben√∂tigt wird.</p><p>Ich verstehe das, aber was ich nicht verstehe ist, warum man dieser
Sache einen gesonderten Namen gibt und sie als eine spezielle
Programmiertechnik behandelt.  Statt <code>f x = \ y -&gt; x + y</code> k√∂nnte
man auch schreiben: <code>f x y = x + y</code>.  Das ist die normalste Sache der
Welt und ich verstehe √ºberhaupt nicht, wie es anders sein k√∂nnte,
also was es bedeuten soll, ohne Closures zu programmieren.</p><p>Beim Schreiben kommt mir der Verdacht, dass es irgendwie damit
zusammenh√§ngen muss, dass Sprachen wie C keine First Class Functions
haben.  Wenn man es nicht gewohnt ist, kann das Herumreichen von
Funktionen als Argumente und R√ºckgabewerte mit allen M√∂glichkeiten,
die sich daraus ergeben, vielleicht wie ein besonderer Hokuspokus
erscheinen, der erst mal in einen Begriff zu bringen ist: Closure
‚Äî eine Funktion, die auf freien Variablen operiert.</p><p>Das Gegenteil w√§re ein Combinator ‚Äî eine Funktion ohne freie
Variable.</p><p><strong>Update</strong></p><p>Ok, ich hab‚Äôs!  Der eigentliche Effekt, an dem man offenbar bei der
imperativen Programmierung mit Closures interessiert ist, tritt bei
der rein funktionalen Programmierung gar nicht auf.  Eine Closure
ist in diesem Fall eine Prozedur mit einem inneren Zustand, der
√ºber mehrere Aufrufe hinweg fortbesteht und ver√§nderbar ist.
Hier ein angepasstes Beispiel aus der Go Tour:</p><pre><code>func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}
func main() {
    f := adder()
    fmt.Println(f(0)) // 0
    fmt.Println(f(1)) // 1
    fmt.Println(f(2)) // 3
    fmt.Println(f(3)) // 6
    fmt.Println(f(4)) // 10
    fmt.Println(f(5)) // 15
}
</code></pre>
<p>Was passiert hier?  Die Prozedur <code>f</code> hat einen inneren Zustand,
der mit <code>sum := 0</code> initialisiert wird, bei jedem Aufruf von
<code>f</code> ver√§ndert wird und nur indirekt √ºber den R√ºckgabewert
observierbar ist.  Daraus k√∂nnte man ein Objektsystem stricken.</p><p>Nicht alle imperativen Sprachen unterst√ºtzen Closures.  Wenn sie
es nicht tun, wird <code>f</code> im obigen Beispiel zur Identit√§tsfunktion,
weil <code>f(n)</code> stets zu <code>0 + n</code> auswertet.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Trial beim MC Post Leipzig</title>
        <author>
            <name>Aram√≠s Concepci√≥n Dur√°n</name>
        </author>
        <link href="https://nojs.de/trial-beim-mc-post-leipzig/"/>
        <id>https://nojs.de/trial-beim-mc-post-leipzig/</id>

        <updated>2022-12-02T09:41:00+01:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p><a href="../tschuessi-mc-post/index.html">Es gibt dazu ein Update 2025.</a></p><p>In meiner Jugend bin ich wettkampforientiert Fahrrad-Trial gefahren.
Einige Jahre lang war dieser Sport gewisserma√üen meine Raison
d‚Äô√™tre.  Dann hat f√ºr mich das echte Leben begonnen: Abitur,
Studium, Freundin, WG-Leben und eine chaotische Suche nach meinem
Platz in dieser Welt.  Jetzt ist es vielleicht achtzehn Jahre oder
l√§nger her, dass ich den Trial-Sport aufgegeben habe.  Irgendwie
war damals die Luft raus.  Aber in den darauffolgenden Jahren habe
ich etwas so k√∂rperlich intensives und viszeral sinnstiftendes
wirklich sehr sehr vermisst in meinem Leben.  Trial hat mir damals
das gegeben, was Hartmut Rosa eine diagonale Resonanzbeziehung nennt.</p><p>Jetzt bin ich 38 Jahre alt und √ºbergewichtig.  Ich muss dringend
mehr Sport machen, um meine zweite Lebensh√§lfte gesund √ºber die
B√ºhne zu bringen.  Noch geht es mir gut, aber ich bef√ºrchte,
dass ich in zehn Jahren endg√ºltig ein dicker Stubenhocker sein
werde, f√ºr den die sportlichen Highlights des Tages die Wege zum
K√ºhlschrank, zum Briefkasten und zum Auto sind.  Die Eitelkeit
als Triebfeder f√ºr die k√∂rperliche Fitness tritt f√ºr mich mit
zunehmendem Alter in den Hintergrund.  Sie wird abgel√∂st von der
Sorge um mein k√∂rperliches und geistiges Wohlbefinden.</p><p>Im Fr√ºhling kam mir die Idee, Trial wieder auszuprobieren um
herauszufinden ob es wieder Spa√ü macht und wieviel davon mein
K√∂rper noch erinnert.  Ja, es macht einen Heidenspa√ü und zu meinem
gro√üen Erstaunen kann ich es noch.</p><figure class="post__image"><img loading="lazy" src="../media/files/c005300e15073ea140da81b2043d686b6a09ae30.jpg" alt=""  data-is-external-image="true"></figure><p>Die Bilder sind auf dem Trainingsgel√§nde des MC Post Leipzig
e.V. entstanden.  Ich bin dort seit ein paar Wochen Mitglied und
nutze jede Gelegenheit f√ºr ein Training.  Nach f√ºnf Minuten atme
ich wie nach einem Sprint.  Nach einer Stunde bin ich nassgeschwitzt
und v√∂llig ersch√∂pft.</p><figure class="post__image"><img src="../media/files/488cd0881027d7617510e3a3f70d6a90253b6245.jpg" alt=""  data-is-external-image="true"></figure><figure class="post__image"><img loading="lazy" src="../media/files/72b2606db197c396d0eadcdc12e9b47c42749806.jpg" alt=""  data-is-external-image="true"></figure><p>Der Fotograf, der diese Aufnahmen geschossen hat, ist
Jan Zwicker.  Jan stand am Samstag fr√ºh um zehn (f√ºr einen
anderen Anlass) mit seiner professionellen Fotoausr√ºstung auf
dem Gel√§nde und hat gefragt, ob er ein paar Fotos machen darf.<br><a href="https://wheels-and-vibes.com/">https://wheels-and-vibes.com/</a></p><figure class="post__image"><img src="../media/files/e42a753ae8d6da3d8b37dc2724040e347cdd736f.jpg" alt=""  data-is-external-image="true"></figure><figure class="post__image"><img loading="lazy" src="../media/files/4aab49c3a0f4becf4c507b56ca97d0a2b00a0e59.jpg" alt=""  data-is-external-image="true"></figure><p>Ich wiege 25 kg mehr als damals.  Das macht sich bemerkbar.  Aber die
grunds√§tzlichen Bewegungsabl√§ufe und das Gef√ºhl f√ºr das Fahrrad
sind noch da.  Es scheint zu stimmen: Fahrradfahren verlernt man
nicht.  Jetzt ist die gro√üe Frage, wie es f√ºr mich weitergeht.
Bleibe ich beim Midlife-Cycling? Wird das dazu beitragen, dass ich
wieder fit werde und mein √úbergewicht loswerde? Oder mache ich
mir damit auf Dauer nur die Knochen kaputt?</p><figure class="post__image"><img src="../media/files/fac72a0dc6ac5f5932c4bcc3f489c9314bcd544f.jpg" alt=""  data-is-external-image="true"></figure><figure class="post__image"><img loading="lazy" src="../media/files/a1c8e9816952ec9439a2706480216fc5e9bb8e71.jpg" alt=""  data-is-external-image="true"></figure><p>Das Trainingsgel√§nde des MC Post Leipzig ist das einzige seiner Art
mitten in einer deutschen Gro√üstadt.  Es ist keinen ganzen Kilometer
von meiner Wohnung entfernt und ich frage mich, warum ich nicht schon
eher auf die Idee gekommen bin, dort mitzumachen.  Im Moment bin ich
der einzige Fahrrad-Trialer im Verein.  Die anderen fahren Motorrad.</p><p><del>Wenn du auch Fahrrad-Trial f√§hrst und in der N√§he lebst, mach
bei uns mit.  Es lohnt sich.</del></p><p><del><a href="https://mcpostleipzig.de/">https://mcpostleipzig.de/</a></del></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Nix Expression Language</title>
        <author>
            <name>Aram√≠s Concepci√≥n Dur√°n</name>
        </author>
        <link href="https://nojs.de/nix-expression-language/"/>
        <id>https://nojs.de/nix-expression-language/</id>

        <updated>2022-12-01T09:38:00+01:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>Ich erkunde die Nix Expression Language.  Mein Startpunkt ist
<a href="https://learnxinyminutes.com/docs/nix/">https://learnxinyminutes.com/docs/nix/</a>.  Sehr hilfreich ist auch
die Dokumentation, welche √ºber die Nix Repl verf√ºgbar ist.</p><h2 id="auswertung">Auswertung</h2>
<p>Die auszuwertenden Ausdr√ºcke schreibe ich in eine Datei
<code>scratch.nix</code>.  Die Auswertung erfolgt so:</p><pre><code>$ nix-instantiate --eval scratch.nix
</code></pre>
<p>F√ºr mehr Komfort kann man <code>inotifywait</code> benutzen um die Auswertung
jedesmal anzusto√üen wenn die Datei <code>scratch.nix</code> gespeichert wird:</p><pre><code>$ while true
    inotifywait -q -e modify scratch.nix
    clear
    nix-instantiate --eval scratch.nix
    and echo &quot;.&quot;
  end
</code></pre>
<p>Das ist eine Kommandozeile f√ºr die <code>fish</code> Shell.  In <code>sh</code> usw. muss
man das ein bisschen anders schreiben.  Die <code>fish</code> Shell ist sehr
komfortabel: man kann das einfach so mehrzeilig aufschreiben;
die Shell wei√ü, wann die Eingabetaste die Zeile umbrechen soll
und wann sie die Auswertung ansto√üen soll.</p><p>Kurze Ausdr√ºcke kann man auch direkt in der Nix Repl ausprobieren:</p><pre><code>$ nix repl
Welcome to Nix 2.10.3. Type :? for help.

nix-repl&gt; &quot;Das ist eine Zeichenkette&quot;
&quot;Das ist eine Zeichenkette&quot;

nix-repl&gt; 7 * 11 * 13
1001
</code></pre>
<p>Update: Am Ende habe ich die Methode mit der Scratch-Datei kaum
verwendet und mich stattdessen fast ausschlie√ülich auf die Nix
Repl verlassen.  Die Nix Repl bietet integrierte Dokumentation und
kann auch mit mehrzeiligen Eingaben gut umgehen.</p><h2 id="einfache-sprachbestandteile">Einfache Sprachbestandteile</h2>
<p>Im Schnelldurchlauf.</p><h3 id="kommentare">Kommentare</h3>
<pre><code># Einzeilige Kommentare (wie in Python).

/*
    Mehrzeilige Kommentare (wie in C++).

    Python-Einzeiler und C++-Mehrzeiler sind schon mal eine
    seltsame Kombination.  Wir haben noch nicht richtig begonnen
    und der Merkw√ºrdigkeitsfaktor ist schon gr√∂√üer 1.
*/
</code></pre>
<h3 id="booleans">Booleans</h3>
<pre><code>nix-repl&gt; true &amp;&amp; false
false

nix-repl&gt; true || false
true
</code></pre>
<h3 id="verzweigung">Verzweigung</h3>
<pre><code>nix-repl&gt; if 3 &lt; 4 then &quot;a&quot; else &quot;b&quot;
&quot;a&quot;
</code></pre>
<h3 id="zahlen">Zahlen</h3>
<p>Es scheint Integers und Floats zu geben.  Man kann sie beim Rechnen
mit einander kombinieren.  Die arithmetischen Operatoren sind
polymorph.  Der Interpreter scheint selbst√§ndig nach gewissen Regeln
zu enscheiden, wann das Ergebnis Integer und wann es Float ist.
Daraus ergeben sich die √ºblichen Fallstricke:</p><pre><code>nix-repl&gt; 7.0 / 2
3.5

nix-repl&gt; 7 / 2
3
</code></pre>
<p>F√ºr den Einsatzzweck der Nix Expression Language ist das bestimmt
kein Problem.</p><h3 id="strings">Strings</h3>
<pre><code>nix-repl&gt; &quot;Das ist ein String&quot;
&quot;Das ist ein String&quot;
</code></pre>
<p>Strings k√∂nnen mehrzeilig sein:</p><pre><code>nix-repl&gt; &quot;asdf
...       asdf
...       asdf&quot;
&quot;asdf\nasdf\nasdf&quot;
</code></pre>
<p>Die sogenannten Indented Strings sind ebenfalls mehrzeilig.
Bei ihnen wird die Einr√ºckung nicht mit ausgewertet.  Das ist
die k√ºrzeste Folge von f√ºhrenden Leerzeichen, in der alle nicht
leeren Zeilen des Strings √ºbereinstimmen.  Ob und wie dabei Tabs
ber√ºcksichtigt werden, habe ich nicht ausprobiert.  Hier werden
in jeder Zeile die vier f√ºhrenden Leerzeichen entfernt:</p><pre><code>nix-repl&gt; &#39;&#39;    asdf
...           asdf
...           asdf&#39;&#39;
&quot;asdf\nasdf\nasdf&quot;
</code></pre>
<p>Mit leeren Zeilen sind hier auch Zeilen gemeint, die nur aus
Leerraum bestehen.  Leerzeilen am Rand des Strings werden verworfen.</p><p>Verkettung von Strings mit <code>+</code>:</p><pre><code>nix-repl&gt; &quot;ab&quot; + &quot;cd&quot;
&quot;abcd&quot;
</code></pre>
<p>Auswertung in Strings:</p><pre><code>nix-repl&gt; &quot;Home is ${builtins.getEnv &quot;HOME&quot;}.&quot;
&quot;Home is /home/aramis.&quot;
</code></pre>
<p>Der Name <code>builtins</code> verweist auf eine Standardbibliothek (genauer:
ein Set) von Funktionen und Prozeduren.  Das <code>builtins</code> Set ist
immer verf√ºgbar wenn der Nix Interpreter startet.  Die Prozedur
<code>builtins.getEnv</code> liefert den Wert von Umgebungsvariablen.</p><pre><code>nix-repl&gt; builtins.getEnv &quot;HOME&quot;
&quot;/home/aramis&quot;
</code></pre>
<h3 id="pfade">Pfade</h3>
<p>F√ºr Pfade gibt es einen eigenen Basisdatentyp.  Man notiert Pfade
einfach so wie man sie auch sonst notieren w√ºrde:</p><pre><code>nix-repl&gt; /home/aramis
/home/aramis
</code></pre>
<p>Das hat aber Einschr√§nkungen.  Zum Beispiel sind abschlie√üende
Schr√§gstriche aus irgendwelchen Gr√ºnden nicht gestattet:</p><pre><code>nix-repl&gt; /home/aramis/
error: path has a trailing slash

nix-repl&gt; /home/aramis/.
/home/aramis
</code></pre>
<p>Pfade ganz ohne Schr√§gstriche wie z.B. <code>.</code> werden auch nicht
erkannt:</p><pre><code>nix-repl&gt; .
error: syntax error, unexpected &#39;.&#39;

nix-repl&gt; ./
error: path has a trailing slash

nix-repl&gt; ./.
/home/aramis
</code></pre>
<p>Relative Pfade werden in absolute Pfade aufgel√∂st relativ zu dem
Verzeichnis, in welchem sich die Datei befindet, die ausgewertet
wird:</p><pre><code>nix-repl&gt; ./.
/home/aramis
</code></pre>
<p>Pfade werden kanonisiert:</p><pre><code>nix-repl&gt; /home/aramis/.
/home/aramis
</code></pre>
<p>Daraus, dass der Parser auch relative Pfade als Pfade erkennt,
ergibt sich, dass der Schr√§gstrich, wenn er als Divisionszeichen
gelesen werden soll, von Leerraum umgeben sein muss</p><pre><code>nix-repl&gt; 0/0
/home/aramis/0/0

nix-repl&gt; 0 / 0
error: division by zero
</code></pre>
<h3 id="imports">Imports</h3>
<p>Jedes Nix Skript enth√§lt genau einen Top-Level-Ausdruck ohne freie
Variable, der also vollst√§ndig ausgewertet werden kann.  Wenn ein
Skript importiert wird, entspricht der Wert des Import-Ausdrucks
dem Wert des importierten Skripts:</p><pre><code>$ echo &quot;1 + 2&quot; &gt; foo.nix
$ nix repl
Welcome to Nix 2.10.3. Type :? for help.

nix-repl&gt; import ./foo.nix
3
</code></pre>
<p>Das <code>import</code> Schl√ºsselwort kann auch Strings verarbeiten:</p><pre><code>nix-repl&gt; import &quot;/home/aramis/foo.nix&quot;
3
</code></pre>
<p>Aber das scheint nur zu funktionieren wenn der String einen absoluten
Pfad enth√§lt:</p><pre><code>nix-repl&gt; import &quot;foo.nix&quot;
error: string &#39;foo.nix&#39; doesn&#39;t represent an absolute path

nix-repl&gt; import &quot;./foo.nix&quot;
error: string &#39;./foo.nix&#39; doesn&#39;t represent an absolute path
</code></pre>
<h3 id="let-in-ausdr√ºcke">Let-In-Ausdr√ºcke</h3>
<p>Daf√ºr gibt es eine <code>let ... ; in ...</code> Syntax:</p><pre><code>nix-repl&gt; let x = &quot;a&quot; ; in x + x + x
&quot;aaa&quot;
</code></pre>
<p>Die Zuweisungen k√∂nnen sich auf einander beziehen, unabh√§ngig
von ihrer Reihenfolge:</p><pre><code>nix-repl&gt; let y = x + &quot;b&quot; ; x = &quot;a&quot; ; in y + &quot;c&quot;
&quot;abc&quot;
</code></pre>
<p>Innere Zuweisungen √ºberschatten weiter au√üen liegende Zuweisungen:</p><pre><code>nix-repl&gt; let a = 1 ; in let a = 2 ; in a
2
</code></pre>
<h3 id="funktionen">Funktionen</h3>
<p>Das ist erstaunlich rudiment√§r gel√∂st.  Nix kennt eigentlich nur
einfache Lambdas:</p><pre><code>nix-repl&gt; (n : n + 1) 5
6
</code></pre>
<p>Lambdas mit mehr als einem Parameter ergeben sich aus der Syntax
auf nat√ºrliche Weise:</p><pre><code>nix-repl&gt; (a : b : a + b) 5 6
11
</code></pre>
<p>Wenn man Namen f√ºr Funktionen vergeben m√∂chte, kann man auf die
<code>let ... ; in ...</code> Syntax zur√ºckgreifen:</p><pre><code>nix-repl&gt; let plus = (a : b : a + b ) ; in plus 5 6
11
</code></pre>
<h3 id="listen">Listen</h3>
<p>Listen sind von eckigen Klammern begrenzt.  Die Elemente sind durch
Lerraum getrennt.</p><pre><code>nix-repl&gt;[ 1 2 3 ]
[ 1 2 3 ]
</code></pre>
<p>Es gibt viele Built-Ins f√ºr Listen:</p><pre><code>nix-repl&gt; builtins.length [ 1 2 3 ]
3

nix-repl&gt; builtins.concatLists [ [ 1 2 3 ] [ 4 5 6 ] ]
[ 1 2 3 4 5 6 ]

nix-repl&gt; builtins.head [ 1 2 3 ]
1

nix-repl&gt; builtins.filter (n : n &lt; 3) [ 1 2 3 ]
[ 1 2 ]
</code></pre>
<h3 id="sets-mengen">Sets (Mengen)</h3>
<p>In Nix Sets hat jedes Element einen String als Schl√ºssel also
einen Namen.  Demnach sind Nix Sets keine blo√üen Mengen sondern
eher Records bzw. Maps.</p><pre><code>nix-repl&gt; { a = 1 ; b = 2 ; }.a
1

nix-repl&gt; let s = { a = 1 ; b = 2 ; } ; in s.a
1
</code></pre>
<p>Der <code>?</code> Operator pr√ºft die Existenz eines Schl√ºssels:</p><pre><code>nix-repl&gt; { a = 1 ; b = 2 ; } ? a
true
</code></pre>
<p>Der <code>//</code> Operator vereinigt zwei Sets:</p><pre><code>nix-repl&gt; { a = 1 ; } // { b = 2 ; }
{ a = 1; b = 2; }
</code></pre>
<p>Wenn dabei Schl√ºssel kollidieren, hat das rechte Set Vorrang:</p><pre><code>nix-repl&gt; { a = 1 ; } // { a = 2 ; }
{ a = 2; }
</code></pre>
<p>Mit dem <code>rec</code> Schl√ºsselwort k√∂nnen rekursive Sets deklariert
werden.  Darin k√∂nnen sich Werte auf andere Werte des selben
Sets beziehen:</p><pre><code>nix-repl&gt; rec { a = 1 ; b = a ; }
{ a = 1; b = 1; }

nix-repl&gt; rec { a = b ; b = a ; }
error: infinite recursion encountered
</code></pre>
<p>F√ºr verschachtelte Sets gibt es eine Kurznotation:</p><pre><code>nix-repl&gt; { a.b = 2 ; a.c = 3 ; }
{ a = { ... }; }
</code></pre>
<p>Das entspricht:</p><pre><code>nix-repl&gt; { a = { b = 2 ; c = 3 ; } ; }
{ a = { ... }; }
</code></pre>
<p>Man kann die Kurznotation mit der ausf√ºhrlicheren mischen:</p><pre><code>nix-repl&gt; { a = { b = 2 ; } ; a.c = 3 ; }
{ a = { ... }; }
</code></pre>
<p>Ich finde, das sieht widerspr√ºchlich aus.</p><h3 id="das-with-schl√ºsselwort">Das <code>with</code> Schl√ºsselwort</h3>
<p>Das <code>with</code> Schl√ºsselwort nimmt ein Set und einen Ausdruck.  In dem
Ausdruck gelten die Schl√ºssel-Wert-Paare des Sets als Bindungen:</p><pre><code>nix-repl&gt; with { a = 1 ; b = 2 ; } ; a + b
3
</code></pre>
<p>Das ist also wie die <code>let ... ; in ...</code> Syntax:</p><pre><code>nix-repl&gt; let a = 1 ; b = 2 ; in a + b
3
</code></pre>
<p>Der Unterschied ist, dass bei <code>with</code> die gesamte Menge von Bindungen
in einem (Set-)Ausdruck zusammengefasst ist.  Dadurch kann man sich
die Bindungen sozusagen als ein ganzes B√ºndel aus dem Kontext holen.
Man sieht das h√§ufig in Nix-Expressions bspw. um die Built-Ins
unqualifiziert verf√ºgbar zu machen:</p><pre><code>nix-repl builtins.length [ 1 2 3 ]
3

nix-repl&gt; with builtins ; length [ 1 2 3 ]
3
</code></pre>
<p>Das ist sinnvoll wenn man z.B. viele Built-Ins in einem Ausdruck
verwenden m√∂chte und sie nicht jedesmal mit <code>builtins.</code>
qualifizieren m√∂chte.</p><p>Ohne <code>with</code>:</p><pre><code>nix-repl&gt; [ ( builtins.length [ 1 2 3 ] )
...         ( builtins.head [ 1 2 3 ] )
...         ( builtins.elem 2 [ 1 2 3 ] )
...       ]
[ 3 1 true ]
</code></pre>
<p>Mit <code>with</code>:</p><pre><code>nix-repl&gt; with builtins ;
...       [ ( length [ 1 2 3 ] )
...         ( head [ 1 2 3 ] )
...         ( elem 2 [ 1 2 3 ] )
...       ]
[ 3 1 true ]
</code></pre>
<p>Wenn man also qualifiziert importieren m√∂chte, ganz grob ungef√§hr
so wie man es in Haskell machen w√ºrde, k√∂nnte das so aussehen:</p><pre><code>$ echo &quot;{ plus = a : b : a + b ; }&quot; &gt; foo.nix
$ nix repl
Welcome to Nix 2.10.3. Type :? for help.

nix-repl&gt; let foo = import ./foo.nix ; in with foo ; foo.plus 5 6
11
</code></pre>
<p>Das w√ºrde einem unqualifizierten Import entsprechen:</p><pre><code>nix-repl&gt; with import ./foo.nix ; plus 5 6
11
</code></pre>
<p>Anstatt wie oben den Import in einem Let-Ausdruck an den Namen <code>foo</code>
zu binden, kann man diesen Namen in der importierten Datei festlegen.
Dann spart man sich den Let-Ausdruck:</p><pre><code>$ echo &quot;{ foo = { plus = a : b : a + b ; } ; }&quot; &gt; foo.nix
$ nix repl
Welcome to Nix 2.10.3. Type :? for help.

nix-repl&gt; with import ./foo.nix ; foo.plus 5 6
11
</code></pre>
<p>Die Variante hat den gro√üen Nachteil, dass die Festlegung des
<em>Qualifiers</em> <code>foo</code> in der importierenden Datei nicht explizit ist.</p><p>Mit <code>with</code> l√§sst sich jeweils nur ein Set von Bindungen angeben
aber, √§hnlich wie bie den Lambdas, ergibt sich auch hier aus der
Syntax eine nat√ºrliche Erweiterung auf mehrere Sets:</p><pre><code>nix-repl&gt; with builtins ;
...       with { myList = [ 1 2 3 ] ; } ;
...       length myList
3
</code></pre>
<h3 id="set-patterns">Set Patterns</h3>
<p>Funktionen unterst√ºtzen per se keine benannten Parameter.
Lambdas k√∂nnen aber selbstverst√§ndlich auch auf Sets operieren:</p><pre><code>nix-repl&gt; (x : x.a + x.b) { a = 5 ; b = 6 ; }
11
</code></pre>
<p>Mit sogenannten Set Patterns kann man letztlich doch benannte
Funktionsparameter aufschreiben:</p><pre><code>nix-repl&gt; ({a,b} : a + b) { a = 5 ; b = 6 ; }
11
</code></pre>
<p>Dabei ist <code>{a,b}</code> ein sogenanntes Set Pattern.</p><p>Achtung: Wenn das Argument ein Set ist, welches zus√§tzliche
Werte enth√§lt, die im Set Pattern nicht angegeben sind, ist das
ein Fehler:</p><pre><code>nix-repl&gt; ({a,b} : a + b) { a = 5 ; b = 6 ; c = 7 ; }
error: anonymous function at (string):1:2 called with unexpected argument &#39;c&#39;
</code></pre>
<p>Man kann den Fall aber im Set Pattern durch Auslassungspunkte
ausdr√ºcklich zulassen:</p><pre><code>nix-repl&gt; ({a,b,...} : a + b) { a = 5 ; b = 6 ; c = 7 ; }
11
</code></pre>
<h3 id="fehler">Fehler</h3>
<p>Das <code>throw</code> Schl√ºsselwort bricht die Auswertung ab und gibt eine
Fehlermeldung aus:</p><pre><code>nix-repl&gt; 1 + 2 + throw &quot;drei&quot;
error: drei
</code></pre>
<p>Anscheinend werden Fehler innerhalb von Listen wie normale Elemente
behandelt.  Die Auswertung wird nicht abgebrochen:</p><pre><code>nix-repl&gt; [ 1 (throw &quot;zwei&quot;) 3 ]
[ 1 ¬´error: error: zwei¬ª 3 ]
</code></pre>
<p>Das gleiche Verhalten tritt innerhalb von Sets auf:</p><pre><code>nix-repl&gt; { eins = 1 ; zwei = throw &quot;zwei&quot; ; drei = 3 ; }
{ drei = 3; eins = 1; zwei = ¬´error: error: zwei¬ª; }
</code></pre>
<p>Neben <code>throw</code> gibt es auch noch das Schl√ºsselwort <code>abort</code>, welches
ebenfalls die Auswertung abbricht und eine Fehlermeldung ausgibt:</p><pre><code>nix-repl&gt; 1 + 2 + abort &quot;drei&quot;
error: evaluation aborted with the following error message: &#39;drei&#39;
</code></pre>
<p>Im Unterschied zu <code>throw</code> f√ºhrt <code>abort</code> auch innerhalb von Listen
und Sets zum Abbruch der Auswertung:</p><pre><code>nix-repl&gt; [ 1 (abort &quot;zwei&quot;) 3 ]
error: evaluation aborted with the following error message: &#39;zwei&#39;

nix-repl&gt; { eins = 1 ; zwei = abort &quot;zwei&quot; ; drei = 3 ; }
error: evaluation aborted with the following error message: &#39;zwei&#39;
</code></pre>
<p>Der Unterschied zwischen <code>throw</code> und <code>abort</code> ist n√ºtzlich.
In <code>nix-env -qa</code> und anderen Shell-Anweisungen, die Listen oder Sets
von Nix Derivationen verarbeiten, wird <code>throw</code> verwendet, sofern
bei einem Fehler in einer Derivation trotzdem alle nachfolgenden
Derivationen verarbeitet werden sollen.  Nat√ºrlich gibt es auch
F√§lle, in denen ein Fehler zum Abbruch der ganzen Auswertung
f√ºhren soll.  In solchen F√§llen verwendet man <code>abort</code>.</p><p>Mit <code>builtins.tryEval</code> k√∂nnen Fehler aufgefangen werden, die mit
<code>throw</code> ausgel√∂st worden sind:</p><pre><code>nix-repl&gt; builtins.tryEval (1 + 2 + 3)
{ success = true; value = 6; }

nix-repl&gt; builtins.tryEval (1 + 2 + throw &quot;drei&quot;)
{ success = false; value = false; }
</code></pre>
<p>Mit <code>abort</code> ausgel√∂ste Fehler kann <code>builtins.tryEval</code> nicht
auffangen:</p><pre><code>nix-repl&gt; builtins.tryEval (1 + 2 + abort &quot;drei&quot;)
error: evaluation aborted with the following error message: &#39;drei&#39;
</code></pre>
<p>Das <code>assert</code> Schl√ºsselwort erwartet zwei Ausdr√ºcke, getrennt
durch ein Semikolon:</p><pre><code>assert &lt;erster Ausdruck&gt; ; &lt;zweiter Ausdruck&gt;
</code></pre>
<p>Der erste Ausdruck muss boolsch sein.  Der zweite Ausdruck kann
beliebig sein.  Wenn der erste Ausdruck zu <code>true</code> auswertet, wertet
der gesamte <code>assert</code> Ausdruck zum zweiten Ausdruck aus:</p><pre><code>nix-repl&gt; assert true ; &quot;1199Panigale&quot;
&quot;1199Panigale&quot;

nix-repl&gt; assert 3 &lt; 4 ; &quot;1199&quot; + &quot;Panigale&quot;
&quot;1199Panigale&quot;
</code></pre>
<p>Wenn der erste Ausdruck zu <code>false</code> auswertet, l√∂st der <code>assert</code>
Ausdruck einen Fehler aus:</p><pre><code>nix-repl&gt; assert false ; &quot;1199Panigale&quot;
error: assertion &#39;false&#39; failed

nix-repl&gt; assert 4 &lt; 3 ; &quot;1199&quot; + &quot;Panigale&quot;
error: assertion &#39;(__lessThan 4 3)&#39; failed
</code></pre>
<p>Fehler, die von <code>assert</code> ausgel√∂st worden sind, k√∂nnen mit
<code>builtins.tryEval</code> aufgefangen werden:</p><pre><code>nix-repl&gt; builtins.tryEval (assert true ; &quot;1199Panigale&quot;)
{ success = true; value = &quot;1199Panigale&quot;; }

nix-repl&gt; builtins.tryEval (assert false ; &quot;1199Panigale&quot;)
{ success = false; value = false; }
</code></pre>
<h2 id="impurity">Impurity</h2>
<p>Die Nix Expression Language ist keine pure funktionale Sprache.
Sie folgt dem Anspruch, m√∂glichst pur zu arbeiten, um die
Reproduzierbarkeit von Builds sicherzustellen.  Es gibt aber ein
paar Ausnahmen.</p><p>Ich will kein Haskell Snob sein, bin aber geneigt, anzumerken,
dass eine Programmiersprache entweder <em>purely functional</em>
ist oder nicht, also ganz oder gar nicht.  Es gibt dazwischen
keinen Kompromiss, bzw. der Kompromiss w√§re immer <em>impure</em>.
Schlie√ülich ist eine mathematische Relation entweder eine Abbildung
oder eben nicht.  Andererseits kann man sehr wohl auch in einer
Programmiersprache, welche diese Eigenschaft nicht hat, <em>purely
functional</em> programmieren; es obliegt dann nur dem Menschen,
sicherzustellen dass der Code ausschlie√ülich statische Werte
aus dem Kontext liest und klar unterscheidet zwischen Prozeduren,
die Nebeneffekte hervorrufen, und solchen die das nicht tun.</p><p>Es folgen ein paar Ursachen daf√ºr, dass die Nix Expression Language
nicht <em>pure</em> ist.  (Es gibt noch weitere.)</p><h3 id="builtinsgetenv">builtins.getEnv</h3>
<p>Die Prozedur <code>builtins.getEnv</code> liest Umgebungsvariable:</p><pre><code>nix-repl&gt; builtins.getEnv &quot;HOME&quot;
&quot;/home/aramis&quot;
</code></pre>
<p>Das ist unter allen Prozeduren, die hier aufgef√ºhrt sind, der eine,
von dem ich mir vorstellen k√∂nnte, dass er in die tolle Idee vom
<em>Purely Functional Package Management</em> eine gro√üe L√ºcke rei√üt.</p><h3 id="builtinstrace">builtins.trace</h3>
<p>Die Prozedur <code>builtins.trace</code> nimmt zwei Werte entgegen, sendet
den ersten Wert zur Standardfehlerausgabe und wertet selbst zum
zweiten Wert aus:</p><pre><code>nix-repl&gt; builtins.trace &quot;err&quot; &quot;val&quot;
trace: err
&quot;val&quot;
</code></pre>
<p>Auf die Standardfehlerausgabe zu schreiben, ist strenggenommen
ein Nebeneffekt, aber auch Sprachen, die sich r√ºhmen, <em>purely
functional</em> zu sein, brauchen und haben eine <code>trace</code> Prozedur.</p><h3 id="builtinstofile">builtins.toFile</h3>
<p>Die Prozedur <code>builtins.toFile</code> schreibt Dateien in den Nix Store:</p><pre><code>nix-repl&gt; builtins.toFile &quot;foo.txt&quot; &quot;hello!&quot;
&quot;/nix/store/ayh05aay2anx135prqp0cy34h891247x-foo.txt&quot;

nix-repl&gt; :q

$ cat /nix/store/ayh05aay2anx135prqp0cy34h891247x-foo.txt
hello!
</code></pre>
<p>In eine Datei zu schreiben ist nat√ºrlich ein Nebeneffekt.  Zumindest
wird hier sichergestellt, dass eine Datei, die einmal im Nix Store
erzeugt worden ist, ihren Inhalt nicht mehr unbemerkt √§ndern kann,
denn ein Hashwert ihres Inhalts wird dem Dateinamen als Pr√§fix
vorangestellt.  Was Nix anschlie√üend mit diesen Hashwerten macht
‚Äì insbesondere ob Nix wirklich jede Datei vor jeder Verarbeitung
erneut hasht und mit dem Dateinamen abgleicht ‚Äì wei√ü ich nicht,
aber das finde ich bestimmt noch heraus.</p><p>An der Stelle bin ich durch mit
<a href="https://learnxinyminutes.com/docs/nix/">https://learnxinyminutes.com/docs/nix/</a>.  Aktuell ist mein Plan, mir
als n√§chstes die Namen anzuschauen, die in der Nix Repl aufgelistet
werden wenn man direkt nach dem Start die Tab-Taste dr√ºckt.
Dann schaue ich mir den Inhalt des <code>builtins</code> Sets genauer an.</p><h2 id="top-level-namen">Top-Level Namen</h2>
<p>Es gibt ein paar Namen (f√ºr Funktionen, Prozeduren, ‚Ä¶), die nach
dem Start der Nix Repl unqualifiziert im Top-Level zur Verf√ºgung
stehen:</p><pre><code>abort baseNameOf break builtins derivation derivationStrict dirOf
false fetchGit fetchMercurial fetchTarball fetchTree fromTOML
import isNull map null placeholder removeAttrs scopedImport
throw toString true
</code></pre>
<p>Daneben gibt es noch eine Menge von Namen, die mit einem Unterstrich
beginnen, wie z.B. <code>__typeOf</code>.  Das scheinen allesamt Aliase f√ºr
die Namen im <code>builtins</code> Set zu sein.  Diese Namen lasse ich hier aus,
weil ich vorhabe, sp√§ter auf den Inhalt von <code>builtins</code> einzugehen.</p><p>Die folgenden Namen wurden schon weiter oben erl√§utert:</p><pre><code>abort builtins false import throw true
</code></pre>
<p>Jetzt schaue ich mir den Rest an.</p><h3 id="map">map</h3>
<p>Damit kann man eine Funktion auf jedes Element in einer Liste
anwenden:</p><pre><code>nix-repl&gt; map (n : 2 * n) [ 1 2 3 ]
[ 2 4 6 ]
</code></pre>
<p>Wer schon funktional programmiert hat, d√ºrfte <code>map</code> kennen.</p><h3 id="basenameof">baseNameOf</h3>
<p>Liefert das letzte Segment in einem Pfad:</p><pre><code>nix-repl&gt; baseNameOf /home/aramis
&quot;aramis&quot;

nix-repl&gt; baseNameOf ./.
&quot;aramis&quot;
</code></pre>
<p>Das funktioniert auch mit Strings:</p><pre><code>nix-repl&gt; baseNameOf &quot;/home/aramis&quot;
&quot;aramis&quot;

nix-repl&gt; baseNameOf &quot;/home/aramis/&quot;
&quot;aramis&quot;
</code></pre>
<p>Pfade in einem String werden aber nicht kanonisiert:</p><pre><code>nix-repl&gt; baseNameOf &quot;../../..&quot;
&quot;..&quot;
</code></pre>
<h3 id="dirof">dirOf</h3>
<p>Liefert den Pfad ohne das letzte Segment:</p><pre><code>nix-repl&gt; dirOf /home/aramis
/home

nix-repl&gt; dirOf &quot;/home/aramis&quot;
&quot;/home&quot;

nix-repl&gt; dirOf &quot;/home/aramis/&quot;
&quot;/home/aramis&quot;

nix-repl&gt; dirOf &quot;../../..&quot;
&quot;../..&quot;
</code></pre>
<h3 id="null-isnull">null, isNull</h3>
<p>Offenbar gibt es einen <code>null</code> Wert.  Ich wei√ü nicht, welche Rolle
<code>null</code> in der Nix Expression Language spielt.  Hoffentlich keine
allzu gro√üe.  In anderen Sprachen repr√§sentiert der <code>null</code> Wert
h√§ufig die Abwesenheit eines ‚Äúechten‚Äù Wertes.</p><p>Der <code>null</code> Wert scheint seinen eigenen Datentyp zu haben.  Ich greife
an der Stelle vor auf <code>builtins.typeOf</code>.  Damit kann man den Datentyp
eines Ausdrucks  finden:</p><pre><code>nix-repl&gt; builtins.typeOf 0
&quot;int&quot;

nix-repl&gt; builtins.typeOf 0.0
&quot;float&quot;

nix-repl&gt; builtins.typeOf false
&quot;bool&quot;

nix-repl&gt; builtins.typeOf &quot;&quot;
&quot;string&quot;

nix-repl&gt; builtins.typeOf []
&quot;list&quot;

nix-repl&gt; builtins.typeOf {}
&quot;set&quot;

nix-repl&gt; builtins.typeOf null
&quot;null&quot;
</code></pre>
<p>Die Funktion <code>isNull</code> ist markiert als <em>deprecated</em>.  Man soll
stattdessen <code>... == null</code> verwenden:</p><pre><code>nix-repl&gt; isNull null
true

nix-repl&gt; isNull 0
false

nix-repl&gt; isNull &quot;&quot;
false

nix-repl&gt; null == null
true

nix-repl&gt; 0 == null
false

nix-repl&gt; &quot;&quot; == null
false
</code></pre>
<h3 id="tostring">toString</h3>
<p>Damit k√∂nnen Ausdr√ºcke in eine Stringdarstellung √ºberf√ºhrt
werden:</p><pre><code>nix-repl&gt; toString 123
&quot;123&quot;

nix-repl&gt; toString &quot;Das ist schon ein String&quot;
&quot;Das ist schon ein String&quot;
</code></pre>
<p>Pfade werden kanonisiert:</p><pre><code>nix-repl&gt; toString ./.
&quot;/home/aramis&quot;
</code></pre>
<p>F√ºr andere Datentypen liefert <code>toString</code> Ergebnisse, die ich so
nicht erwartet h√§tte:</p><pre><code>nix-repl&gt; toString 0.0
&quot;0.000000&quot;

nix-repl&gt; toString true
&quot;1&quot;

nix-repl&gt; toString false
&quot;&quot;

nix-repl&gt; toString []
&quot;&quot;

nix-repl&gt; toString [ 1 2 3 ]
&quot;1 2 3&quot;

nix-repl&gt; toString [ 1 2 3 [ 4 5 6 ] ]
&quot;1 2 3 4 5 6&quot;

nix-repl&gt; toString null
&quot;&quot;
</code></pre>
<p>Auf Sets kann <code>toString</code> nur operieren wenn darin ein spezieller
Schl√ºssel <code>__toString</code> oder <code>outPath</code> vorhanden ist:</p><pre><code>nix-repl&gt; toString { a = 1 ; b = 2 ; c = 3 ; }
error: cannot coerce a set to a string

nix-repl&gt; toString { a = 1 ; b = 2 ; c = 3 ; outPath = &quot;asdf&quot; ; }
&quot;asdf&quot;

nix-repl&gt; toString
...         { a = 1 ; b = 2 ; c = 3 ; __toString = self : self.a }
&quot;1&quot;
</code></pre>
<h3 id="break">break</h3>
<p>Die Prozedur <code>break</code> hat hier nichts mit While-Schleifen oder
√§hnlichem zu tun.  Man kann damit Breakpoints im Code setzen, an
denen der Interpreter im Debug Modus die Auswertung pausiert und in
die Repl wechselt.  Um den Interpreter im Debug Modus zu starten,
muss das Flag <code>--debugger</code> mit √ºbergeben werden.</p><p>Da wir hier nicht imperativ sondern deklarativ bzw. funktional
programmieren, kann <code>break</code> nicht als Anweisung im Code platziert
werden ohne selbst zu irgendetwas auszuwerten.  Deswegen erwartet
<code>break</code> ein Argument und wertet zu diesem Argument aus:</p><pre><code>nix-repl&gt; break 1
1
</code></pre>
<h3 id="removeattrs">removeAttrs</h3>
<p>Die Funktion <code>removeAttrs</code> nimmt ein Set und eine Liste mit
Schl√ºsseln entgegen.  Die aufgef√ºhrten Schl√ºssel werden aus
dem Set entfernt.  Schl√ºssel, die in dem Set nicht vorkommen,
werden ignoriert:</p><pre><code>nix-repl&gt; removeAttrs { x = 1 ; y = 2 ; z = 3 ; } [ &quot;a&quot; &quot;x&quot; &quot;z&quot; ]
{ y = 2; }
</code></pre>
<p>Ich glaube, diese Stelle markiert einen √úbergang.  Ich habe
zun√§chst versucht, die Nix Expression Language ganz allgemein als
Programmiersprache zu betrachten, ohne darauf R√ºcksicht zu nehmen,
wof√ºr sie tats√§chlich eingesetzt werden soll.  Ich denke, dass
das ab hier immer weniger m√∂glich sein wird.</p><h3 id="fromtoml">fromTOML</h3>
<p>Ich bin mit TOML nicht besonders vertraut, aber ich glaube,
es ist nicht viel mehr als eine Folge von zeilenweisen
Schl√ºssel-Wert-Zuweisungen in der Form <code>key=value</code>.  Die Funktion
<code>fromTOML</code> scheint TOML Markup in ein Nix Set zu √ºberf√ºhren:</p><pre><code>nix-repl&gt; fromTOML &quot;a=1\nb=2&quot;
{ a = 1; b = 2; }
</code></pre>
<h3 id="scopedimport">scopedImport</h3>
<p>Das ist nirgendwo richtig dokumentiert und wird nicht einmal im
Nix Manual erw√§hnt.  Es gibt eine Issue auf Github dazu:</p><p><a href="https://github.com/NixOS/nix/issues/1450">https://github.com/NixOS/nix/issues/1450</a></p><p>Ein paar Ausz√ºge:</p><ul>
<li><em>‚ÄúscopedImport has nasty performance consequences since it disables
the parser/evaluation cache‚Äù</em></li>
<li><em>‚ÄúIt allows doing some pretty nasty/nifty things like overriding
every primop (including import)‚Äù</em></li>
</ul>
<p>Ok, also die Finger davon lassen.  Es h√§tte mich trotzdem ein
bisschen interessiert, wie man das benutzt, aber nicht so sehr,
dass ich an der Stelle weiterbuddeln m√∂chte.</p><h3 id="fetchgit-fetchmercurial-fetchtarball-fetchtree">fetchGit, fetchMercurial, fetchTarball, fetchTree</h3>
<p>Mit den Fetch-Befehlen lassen sich Dateien herunterladen und in
den Nix Store schreiben.  <code>fetchMercurial</code> und <code>fetchTree</code> sind
undokumentiert, also schaue ich mir zun√§chst die anderen beiden an.</p><p><code>fetchGit</code> holt einen Pfad aus einem Git Repository und schreibt ihn
in den Nix Store.  In der Nix Repl erh√§lt man mit <code>:doc fetchGit</code>
reichlich Dokumentation dazu, wie das genau zu benutzen ist.
Ich m√∂chte das hier nicht alles wiedergeben.</p><p><code>fetchTarball</code> l√§dt ein Tar-Archiv herunter und entpackt es in den
Nix Sore.  Das Tar-Archiv kann (oder muss?) zus√§tzlich mit <code>gzip</code>,
<code>bzip7</code> oder <code>xv</code> komprimiert sein.  Die Dokumentation in der Repl
dazu ist auch recht ausf√ºhrlich.</p><p><code>fetchMercurial</code> ist in der Repl nicht dokumentiert.  Ich nehme an,
es ist wie <code>fetchGit</code> aber f√ºr Mercurial Repositories.</p><p><code>fetchTree</code> ist ebenfalls undokumentiert in der Repl.  Das Nix
Manual erw√§hnt, dass <code>fetchTree</code> die Funktionalit√§t der
anderen Fetch-Befehle in sich vereint und somit beliebige Quellen
herunterladen kann.  M√∂glicherweise ist das nur eine Fassade,
die je nach Quelle das passende Backend w√§hlt, ungef√§hr so wie
<code>aunpack</code> das Entpacken von Archivdateien handhabt.</p><h3 id="derivation-derivationstrict">derivation, derivationStrict</h3>
<p>Beides hat in der Nix Repl keine Dokumentation.  Was ist eine
Derivation?  Man kann das w√∂rtlich mit Ableitung √ºbersetzen.
Im Kontext von Nix ist damit eine sogenannte <em>Build Action</em>
gemeint.  Ich nehme an, das ist ein Rezept f√ºr den Bau eines
Softwarepaketes und seine ‚ÄúInstallation‚Äù im Nix Store.  Laut Handbuch
ist <code>derivation</code> die wichtigste built-in Funktion: schlie√ülich ist
Nix genau daf√ºr gedacht/gemacht, solche Derivationen zu beschreiben
und auszuf√ºhren.</p><p><code>derivation</code> verarbeitet ein Set, das genau beschreibt, was gebaut
wird, und zwar mit den folgenden Schl√ºsseln (Attributen):</p><ul>
<li><code>system</code><ul>
<li>Nix Systemtyp, z.B. <code>&quot;i686-linux&quot;</code> oder <code>&quot;x86_64-darwin&quot;</code></li>
<li>siehe <code>nix -vv --version</code></li>
</ul>
</li>
<li><code>name</code><ul>
<li>der Name des Pakets</li>
</ul>
</li>
<li><code>builder</code><ul>
<li>das Programm, welches zum Bauen verwendet wird</li>
<li>kann eine Derivation oder eine lokale Datei sein (ein Script)</li>
<li>Die Attribute der Derivation werden als Umgebungsvariable
√ºbergeben:<ul>
<li>Strings und Zahlen werden unver√§ndert √ºbergeben.</li>
<li>Pfade werden zun√§chst in den Nix Store kopiert und der
Zielpfad landet in der Umgebungsvariable.</li>
<li>Derivationen werden gebaut und der Pfad des Zielartefakts
landet in der Umgebungsvariable.<ul>
<li>Listen werden leerzeichensepariert √ºbergeben.</li>
<li><code>true</code> wird als <code>1</code> √ºbergeben.</li>
<li><code>false</code> und <code>null</code> werden als <code>&quot;&quot;</code> √ºbergeben.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>args</code><ul>
<li>optionale Liste von CLI-Argumenten f√ºr das bauende Programm</li>
</ul>
</li>
<li><code>outputs</code><ul>
<li>optionale Liste von Ausgabepfaden</li>
<li>Normalerweise gibt es nur einen Outputpfad <code>out</code>, aber man
kann diesen Schl√ºssel verwenden, um verschiedene Ausgabepfade
zu deklarieren, bspw. <code>[ &quot;lib&quot; &quot;headers&quot; &quot;doc&quot; ]</code>, dann stehen
dem bauenden Programm drei Pfade statt nur einem zur Verf√ºgung,
die separat garbage-collected werden k√∂nnen.</li>
</ul>
</li>
</ul>
<p>Damit habe ich eine erste, grobe Vorstlelung davon, wie Nix baut.</p><p>F√ºr <code>derivationStrict</code> habe ich nirgendwo Dokumentation gefunden.</p><h3 id="placeholder">placeholder</h3>
<p>Nimmt einen Ausgabepfad entgegen (<code>&quot;out&quot;</code>, <code>&quot;bin&quot;</code>, <code>&quot;dev&quot;</code>,
‚Ä¶) und liefert einen Plazhalter, der beim Bauen durch den
Ausgabepfad ersetzt wird.  Es scheint wirklich eine Funktion zu sein:</p><pre><code>nix-repl&gt; placeholder &quot;out&quot;
&quot;/1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9&quot;

nix-repl&gt; placeholder &quot;out&quot;
&quot;/1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9&quot;

nix-repl&gt; placeholder &quot;out&quot;
&quot;/1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9&quot;
</code></pre>
<p>Keine Ahnung, wof√ºr das gut ist.</p><h2 id="built-ins">Built-ins</h2>
<p>Im letzten Abschnitt habe ich mir die Namen angeschaut, die nach
dem Start der Nix Repl unqualifiziert im Top-Level verf√ºgbar sind.
Unterhalb von <code>builtins</code> gibt es eine ganze Reihe weiterer Namen.
Die schaue ich mir jetzt an.  Einige davon sind nicht neu, weil
sie auch im Top-Level verf√ºgbar sind.  Die lasse ich unerw√§hnt aus.</p><h3 id="builtinsadd">builtins.add</h3>
<p>Die Funktion hinter dem <code>+</code> Operator:</p><pre><code>nix-repl&gt; builtins.add 3 4
7
</code></pre>
<h3 id="builtinsadderrorcontext">builtins.addErrorContext</h3>
<p>Daf√ºr finde ich keine Dokumentation.</p><h3 id="builtinsall">builtins.all</h3>
<p>Pr√ºft ob ein Pr√§dikat auf alle Elemente einer Liste zutrifft:</p><pre><code>nix-repl&gt; builtins.all ( n : n &gt; 3 ) [ 1 2 3 ]
false

nix-repl&gt; builtins.all ( n : n &gt; 3 ) [ 4 5 6 ]
true
</code></pre>
<h3 id="builtinsany">builtins.any</h3>
<p>Pr√ºft ob ein Pr√§dikat auf mindestens ein Element einer Liste
zutrifft:</p><pre><code>nix-repl&gt; builtins.any ( n : n &lt; 3 ) [ 1 2 3 ]
true

nix-repl&gt; builtins.any ( n : n &lt; 3 ) [ 4 5 6 ]
false
</code></pre>
<h3 id="builtinsappendcontext">builtins.appendContext</h3>
<p>Daf√ºr finde ich keine Dokumentation.</p><h3 id="builtinsattrnames">builtins.attrNames</h3>
<p>Liefert eine sortierte Liste der Schl√ºssel in einem Set:</p><pre><code>nix-repl&gt; builtins.attrNames { a = 1 ; b = 2 ; c = 3 ; }
[ &quot;a&quot; &quot;b&quot; &quot;c&quot; ]
</code></pre>
<h3 id="builtinsattrvalues">builtins.attrValues</h3>
<p>Wie Sartres Autodidakt, gehe ich die Built-ins in alphabetischer
Reihder sonderliche Autodidakt in Bouville, gehe ich die Built-ins in
alphabetischer Reihenfolge durch.  Immerhin sind es bei mir nicht die
B√ºcher einer ganzen Bibliothek, sondern nur ein paar Nix-Funktionen.
Jetzt w√§re <code>builtins.deepSeq</code></p><pre><code>nix-repl&gt; builtins.attrValues { a = 3 ; b = 2 ; c = 1 ; }
[ 3 2 1 ]
</code></pre>
<h3 id="builtinsbitand">builtins.bitAnd</h3>
<p>Bitweise Konjunktion zweier Integers:</p><pre><code>nix-repl&gt; builtins.bitAnd 123 456
72
</code></pre>
<p>Rechnen wir das spa√üeshalber durch:</p><pre><code>123 = 64  + 32  + 16  + 8   + 2   + 1
    = 2^6 + 2^5 + 2^4 + 2^3 + 2^1 + 2^0
    = 1111011

456 = 256 + 128 + 64  + 8
    = 2^8 + 2^7 + 2^6 + 2^3
    = 111001000

  001111011
+ 111001000
= 001001000 = 2^3 + 2^6 = 72
</code></pre>
<h3 id="builtinsbitor">builtins.bitOr</h3>
<p>Bitweise Disjunktion zweier Integers:</p><pre><code>nix-repl&gt; builtins.bitOr 123 456
507
</code></pre>
<h3 id="builtinsbitxor">builtins.bitXor</h3>
<p>Bitweise Kontravalenz (‚Äúexklusive Disjunktion‚Äù) zweiter Integers:</p><pre><code>nix-repl&gt; builtins.bitXor 123 456
435
</code></pre>
<h3 id="builtinsbuiltins">builtins.builtins</h3>
<p>Offenbar enth√§lt das <code>builtins</code> Set eine Referenz auf sich selbst.</p><pre><code>nix-repl&gt; builtins.builtins == builtins
true

nix-repl&gt; builtins.builtins.builtins.builtins == builtins
true
</code></pre>
<p>Schrullig, aber was soll‚Äôs.</p><h3 id="builtinscatattrs">builtins.catAttrs</h3>
<p>Das nimmt einen Schl√ºssel (String) und sammelt aus einer Liste
von Sets die Werte f√ºr diesen Schl√ºssel ein:</p><pre><code>nix-repl&gt; builtins.catAttrs &quot;a&quot;
...         [ { a = 1 ; } { b = 2 ; } { a = 3 ; } ]
[ 1 3 ]
</code></pre>
<h3 id="builtinsceil">builtins.ceil</h3>
<p>Liefert f√ºr eine Zahl <code>x</code> die n√§chste Ganzzahl <code>n</code> sodass <code>x &lt;= n</code>:</p><pre><code>nix-repl&gt; builtins.ceil 1.5
2

nix-repl&gt; builtins.ceil 2
2
</code></pre>
<h3 id="builtinscompareversions">builtins.compareVersions</h3>
<p>Vergleicht zwei Strings anhand der typischen Ordnung von
Versionsnummern.  Das Ergebnis ist <code>-1</code>, <code>0</code> oder <code>1</code>, je nachdem
ob das erste Argument gegen√ºber dem zweiten kleiner, gleich oder
gr√∂√üer ist.</p><pre><code>nix-repl&gt; builtins.compareVersions &quot;0.0.0&quot; &quot;0.0.1&quot;
-1

nix-repl&gt; builtins.compareVersions &quot;0.0.1&quot; &quot;0.0.1&quot;
0

nix-repl&gt; builtins.compareVersions &quot;0.0.2&quot; &quot;0.0.1&quot;
1
</code></pre>
<h3 id="builtinsconcatlists">builtins.concatLists</h3>
<p>Konkateniert Listen:</p><pre><code>nix-repl&gt; builtins.concatLists [ [ 1 2 3 ] [ 4 5 6 ] ]
[ 1 2 3 4 5 6 ]
</code></pre>
<h3 id="builtinsconcatmap">builtins.concatMap</h3>
<p>Das ist eine Verkettung von <code>map</code> und <code>concatLists</code>.  Das hei√üt,
f√ºr eine Funktion <code>f</code> und eine Liste <code>ls</code> sind die folgenden beiden
Ausdr√ºcke √§quivalent:</p><p><code>builtins.concatLists (map f ls)</code></p><p><code>builtins.concatMap f ls</code></p><p>Beispielsweise:</p><pre><code>nix-repl&gt; with
...         { f  = map ( n : 2 * n ) ;
...           ls = [ [ 1 2 3 ] [ 4 5 6 ] ] ;
...         } ;
...         builtins.concatLists ( map f ls )
[ 2 4 6 8 10 12 ]

nix-repl&gt; with
...         { f  = map ( n : 2 * n ) ;
...           ls = [ [ 1 2 3 ] [ 4 5 6 ] ] ;
...         } ;
...         builtins.concatMap f ls
[ 2 4 6 8 10 12 ]
</code></pre>
<h3 id="builtinsconcatstringssep">builtins.concatStringsSep</h3>
<p>Konkateniert Strings mit einem Trennzeichen:</p><pre><code>nix-repl&gt; builtins.concatStringsSep &quot;/&quot; [ &quot;usr&quot; &quot;local&quot; &quot;bin&quot; ]
&quot;usr/local/bin&quot;
</code></pre>
<h3 id="builtinscurrentsystem">builtins.currentSystem</h3>
<p>Liefert einen Namen f√ºr das System, auf dem Nix gerade l√§uft:</p><pre><code>nix-repl&gt; builtins.currentSystem
&quot;x86_64-linux&quot;
</code></pre>
<h3 id="builtinscurrenttime">builtins.currentTime</h3>
<p>Liefert die aktuelle Posix-Zeit:</p><pre><code>nix-repl&gt; builtins.currentTime
1661168166
</code></pre>
<h3 id="builtinsseq">builtins.seq</h3>
<p>Wie der sonderliche Autodidakt in Bouville, gehe ich die Built-ins
in alphabetischer Reihenfolge durch.  Immerhin sind es bei mir
nicht die B√ºcher einer ganzen Bibliothek, sondern nur ein paar
Nix-Funktionen.  Jetzt w√§re <code>builtins.deepSeq</code> an der Reihe,
aber das w√§re Quatsch ohne vorher <code>builtins.seq</code> zu betrachten.
Deswegen ziehe ich das vor.</p><p>Nix wertet verz√∂gert aus (so wie Haskell).  Das bedeutet, dass
Ausdr√ºcke erst dann ausgewertet werden wenn sie tats√§chlich
gebraucht werden und auch nur so weit wie es tats√§chlich n√∂tig ist.
Ich m√∂chte das kurz an einem Beispiel demonstrieren.  Das geht
vielleicht am besten mit einer Funktion, die viel Rechenzeit frisst.
Ad hoc f√§llt mir die Fibonacci-Funktion ein.  Das hier w√§re eine
einfache Implementierung daf√ºr in Haskell:</p><pre><code>-- Haskell:

fib n =
    if n &lt; 1 then 0
    else if n &lt; 2 then 1
    else fib ( n - 1 ) + fib ( n - 2 )
</code></pre>
<p>Das ist so rechenaufw√§ndig, dass ich mit meinem Rechner auf <code>fib 32</code> schon ein paar Sekunden warten muss, also ein guter Kandidat.
Wir k√∂nnen das auch als Lambda-Ausdruck schreiben.  Dann wandert
der Parameter <code>n</code> nach rechts hinter das <code>=</code> Zeichen:</p><pre><code>-- Haskell:

fib = \ n -&gt;
    if n &lt; 1 then 0
    else if n &lt; 2 then 1
    else fib ( n - 1 ) + fib ( n - 2 )
</code></pre>
<p>In Nix m√ºssen Funktionen als Lambda-Ausdr√ºcke notiert werden.
Die konventionelle Notation mit dem Parameter auf der linken Seite
wird nicht unterst√ºtzt.  Mein erster Versuch, diese Funktion in
Nix zu schreiben, sah so aus:</p><pre><code>nix-repl&gt; fib = n :
...         if n &lt; 1 then 0
...         else if n &lt; 2 then 1
...         else fib ( n - 1 ) + fib ( n - 2 )
error: undefined variable &#39;fib&#39;
</code></pre>
<p>Nix unterst√ºtzt keine rekursiven Funktionen, jedenfalls nicht auf
diese Weise.  Damit das klappt, m√ºssen wir die Funktion in ein
rekursives Set stecken:</p><pre><code>nix-repl&gt; funs = rec
...         { fib = n :
...             if n &lt; 1 then 0
...             else if n &lt; 2 then 1
...             else fib ( n - 1 ) + fib ( n - 2 ) ;
...         }

nix-repl&gt; funs.fib 32
2178309
</code></pre>
<p>Nix rechnet <code>funs.fib 32</code> schneller aus als Haskell aber es dauert
mit meinem Rechner immer noch mehr als eine Sekunde, bis der
Interpreter die Berechnung gestemmt hat und das Ergebnis ausdruckt.
Damit haben wir alles beisammen um verz√∂gerte Auswertung zu
demonstrieren.  Daf√ºr erg√§nzen wir das Set um zwei weitere
Schl√ºssel-Wert-Paare:</p><pre><code>nix-repl&gt; funs = rec
...         { fib = n :
...             if n &lt; 1 then 0
...             else if n &lt; 2 then 1
...             else fib ( n - 1 ) + fib ( n - 2 ) ;
...
...           fib35 = fib 35 ;
...           x = 1 ;
...         }

nix-repl&gt;
</code></pre>
<p>Den Wert f√ºr den Schl√ºssel <code>fib35</code> auszurechnen, sollte
ein paar Sekunden dauern, aber die Nix Repl nimmt das Set ohne
Zeitverz√∂gerung entgegen.  Das spricht daf√ºr, dass der Wert f√ºr
<code>fib35</code> nicht sofort berechnet wird.  Wir k√∂nnen uns auch den Wert
f√ºr den Schl√ºssel <code>x</code> ohne Zeitverz√∂gurung ausgeben lassen:</p><pre><code>nix-repl&gt; funs.x
1
</code></pre>
<p>Erst wenn wir uns den Wert f√ºr <code>fib35</code> ausgeben lassen, gibt es eine
deutliche Verz√∂gerung von mehreren Sekunden, die darauf hinweist,
dass der Wert jetzt tats√§chlich berechnet wird:</p><pre><code>nix-repl&gt; funs.fib35
9227465
</code></pre>
<p>Wenn wir uns im Anschluss noch einmal das ganze Set ausgeben lassen,
geschieht das wieder ohne Verz√∂gerung:</p><pre><code>nix-repl&gt; funs
{ fib = ¬´lambda @ (string):1:14¬ª; fib35 = 9227465; x = 1; }
</code></pre>
<p>Der Wert f√ºr den Schl√ºssel <code>fib35</code> wurde schon berechnet und
wird hier einfach wiederverwendet anstatt ihn ein zweites Mal zu
berechnen.  Deswegen erfolgt die Ausgabe ohne zeitliche Verz√∂gerung.
Wenn wir vorher nicht <code>funs.fib35</code> ausgewertet h√§tten, dann
h√§tten wir an dieser Stelle ein paar Sekunden auf die Auswertung
warten m√ºssen.</p><p>Das ist verz√∂gerte Auswertung: die Ausdr√ºcke und Teilausdr√ºcke
werden nicht sofort ausgewertet sondern erst dann wenn ihr Wert
tats√§chlich ben√∂tigt wird, bspw. um eine Ausgabe zu erzeuen.</p><p>Im Allgemeinen ist das eine gute Sache, aber manchmal m√∂chte
man, dass die Auswertung nicht verz√∂gert sondern sofort
stattfindet.  Das ist vor allem dann wichtig, wenn zwei Ausdr√ºcke
irgendwelche externen Effeke haben und diese Effekte in einer
bestimmen Reihenfolge auftreten sollen.  Dann muss man irgendwie
sicherstellen, dass die Ausdr√ºcke in der richtigen Reihenfolge
ausgewertet werden.  In Programmiersprachen, die standardm√§√üig
strikt (i.e. unverz√∂gert) auswerten, hat man dieses Problem nicht.
Da ist die Auswertungsreihenfolge dadurch vorgegeben, in welcher
Reihenfolge man Ausdr√ºcke notiert.  In Programmiersprachen, die
standardm√§√üig verz√∂gert auswerten, ben√∂tigt man daf√ºr besondere
Hilfsmittel, die eine strikte Auswertung sicherstellen.</p><p>Hier kommt <code>builtins.seq</code> ins Spiel.  <code>builtins.seq</code> nimmt zwei
Ausdr√ºcke entgegen, wertet den ersten Ausdruck aus, verwirft das
Resultat und wertet dann den zweiten Ausdruck aus:</p><pre><code>nix-repl&gt; builtins.seq 1 2
2
</code></pre>
<p>So wird sichergestellt, dass der erste Ausdruck vor dem zweiten
ausgewertet wird.  Ich kann gerade kein leicht demonstrierbares
Beispiel aus dem √Ñrmel sch√ºtteln, bei dem das eine Rolle spielen
w√ºrde, aber wenn bspw. der erste Ausdruck eine Datei schreibt und
der zweite diese Datei liest, stellt <code>builtins.seq</code> sicher, dass das
Schreiben tats√§chlich vor dem Lesen erfolgt.  Ohne <code>builtins.seq</code>
w√§re diese Reihenfolge wegen der verz√∂gerten Auswertung nicht
sichergestellt.</p><h3 id="builtinsdeepseq">builtins.deepSeq</h3>
<p>Die Auswertung von <code>builtins.seq e1 e2</code> ist zwar strikt im Ausdruck
<code>e1</code>, aber mit einem Haken: der Ausdruck <code>e1</code> wird nur oberfl√§chlich
strikt ausgewertet.  Ich erkl√§re kurz, was das bedeutet.  Es gibt
einfache Ausdr√ºcke, die direkt ausgewertet werden k√∂nnen ohne
daf√ºr weiter vereinfacht werden zu m√ºssen.  Das sind bspw. einfache
Zahlenausdr√ºcke <code>123</code> oder Zeichenketten wie <code>&quot;asdf&quot;</code>.  Daneben gibt
es aber auch komplexe Ausdr√ºcke, die bei der Auswertung zun√§chst
auf einen einfachen Ausdruck reduziert werden m√ºssen.  Das ist
der Fall wenn ein Ausdruck Funktionen (bzw. Operationen) enth√§lt,
die bei der Auswertung angewendet werden m√ºssen.  Diese Reduktion
auf einen einfachen Ausdruck erfolgt schrittweise.  Hier ist ein
Ausdruck, der in mehreren Schritten ausgewertet werden muss:</p><pre><code>nix-repl&gt; let
...         f1 = n : 1 + n ;
...         f2 = n : 2 + n ;
...         f3 = n : 3 + n ;
...       in
...         f3 ( f2 ( f1 0 ) )
</code></pre>
<p>Hier ist eine m√∂gliche Auswertung f√ºr diesen Ausdruck:</p><pre><code>=&gt; f3            ( f2            ( f1            0 ) )
-----------------------------------^^^^^^^^^^^^^----------
=&gt; f3            ( f2            ( ( n : 1 + n ) 0 ) )
-----------------------------------^^^^^^^^^^^^^^^--------
=&gt; f3            ( f2            ( 1 + 0           ) )
---------------------------------^^^^^^^^^^^^^^^^^^^------
=&gt; f3            ( f2            1                   )
-------------------^^^^^^^^^^^^^--------------------------
=&gt; f3            ( ( n : 2 + n ) 1                   )
-------------------^^^^^^^^^^^^^^^------------------------
=&gt; f3            ( 2 + 1                             )
-----------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^----
=&gt; f3            3
---^^^^^^^^^^^^^------------------------------------------
=&gt; ( n : 3 + n ) 3
---^^^^^^^^^^^^^^^----------------------------------------
=&gt; 3 + 3
---^^^^^--------------------------------------------------
=&gt; 6
</code></pre>
<p>Ob die Auswertung tats√§chlich genau in dieser Reihenfolge
stattfindet, wei√ü ich nicht.  Es gibt da verschiedene
M√∂glichkeiten.  Relevant ist f√ºr uns nur, dass die Auswertung
schrittweise erfolgt.</p><p>Wenn das nun der Teilausausdruck <code>e1</code> im Ausdruck <code>builtins.seq e1 e2</code> w√§re, w√ºrde <code>builtins.seq</code> nicht garantieren, dass das ganze
vor der Auswertung von <code>e2</code> vollst√§ndig auf den Wert <code>6</code> reduziert
wird.  <code>builtins.seq</code> w√ºrde lediglich gew√§hrleisten, dass <code>e1</code> auf
der ersten Ebene strikt ausgewertet wird, also vielleicht bis <code>f3 ( f2 ( 1 + 0 ) )</code>.  Damit w√§re die Funktion <code>f1</code> schon vollst√§ndig
abgefr√ºhst√ºckt, aber wenn sich in <code>f2</code> oder <code>f3</code> noch irgendwelche
externen Nebeneffekte verbergen w√ºrden, w√§re durch <code>builtins.seq</code>
nicht sichergestellt, dass diese Effekte vor der Auswertung von
<code>e2</code> eintreten.  Genau das war gemeint mit der Feststellung,
<code>builtins.seq</code> w√ºrde <code>e1</code> nur oberfl√§chlich strikt auswerten.</p><p>Ich m√∂chte hier anmerken, dass ich mich mit dieser Erl√§uterung
recht weit aus dem Fenster lehne.  Ich wei√ü nicht, wie der Nix
Interpreter tats√§chlich auswertet und ob meine Charakterisierung
einer nur oberfl√§chlich strikten Auswertung den Nagel auf den Kopf
trifft.  Ich hoffe, dass es hier kein fundamentales Missverst√§ndnis
meinerseits gibt, das diese Erl√§uterung zu Stuss macht.  In jedem
Fall ist das gegenw√§rtig mein mentales Modell dieser Sache.</p><p>Wenn <code>e1</code> eine Prozedur wie <code>fetchGit</code> ist, die direkt einen externen
Nebeneffekt erzeugt, gen√ºgt die oberfl√§chlich strikte Auswertung
durch <code>builtins.seq</code>, aber wenn ein komplexer Ausdruck vollst√§ndig,
also in voller Tiefe, strikt ausgewertet werden soll, muss daf√ºr
<code>builtins.deepSeq</code> verwendet werden.</p><p>Meine Motivation, daf√ºr ein gutes Beispiel zu finden, ist bei Null,
denn ich habe noch reichlich Built-ins vor mir.  Vielleicht erg√§nze
ich sp√§ter eins.</p><h3 id="builtinsdiv">builtins.div</h3>
<p>Die Funktion hinter dem Divisionsoperator <code>/</code>, den wir schon weiter
oben behandelt haben:</p><pre><code>nix-repl&gt; builtins.div 7.0 2
3.5

nix-repl&gt; builtins.div 7 2
3
</code></pre>
<h3 id="builtinselem">builtins.elem</h3>
<p>Pr√ºft, ob ein Wert als Element in einer Liste enthalten ist:</p><pre><code>nix-repl&gt; builtins.elem 3 [ 1 2 3 ]
true

nix-repl&gt; builtins.elem 4 [ 1 2 3 ]
false
</code></pre>
<h3 id="builtinselemat">builtins.elemAt</h3>
<p>Liefert das n-te Element einer Liste:</p><pre><code>nix-repl&gt; builtins.elemAt [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ] 0
&quot;a&quot;

nix-repl&gt; builtins.elemAt [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ] 1
&quot;b&quot;

nix-repl&gt; builtins.elemAt [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ] 2
&quot;c&quot;

nix-repl&gt; builtins.elemAt [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ] 3
error: list index 3 is out of bounds
</code></pre>
<p>Das hier ist aufschlussreich:</p><pre><code>nix-repl&gt; builtins.elemAt [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ] -1
error: value is the partially applied built-in function &#39;elemAt&#39;
       while an integer was expected
</code></pre>
<p>Die Fehlermeldung legt nahe, dass das Minuszeichen hier nicht als
Vorzeichen sondern als Subtraktionsoperator interpretiert wird.
Um das zu √§ndern, muss man Klammern setzen:</p><pre><code>nix-repl&gt; builtins.elemAt [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ] (-1)
error: list index -1 is out of bounds
</code></pre>
<p>Immer noch ein Fehler, aber ein besserer.</p><h3 id="builtinsfetchurl">builtins.fetchurl</h3>
<p>L√§dt etwas herunter, legt es im Nix Store ab und gibt den Pfad aus:</p><pre><code>nix-repl&gt; builtins.fetchurl https://arxiv.org/pdf/2208.10524
[4.2 MiB DL]&quot;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524&quot;
</code></pre>
<p>Wenn man schon im Vorfeld den SHA-256 Hash der Datei kennt, kann
man den Hash mit angeben und damit kryptografisch verifizieren,
dass es die richtige Datei ist:</p><pre><code>nix-repl&gt; builtins.fetchurl
...         { url = https://arxiv.org/pdf/2208.10524 ;
...           sha256 = &quot;cbd791862a937ac2f823b81a771e63bdb5313d204e0011965c833ee3889fdc73&quot; ;
...         }
&quot;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524&quot;
</code></pre>
<p>Wenn der Hash nicht passt, l√∂st das einen Fehler aus:</p><pre><code>nix-repl&gt; builtins.fetchurl
...         { url = https://arxiv.org/pdf/2208.10524 ;
...           sha256 = &quot;ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot; ;
...         }
error: hash mismatch in file downloaded from &#39;https://arxiv.org/pdf/2208.10524&#39;:
         specified: sha256:1zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
                  got:       sha256:0wywky4f6gl3bjb1202f40yk3ddxccg7f6mq4gwc4ylk5a393myb
                  [4.2 MiB DL]
</code></pre>
<p>Der Hash in der Fehlermeldung unterscheidet sich von dem Hash in der Anweisung:</p><pre><code>sha256 = &quot;ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot; ;
...
specified: sha256:1zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
</code></pre>
<p>Ich nehme an, dass Nix einfach nur eine andere Darstellung verwendet
um die Hashes kompakter zu machen.  Man sieht das auch daran,
dass der Hash im Nix Store Pfad ein anderer ist.  Es w√§re gut,
zu wissen, welcher Hash und welche Darstellung das genau ist,
aber darum k√ºmmere ich mich sp√§ter.</p><p>Ich bin mir gar nich sicher, ob Nix die Datei jetzt noch einmal
heruntergeladen hat oder einfach die bereits heruntergeladene Datei
wiederverwendet hat.  Also w√ºrde ich gern die Datei aus dem Store
l√∂schen und dann noch einmal herunterladen.  Wie geht das?  So:</p><pre><code>$ nix-store --delete
    /nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524
</code></pre>
<p>Aber Achtung: Bevor man die Datei aus dem Store l√∂schen kann,
muss man die Nix Repl terminieren.  Solange die Repl noch l√§uft,
verweigert Nix das L√∂schen, weil die Datei noch in Verwendung ist.</p><p>Ich lade die Datei also noch einmal mit einem falschen Hash herunter:</p><pre><code>nix-repl&gt; builtins.fetchurl
...         { url = https://arxiv.org/pdf/2208.10524 ;
...           sha256 = &quot;ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot; ;
...         }
error: hash mismatch in file downloaded from &#39;https://arxiv.org/pdf/2208.10524&#39;:
         specified: sha256:1zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
                  got:       sha256:0wywky4f6gl3bjb1202f40yk3ddxccg7f6mq4gwc4ylk5a393myb
                  [4.2 MiB DL]
                  n
</code></pre>
<p>Die finale Ausgabe stimmt √ºberein, aber die Ausf√ºhrung hat deutlich
l√§nger gedauert, weil Nix die Datei wirklich ein weiteres Mal
heruntergeladen hat.</p><p>Mit <code>builtins.fetchurl</code> haben wir also die M√∂glichkeit, beliebige
Dateien aus dem Netz herunterzuladen und die Echtheit dieser Dateien
durch Angabe eines SHA-256 Hashes abzusichern.  Das bedeutet, dass
wir Dateien, deren Hash wir bereits kennen, aus beliebigen Quellen
herunterladen k√∂nnen, ohne uns Sorgen dar√ºber machen zu m√ºssen,
dass vielleicht jemand diese Dateien ohne unser Wissen ver√§ndert
haben k√∂nnte.  Das ist gro√üartig!  Nix ist ein System f√ºr die
Verwaltung von Softwarepaketen, aber auch jenseits davon fallen
mir f√ºr so etwas viele Einsatzm√∂glichkeiten ein.</p><h3 id="builtinsfilter">builtins.filter</h3>
<p>Bereinigt eine Liste um alle Elemente, denen ein bestimmtes
Pr√§dikat fehlt:</p><pre><code>nix-repl&gt; isEven = n : n / 2 == n / 2.0

nix-repl&gt; builtins.filter isEven
...         [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ]
[ 2 4 6 8 10 12 14 16 ]
</code></pre>
<h3 id="builtinsfiltersource">builtins.filterSource</h3>
<p>Damit kann man Quellen in den Nix Store √ºbertragen und dabei gewisse
Dateien herausfiltern.  N√§her will ich das hier nicht betrachten.
Die Dokumentation enth√§lt eine Warnung, die man vor dem Gebrauch
lesen und verstehen sollte.</p><h3 id="builtinsfindfile">builtins.findFile</h3>
<p>Weder in der Nix Repl noch im Handbuch dokumentiert.</p><h3 id="builtinsfloor">builtins.floor</h3>
<p>Liefert f√ºr eine Zahl <code>x</code> die n√§chste Ganzzahl <code>n</code> sodass <code>x &gt;= n</code>:</p><pre><code>nix-repl&gt; builtins.floor 1.5
1

nix-repl&gt; builtins.floor 1
1
</code></pre>
<h3 id="builtinsfoldl">builtins.foldl‚Äô</h3>
<p>Damit kann man eine Liste von Werten sozusagen ‚Äúzusammenfalten‚Äù
auf einen einzigen Wert, indem man sukzessive von links nach rechts
eine Funktion darauf anwendet, die jeweils zwei Werte mit einander
kombiniert.  Man muss einen Startwert mit √ºbergeben.  Ausgehend
von diesem Startwert werden sukzessive die Elemente der Liste
eingesammelt und mit dem bisherigen Zwischenergebnis kombiniert.</p><p>Hier wird eine Liste von Zahlen via <code>builtins.add</code> mit dem Startwert
<code>0</code> zusammengefaltet:</p><pre><code>nix-repl&gt; builtins.foldl&#39; builtins.add 0 [ 1 2 3 4 5 6 ]
21
</code></pre>
<p>Das entspricht einer Verallgemeinerung der zweiwertigen Addition
auf beliebig viele Werte.  Mit <code>builtins.foldl&#39;</code> lassen sich viele
zweiwertige Funktionen auf nat√ºrliche Weise verallgemeinern auf
beliebig viele Werte.  Das setzt nat√ºrlich voraus, dass es zu den
Werten, auf denen man operiert einen neutralen Wert gibt, also eine
Entsprechung zur Null bei den Zahlen.  Mathematisch ist so eine
Struktur artikuliert im algebraischen Begriff eines <em>Monoiden</em>.
Damit muss man sich aber nicht unbedingt befassen: in der Praxis
kann man auch einfach ein paar Werte mit <code>builtins.foldl&#39;</code>
zusammenstauchen, ohne sich vorher Gedanken dar√ºber zu machen,
ob man wirklich eine Null zur Verf√ºgung hat.</p><p>Das zweite <code>l</code> in <code>foldl</code> steht f√ºr <em>left</em>, weil von rechts nach
links gefaltet wird.  Nix stellt nur diese eine Funktion als Built-in
zur Verf√ºgung, aber im Allgemeinen gibt es auch Faltungsfunktionen
die von links nach rechts falten.  Die hei√üen dann typischerweise
<code>foldr</code>.  Bei der Addition macht das keinen Unterschied, aber bei
Funktionen, die nicht kommutativ sind ,bei denen also das Ergebnis
von der Reihenfolge der beiden Argumente abh√§ngt, h√§ngt auch das
Ergebnis einer Faltung davon ab, in welche Richtung gefaltet wird.</p><p>Das abschlie√üende Hochkomma im Namen <code>builtins.foldl&#39;</code>
soll anzeigen, dass diese Funktion strikt ausgewertet wird.
Ich bin weiter oben darauf eingegangen, dass Nix standardm√§√üig
verz√∂gert auswertet und dass man in manchen F√§llen lieber eine
strikte Auswertung haben m√∂chte.  Das hier ist ein solcher Fall.
Das Hochkomma ist nur eine Namenskonvention, die warscheinlich
daher r√ºhrt, dass man sich hier recht stark an Haskell orientiert.
In Haskell wertet die <code>foldl</code> Funktion aus der Standardbibliothek
verz√∂gert aus. Daneben gibt es auch eine mit Hochkomma markierte
<code>foldl&#39;</code> Funktion, die strikt auswertet.  In der Praxis will
man eigentlich immer eine strikte Faltung nach links, also w√§re
es vielleicht besser gewesen, die strikte Variante <code>foldl</code> (ohne
Hochkomma) zu nennen.  Schade, dass Nix sich an dieser ung√ºnstigen
Konvention orientiert, zumal ohnehin nur diese eine Faltungsfunktion
als Built-in mitgeliefert wird.</p><h3 id="builtinsfromjson">builtins.fromJSON</h3>
<p>Parst und √ºberf√ºhrt JSON-Werte in Nix-Werte:</p><pre><code>nix-repl&gt; builtins.fromJSON &quot;{ \&quot;a\&quot; : 1 , \&quot;b\&quot; : 2 , \&quot;c\&quot; : 3 }&quot;
{ a = 1; b = 2; c = 3; }

nix-repl&gt; builtins.fromJSON &quot;[ 1, 2, 3 ]&quot;
[ 1 2 3 ]

nix-repl&gt; builtins.fromJSON &quot;123.456&quot;
123.456

nix-repl&gt; builtins.fromJSON &quot;\&quot;asdf\&quot;&quot;
&quot;asdf&quot;
</code></pre>
<h3 id="builtinsfunctionargs">builtins.functionArgs</h3>
<p>Nimmt eine Funktion entgegen und liefert ein Set mit den Namen ihrer
Parameter als Schl√ºssel.  Die Werte geben f√ºr jeden Parameter
Auskunft dar√ºber, ob es zu ihm einen Standardwert gibt:</p><pre><code>nix-repl&gt; builtins.functionArgs ( { x , y ? 123 } : x + y )
{ x = false; y = true; }
</code></pre>
<p>Das Fragezeichen ist neue Syntax f√ºr mich.  Ziemlich weit am Anfang
dieses Dokumentes hatte ich Set Patterns erw√§hnt, die man verwenden
kann, um benannte Funktionsparameter aufzuschreiben:</p><pre><code>nix-repl&gt; ({a,b} : a + b) { a = 5 ; b = 6 ; }
11
</code></pre>
<p>Offenbar kann man mit dem Fragezeichen Standardargumente festhalten:</p><pre><code>nix-repl&gt; ({a?5,b?6} : a + b) {}
11

nix-repl&gt; ({a?5,b?6} : a + b) { a = 11 ; }
17

nix-repl&gt; ({a?5,b?6} : a + b) { b = 12 ; }
17

nix-repl&gt; ({a?5,b?6} : a + b) { a = 11 ; b = 12 ; }
23
</code></pre>
<p>Die sinnvolle Verwendung von <code>builtins.functionArgs</code> setzt nat√ºrlich
voraus, dass eine Funktion mit benannten Parametern via Set Patterns
aufgeschrieben worden ist.  F√ºr reine Lambda-Funktionen liefert
<code>builtins.functionArgs</code> immer ein leeres Set:</p><pre><code>nix-repl&gt; builtins.functionArgs ( a : b : a + b )
{ }
</code></pre>
<h3 id="builtinsgenlist">builtins.genList</h3>
<p><code>builtins.genlist f n</code> erzeugt eine Liste der L√§nge <code>n</code>, wobei
die Funktion <code>f</code> die jeweiligen Elemente aus den jeweiligen Indizes
berechnet:</p><pre><code>nix-repl&gt; builtins.genList ( x : -x ) 4
[ 0 -1 -2 -3 ]

nix-repl&gt; builtins.genList ( x : 1.0/(x+1) ) 4
[ 1 0.5 0.333333 0.25 ]
</code></pre>
<h3 id="builtinsgenericclosure">builtins.genericClosure</h3>
<p>Das ist eine eigenartig spezifische und zugleich eigenartig
allgemeine Funktion!  Sie erinnert mich ein bisschen an das M√§rchen
vom s√º√üen Brei.  Ich w√ºrde wirklich gern wissen, wof√ºr sie
gedacht ist.  Ich erkenne darin jedenfalls keine so klare und
universell brauchbare Abstraktion wie <code>map</code> oder <code>filter</code> oder
<code>foldl</code>.</p><p><code>builtins.genericClosure</code> nimmt ein Set mit den Schl√ºsseln
<code>startSet</code> und <code>operator</code> entgegen.  <code>startSet</code> ist eine
Liste mit Sets.  <code>operator</code> ist eine Funktion, die auf einem
Set operiert und daraus eine Liste von weiteren Sets erzeugt.
<code>builtins.genericClosure</code> verwendet ausgehend von der <code>startSet</code>
Liste die <code>operator</code> Funktion um rekursiv aus den bestehenden Sets
weitere Sets zu berechnen.  Alle hier erw√§hnten Sets (abgesehen
von dem √§u√üeren) m√ºssen einen Schl√ºssel <code>key</code> enthalten.
Alle Sets, mit einem <code>key</code> Wert, der schon einmal aufgetaucht
ist, werden verworfen.  Sobald keine Sets mit neuen <code>key</code> Werten
hinzukommen, endet die Rekursion.</p><p>Das ist ziemlich kompliziert.  Hier sind ein paar Beispiele.
Zun√§chst der einfachste Fall:</p><pre><code>nix-repl&gt; builtins.genericClosure
...         { startSet = [] ;
...           operator = s : [] ;
...         }
[ ]
</code></pre>
<p>Wir f√ºllen <code>startSet</code> mit ein paar Sets:</p><pre><code>nix-repl&gt; builtins.genericClosure
...         { startSet =
...             [ { key = 5 ; }
...               { key = 6 ; }
...               { key = 7 ; }
...             ] ;
...           operator = s : [] ;
...         }
[ { ... } { ... } { ... } ]
</code></pre>
<p>Die Auslassungpunkte kommen daher, dass die Nix Repl beim
Auswerten und beim Ausgeben der Ergebnisse maximal eine Ebene in
die Tiefe geht.  Bisher bin ich darauf nicht eingegangen, aber
das ist schon einmal vorgekommen, n√§mlich im Abschnitt <a href="#c1447d05c6ee4163ccfb5686d986ca8318492d7f"><em>Sets
(Mengen)</em></a> wo ich die
Kurznotation f√ºr verschachtelte Sets einf√ºhre.  Man erh√§lt die
Auslassungspunkte schon wenn man eine Liste in eine Liste steckt:</p><pre><code>nix-repl&gt; [[]]
[ [ ... ] ]
</code></pre>
<p>Die innere Liste ist leer, aber der Interpreter schaut gar nicht
erst hinein sondern gibt sie gleich mit den Auslassungspunkten aus.</p><p>Man kann die Nix Repl veranlassen, einen Ausdruck in voller Tiefe
auszuwerten und das Ergebnis in voller Tiefe auszugeben.  Daf√ºr muss
man dem auszuwertenden Ausdruck die Repl-Anweisung <code>:p</code> voranstellen.
Damit k√∂nnen wir uns wieder <code>builtins.genericClosure</code> zuwenden:</p><pre><code>nix-repl&gt; :p builtins.genericClosure
...             { startSet =
...                 [ { key = 5 ; }
...                   { key = 6 ; }
...                   { key = 7 ; }
...                 ] ;
...               operator = s : [] ;
...             }
[ { key = 5; } { key = 6; } { key = 7; } ]
</code></pre>
<p>Dass Sets, deren <code>key</code> schon einmal vorgekommen ist, verworfen
werden, gilt schon f√ºr die Sets in der <code>startSet</code> Liste:</p><pre><code>nix-repl&gt; :p builtins.genericClosure
...             { startSet =
...                 [ { key = 5 ; }
...                   { key = 6 ; }
...                   { key = 7 ; }
...                   { key = 5 ; }
...                 ] ;
...               operator = s : [] ;
...             }
[ { key = 5; } { key = 6; } { key = 7; } ]
</code></pre>
<p>Um die Wirkung der <code>operator</code> Funktion zu demonstrieren,
inkrementieren wir einfach die <code>key</code> Werte.  Damit
<code>built.genericClosure</code> trotzdem terminiert, m√ºssen wir das irgendwo
deckeln.  Ich schlage vor, wir belassen es bei <code>key &lt; 10</code>:</p><pre><code>nix-repl&gt; :p builtins.genericClosure
...             { startSet =
...                 [ { key = 5 ; }
...                   { key = 6 ; }
...                   { key = 7 ; }
...                   { key = 5 ; }
...                 ] ;
...               operator = s :
...                 [ { key =
...                         if s.key &lt; 9
...                         then s.key + 1
...                         else s.key ;
...                   }
...                 ] ;
...             }
[ { key = 5; } { key = 6; } { key = 7; } { key = 8; } { key = 9; } ]
</code></pre>
<p>Das hei√üt, wir inkrementieren den <code>key</code> Wert so lange er
kleiner als <code>9</code> ist.  Das Set mit <code>key = 9</code> wird noch erzeugt,
aber dar√ºber kommt nichts mehr.  Die Ausgabe ist so wie ich es
erwartet habe.  Ich glaube, ich habe damit vollst√§ndig erfasst,
was <code>builtins.genericClosure</code> macht.  Einen guten Anwendungsfall
daf√ºr habe ich nicht, aber zumindest den vagen Eindruck, dass man
damit etwas n√ºtzliches machen kann, vielleicht irgend etwas in
Richtung transitiver H√ºllen.</p><h3 id="builtinsgetattr">builtins.getAttr</h3>
<p>Liefert aus einem Set den Wert zu einem Schl√ºssel:</p><pre><code>nix-repl&gt; builtins.getAttr &quot;foo&quot; { foo = 123 ; }
123
</code></pre>
<p>Wenn es den Schl√ºssel nicht gibt, l√∂st das einen Fehler aus:</p><pre><code>nix-repl&gt; builtins.getAttr &quot;bar&quot; { foo = 123 ; }
error: attribute &#39;bar&#39; missing for call to &#39;getAttr&#39;
</code></pre>
<p>Das selbe kann man nat√ºrlich schon mit dem <code>.</code> Operator machen:</p><pre><code>nix-repl&gt; s = { foo = 123 ; }

nix-repl&gt; s.foo
123
</code></pre>
<p>Aber es gibt einen Unterschied: <code>builtins.getAttr</code> nimmt den
Schl√ºssel als String.  Dadurch kann man den Schl√ºssel dynamisch
konstruieren:</p><pre><code>nix-repl&gt; s = { foo = 123 ; }

nix-repl&gt; builtins.getAttr ( &quot;f&quot; + &quot;o&quot; + &quot;o&quot; ) s
123
</code></pre>
<p>Update: der <code>.</code> Operator akzeptiert auch Strings:</p><pre><code>nix-repl&gt; { foo = 123 ; }.&quot;foo&quot;
123
</code></pre>
<p>Aber dynamisch konstruieren kann man den Schl√ºssel trotzdem nicht:</p><pre><code>nix-repl&gt; { foo = 123 ; }.( &quot;f&quot; + &quot;o&quot; + &quot;o&quot; )
error: syntax error, unexpected &#39;(&#39;, ...

nix-repl&gt; { foo = 123 ; }.( &quot;foo&quot; )
error: syntax error, unexpected &#39;(&#39;, ...
</code></pre>
<h3 id="builtinsgetcontext">builtins.getContext</h3>
<p>Weder in der Nix Repl noch im Handbuch dokumentiert.</p><h3 id="builtinsgetenv-1">builtins.getEnv</h3>
<p>Liefert den Wert einer Umgebungsvariable als String:</p><pre><code>nix-repl&gt; builtins.getEnv &quot;HOME&quot;
&quot;/home/aramis&quot;
</code></pre>
<p>F√ºr fehlende Umgebungsvariable wird der leere String wird der
leere String gegeben:</p><pre><code>nix-repl&gt; builtins.getEnv &quot;sa0iboojav9ood5C&quot;
&quot;&quot;
</code></pre>
<h3 id="builtinsgetflake">builtins.getFlake</h3>
<p>L√§dt eine Nix Flake herunter und gibt ihre Attribute zusammen
mit ein paar Metadaten aus.</p><p>Flakes sind ein alternativer Mechanismus um Abh√§ngigkeiten zu
beschreiben und Software in den Nix Store herunterzuladen.
Nix Channels folgen in der Handhabung dem typischen
Paketverwaltungsmodell von Linux Distros:  Es gibt Kan√§le, in denen
versionierte Softwarepakete verf√ºgbar sind, die man bei Bedarf
herunterladen kann.  Um seine Software auf dem neusten Stand zu
halten, ruft man zun√§chst aus seinen Kan√§len Informationen zu
den aktuellen Versionen ab und installiert dann Updates f√ºr die
Software, die nicht mehr auf dem neusten Stand ist.</p><p>So sieht das f√ºr die Debian/Ubuntu Paketverwaltung aus:</p><pre><code>$ apt update            # Aktualisiere Kan√§le
$ apt upgrade           # Aktualisiere Softwarepakete
</code></pre>
<p>So sieht das f√ºr Nix aus:</p><pre><code>$ nix-channel --update  # Aktualisiere Kan√§le
$ nix-env --upgrade     # Aktualisiere Softwarepakete
</code></pre>
<p>Mit Debian/Ubuntu verwendet man <code>apt</code> f√ºr beide Schritte.  Mit Nix
verwendet man im ersten Schritt <code>nix-channel</code> und im zweiten Schritt
<code>nix-env</code>, aber an den Flags sieht man schon, mit wes Geistes Kind
man es hier zu tun hat.</p><p>Im Unterschied dazu, orientieren sich Flakes an Paketverwaltungen wie
Cargo (Rust) oder NPM (JS).  Es gibt keine Kan√§le.  Man deklariert
die Abh√§ngigkeiten einer Software als Git Repositories in einer
<code>flake.nix</code> Datei.  W√§hrend der Installation der Abh√§ngigkeiten
wird eine <code>flake.lock</code> Datei erzeugt, welche die Hashes der
verwendeten Git Commits protokolliert und dadurch die Abh√§ngigkeiten
sozusagen einfriert.</p><p>Flakes sind noch als experimentell markiert und m√ºssen in einer
Konfigurationsdatei aktiviert werden bevor sie verwendet werden
k√∂nnen:</p><pre><code>$ echo experimental-features = nix-command flakes  
    &gt;&gt; ~/.config/nix/nix.conf
</code></pre>
<p>Ich habe mir, √ºber das hier aufgeschriebene hinaus, Flakes noch
nicht genauer angeschaut.</p><h3 id="builtinsgroupby">builtins.groupBy</h3>
<p><code>builtings.groupBy f ls</code> gruppiert die Liste <code>ls</code> anhand der Funktion
<code>f</code>:</p><pre><code>nix-repl&gt; isEven = n : n / 2 == n / 2.0

nix-repl&gt; :p builtins.groupBy
...             ( n : toString ( isEven n ) ) [ 1 2 3 4 5 6 7 8 9 ]
{ &quot;&quot; = [ 1 3 5 7 9 ]; &quot;1&quot; = [ 2 4 6 8 ]; }
</code></pre>
<p>Dabei muss <code>f</code> stets einen String zur√ºckgeben.  Sonst funktioniert
das nicht:</p><pre><code>nix-repl&gt; :p builtins.groupBy isEven [ 1 2 3 4 5 6 7 8 9 ]
error: value is a Boolean while a string was expected
</code></pre>
<h3 id="builtinshasattr">builtins.hasAttr</h3>
<p>Pr√ºft ob ein Schl√ºssel in einem Set enthalten ist:</p><pre><code>nix-repl&gt; builtins.hasAttr &quot;foo&quot; {}
false

nix-repl&gt; builtins.hasAttr &quot;foo&quot; { foo = 123 ; }
true
</code></pre>
<p>Offenbar gibt es auch einen <code>?</code> Operator, der dasselbe macht:</p><pre><code>nix-repl&gt; {} ? &quot;foo&quot;
false

nix-repl&gt; { foo = 123 ; } ? &quot;foo&quot;
true
</code></pre>
<p>Der <code>?</code> Operator kann den zu pr√ºfenden Schl√ºssel nicht nur als
String sondern auch als einfachen Bezeichner verarbeiten:</p><pre><code>nix-repl&gt; { foo = 123 ; } ? foo
true

nix-repl&gt; {} ? foo
false
</code></pre>
<p>Der <code>?</code> Operator hat die selbe Beschr√§nkung wie der <code>.</code> Operator,
n√§mlich dass der Schl√ºssel nicht dynamisch erzeugt werden kann:</p><pre><code>nix-repl&gt; { foo = 123 ; } ? ( &quot;f&quot; + &quot;o&quot; + &quot;o&quot; )
error: syntax error, unexpected &#39;(&#39;, ...

nix-repl&gt; { foo = 123 ; } ? ( &quot;foo&quot; )
error: syntax error, unexpected &#39;(&#39;, ...
</code></pre>
<h3 id="builtinshascontext">builtins.hasContext</h3>
<p>Weder in der Nix Repl noch im Handbuch dokumentiert.</p><h3 id="builtinshashfile">builtins.hashFile</h3>
<p>Erzeugt einen Hash Wert aus einer Datei.  Erwartet werden zwei
Argumente.  Das erste Argument ist der Hash-Algorithmus.  M√∂glich
sind <code>&quot;md5&quot;</code>, <code>&quot;sha1&quot;</code>, <code>&quot;sha256&quot;</code> und <code>&quot;sha512&quot;</code>.  Das zweite
Argument ist der Pfad zur Datei.  Der Pfad kann als Nix Pfad oder
als String √ºbergeben werden.</p><pre><code>nix-repl&gt; builtins.hashFile &quot;md5&quot;
...         /nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524
&quot;ffab34ab46902e10183dc2a065e50ebd&quot;

nix-repl&gt; builtins.hashFile &quot;md5&quot;
...         &quot;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524&quot;
&quot;ffab34ab46902e10183dc2a065e50ebd&quot;

nix-repl&gt; builtins.hashFile &quot;sha1&quot;
...         /nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524
&quot;95936f2f3d784c7a90623acfbb9d093384f5a6a2&quot;

nix-repl&gt; builtins.hashFile &quot;sha1&quot;
...         &quot;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524&quot;
&quot;95936f2f3d784c7a90623acfbb9d093384f5a6a2&quot;
</code></pre>
<p>Die Funktion verarbeitet beliebige Pfade, auch au√üerhalb des Nix
Store.  Leider wei√ü ich jetzt immer noch nicht, was es mit dem Hash
<code>97ggi3ryxkvdljycw05nq82bgs6kdxcx</code> im Store Path auf sich hat.</p><h3 id="builtinshashstring">builtins.hashString</h3>
<p>Erzeugt einen Hash Wert aus einem String.  Erwartet werden
zwei Argumente.  Das erste Argument ist der Hash-Algorithmus.
M√∂glich sind <code>&quot;md5&quot;</code>, <code>&quot;sha1&quot;</code>, <code>&quot;sha256&quot;</code> und <code>&quot;sha512&quot;</code>.
Das zweite ist der zu verarbeitende String:</p><pre><code>nix-repl&gt; builtins.hashString &quot;md5&quot; &quot;foobar&quot;
&quot;3858f62230ac3c915f300c664312c63f&quot;
</code></pre>
<h3 id="builtinshead">builtins.head</h3>
<p>Liefert das erste Element einer Liste:</p><pre><code>nix-repl&gt; builtins.head [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ]
&quot;a&quot;
</code></pre>
<p>Wenn man sich das ganze im mathematichen Sinne als eine Abbildung von
der Menge aller Listen auf die Menge aller m√∂glichen Listenelemente
vorzustellen versucht, stellt man fest, dass es in der Sprechweise
der Schulmathematik eine m√∂gliche Definitionsl√ºcke gibt: n√§mlich
bei der leeren Liste:</p><pre><code>nix-repl&gt; builtins.head []
error: list index 0 is out of bounds
</code></pre>
<p>Die Fehlermeldung l√§sst vermuten, dass <code>builtins.head ls</code>
intern in <code>builtins.elemAt ls 0</code> √ºbersetzt wird.  Jedenfalls
l√∂st die Funktion f√ºr die leere Liste einen Fehler aus.  Es ist
strenggenommen nur eine partielle Funktion.  Das ist schade, wobei
ich hier noch mehr Verst√§ndnis daf√ºr habe als bei der <code>head</code>
Funktion aus der Haskell Standardbibliothek, die das gleiche
Problem hat.</p><h3 id="builtinsintersectattrs">builtins.intersectAttrs</h3>
<p>Erwartet zwei Sets und liefert ein Set mit den Schl√ºssel-Wert-Paaren
aus dem zweiten Set, deren Schl√ºssel auch im ersten Set vorkommen:</p><pre><code>nix-repl&gt; builtins.intersectAttrs
...         { a = 1 ; b = 2 ; } { b = 3 ; c = 4 ; }
{ b = 3; }
</code></pre>
<h3 id="builtinsisattrs">builtins.isAttrs</h3>
<p>Pr√ºft, ob es sich bei einem Wert um ein Set handelt:</p><pre><code>nix-repl&gt; builtins.isAttrs {}
true

nix-repl&gt; builtins.isAttrs 123
false
</code></pre>
<h3 id="builtinsisbool">builtins.isBool</h3>
<p>Pr√ºft, ob es sich bei einem Wert um einen boolschen Wert handelt:</p><pre><code>nix-repl&gt; builtins.isBool false
true

nix-repl&gt; builtins.isBool 123
false
</code></pre>
<h3 id="builtinsisfloat">builtins.isFloat</h3>
<p>Pr√ºft, ob es sich bei einem Wert um eine Flie√ükommazahl handelt:</p><pre><code>nix-repl&gt; builtins.isFloat 123.456
true

nix-repl&gt; builtins.isFloat 123
false
</code></pre>
<h3 id="builtinsisfunction">builtins.isFunction</h3>
<p>Pr√ºft, ob es sich bei einem Wert um eine Funktion handelt:</p><pre><code>nix-repl&gt; builtins.isFunction ( x : x )
true

nix-repl&gt; builtins.isFunction 123
false
</code></pre>
<h3 id="builtinsisint">builtins.isInt</h3>
<p>Pr√ºft, ob es sich bei einem Wert um eine Ganzzahl handelt:</p><pre><code>nix-repl&gt; builtins.isInt 123
true

nix-repl&gt; builtins.isInt &quot;123&quot;
false
</code></pre>
<h3 id="builtinsislist">builtins.isList</h3>
<p>Pr√ºft, ob es sich bei einem Wert um eine Liste handelt:</p><pre><code>nix-repl&gt; builtins.isList []
true

nix-repl&gt; builtins.isList 123
false
</code></pre>
<h3 id="builtinsispath">builtins.isPath</h3>
<p>Pr√ºft, ob es sich bei einem Wert um einen Nix Pfad handelt:</p><pre><code>nix-repl&gt; builtins.isPath ./.
true

nix-repl&gt; builtins.isPath 123
false
</code></pre>
<h3 id="builtinsisstring">builtins.isString</h3>
<p>Pr√ºft, ob es sich bei einem Wert um eine Zeichenkette (String)
handelt:</p><pre><code>nix-repl&gt; builtins.isString &quot;&quot;
true

nix-repl&gt; builtins.isString 123
false
</code></pre>
<h3 id="builtinslangversion">builtins.langVersion</h3>
<p>Undokumentiert.  Wahrscheinlich ist Nix (die Sprache) irgendwie
versioniert:</p><pre><code>nix-repl&gt; builtins.langVersion
6
</code></pre>
<h3 id="builtinslength">builtins.length</h3>
<p>Liefert die L√§nge einer Liste:</p><pre><code>nix-repl&gt; builtins.length [ &quot;a&quot; &quot;b&quot; &quot;c&quot; ]
3
</code></pre>
<h3 id="builtinslessthan">builtins.lessThan</h3>
<p>Die Funktion hinter dem <code>&lt;</code> Operator:</p><pre><code>nix-repl&gt; builtins.lessThan 3 4
true

nix-repl&gt; builtins.lessThan 4 3
false
</code></pre>
<h3 id="builtinslisttoattrs">builtins.listToAttrs</h3>
<p>Verarbeitet eine Liste von Sets mit Schl√ºsseln <code>name</code> und <code>value</code>
zu einem Set mit entsprechenden Schl√ºssel-Wert-Paaren:</p><pre><code>nix-repl&gt; builtins.listToAttrs
...         [ { name = &quot;foo&quot; ; value = 123 ; }
...           { name = &quot;bar&quot; ; value = 456 ; }
...         ]
{ bar = 456; foo = 123; }
</code></pre>
<h3 id="builtinsmapattrs">builtins.mapAttrs</h3>
<p>Eine Map-Funktion f√ºr Sets, die auf den Werten operiert und dabei
die Schl√ºssel ber√ºcksichtigen kann:</p><pre><code>nix-repl&gt; builtins.mapAttrs
...         ( k : v : k + &quot;:&quot; + builtins.toString v )
...         { a = 1 ; b = 2 ; c = 3 ; }
{ a = &quot;a:1&quot;; b = &quot;b:2&quot;; c = &quot;c:3&quot;; }
</code></pre>
<h3 id="builtinsmatch">builtins.match</h3>
<p>Erwartet einen regul√§ren Ausdruck und einen String.  Der regul√§re
Ausdruck kann RegEx-Gruppen enthalten.  Als Ergebnis liefert
<code>builtins.match</code> eine Liste der √úbereinstimmungen f√ºr diese
RegEx-Gruppen.  Ohne RegEx-Gruppen ist das Ergebnis nat√ºrlich die
leere Liste (bei √úbereinstimmung).  Wenn der String nicht auf den
regul√§ren Ausdruck passt, ist das Ergebnis <code>null</code>:</p><pre><code>nix-repl&gt; builtins.match &quot;foo&quot; &quot;bar&quot;
null

nix-repl&gt; builtins.match &quot;foo&quot; &quot;foo&quot;
[ ]

nix-repl&gt; builtins.match &quot;a(b)c(d)e&quot; &quot;abcde&quot;
[ &quot;b&quot; &quot;d&quot; ]
</code></pre>
<p>RegEx-Gruppen sind Teile eines regul√§ren Ausdrucks, die durch
Klammern hervorgehoben sind.  Man verwendet sie, um nicht nur zu
pr√ºfen ob ein String auf einen regul√§ren Ausdruck passt, sondern
auch Teile aus dem String zu extrahieren. Beispielsweise k√∂nnte man
einen regul√§ren Ausdruck f√ºr postalische Adressen konstruieren,
der die Stra√üe, die Hausnummer, die Postleitzahl und die Stadt
extrahiert.</p><h3 id="builtinsmul">builtins.mul</h3>
<p>Die Funktion hinter dem <code>*</code> Operator:</p><pre><code>nix-repl&gt; builtins.mul 3 5
15
</code></pre>
<h3 id="builtinsnixpath">builtins.nixPath</h3>
<p>Weder in der Nix Repl noch im Handbuch dokumentiert.</p><pre><code>nix-repl&gt; :p builtins.nixPath
[ { path = &quot;/home/aramis/.nix-defexpr/channels&quot;; prefix = &quot;&quot;; } ]
</code></pre>
<h3 id="builtinsnixversion">builtins.nixVersion</h3>
<p>Liefert die Nix Versionsnummer:</p><pre><code>nix-repl&gt; builtins.nixVersion
&quot;2.10.3&quot;
</code></pre>
<p>Die Nix Versionsnummer wird auch ausgegeben wenn man die Repl
startet:</p><pre><code>$ nix repl
Welcome to Nix 2.10.3. Type :? for help.

nix-repl&gt;
</code></pre>
<h3 id="builtinsparsedrvname">builtins.parseDrvName</h3>
<p>Zerlegt einen Paketbezeichner der Form <code>&lt;Name&gt;-&lt;Version&gt;</code> in den
Namen und die Version des Pakets auf.  Das Ergebnis wird als Set
mit den Schl√ºsseln <code>name</code> und <code>version</code> gegeben:</p><pre><code>nix-repl&gt; builtins.parseDrvName &quot;nix-0.12pre12876&quot;
{ name = &quot;nix&quot;; version = &quot;0.12pre12876&quot;; }
</code></pre>
<p>Die beiden Teile m√ºssen durch einen Bindestrich getrennt sein.
Die Version muss mit Ziffern beginnen.  Sonst ist mindestens einer
der beiden Werte der leere String:</p><pre><code>nix-repl&gt; builtins.parseDrvName &quot;&quot;
{ name = &quot;&quot;; version = &quot;&quot;; }

nix-repl&gt; builtins.parseDrvName &quot;foo123&quot;
{ name = &quot;foo123&quot;; version = &quot;&quot;; }

nix-repl&gt; builtins.parseDrvName &quot;foo-bar&quot;
{ name = &quot;foo-bar&quot;; version = &quot;&quot;; }

nix-repl&gt; builtins.parseDrvName &quot;foo-1bar&quot;
{ name = &quot;foo&quot;; version = &quot;1bar&quot;; }
</code></pre>
<h3 id="builtinspartition">builtins.partition</h3>
<p>Trennt die Spreu vom Weizen:</p><pre><code>nix-repl&gt; :p builtins.partition ( n : n &gt; 3 ) [ 1 2 3 4 5 6 ]
{ right = [ 4 5 6 ]; wrong = [ 1 2 3 ]; }
</code></pre>
<h3 id="builtinspath">builtins.path</h3>
<p>F√ºgt Daten zum Nix Store hinzu.  Die funktion nimmt ein Set
als Argument entgegen.  Nur der Schl√ºssel <code>path</code> ist Pflicht.
Hier sind alle Schl√ºssel:</p><ul>
<li><code>path</code>: der Pfad zu den Daten</li>
<li><code>name</code>: der Pfadname im Nix Store</li>
<li><code>filter</code>: die Funktion; filtert unerw√ºnschte Unterpfade heraus</li>
<li><code>recursive</code>:<ul>
<li><code>false</code>: f√ºgt den Pfad mit einem flachen Hash zum Store hinzu</li>
<li><code>true</code>: f√ºgt den Pfad mit einem Hash der NAR Serialisierung
zum Store hinzu</li>
</ul>
</li>
<li><code>sha256</code>: der zu erwartende Hash f√ºr die Daten in <code>path</code></li>
</ul>
<p>NAR steht f√ºr <em>Nix Archive</em>.  Das ist ein Serialisierungsformat
f√ºr Dateisystemobjekte (i.e. Dateien, Verzeichnisse, Symlinks).
NAR ist vergleichbar mit Archivformaten wie TAR und ZIP.
Allerdings kann es bei diesen Formaten f√ºr ein und dasselbe
Objekt mehrere g√ºltige Serialisierungen geben, zum Beispiel
weil die Reihenfolge der Serialisierung von Verzeichnisinhalten
nicht definiert ist oder weil eine variable Menge an F√ºllbytes
zwischen Segmenten der Serialisierung zul√§ssig ist oder weil
auch Zeitstempel mit in die Serialisierung aufgenommen werden.
Die Beziehung zwischen einem serialisierten Objekt und den Bytes
seiner Serialisierung hat somit keinen Abbildungscharakter.
Das macht diese Archivformate unbrauchbar wenn der Hash der
Serialisierung als Hash f√ºr das serialisierte Objekt geeignet
sein soll.  NAR ist speziell daf√ºr entwickelt worden,
Dateisystemobjekte f√ºr das Hashing zu serialisieren und
l√§sst keinen Implementierungsspielraum, der die Serialisierung
eines Dateisystemobjektes in verschiedene Bytefolgen gestatten
w√ºrde. (Quelle: <a href="https://edolstra.github.io/pubs/phd-thesis.pdf">https://edolstra.github.io/pubs/phd-thesis.pdf</a>)</p><p>F√ºgt Daten zum Nix Store hinzu.  Die funktion nimmt ein Set
als Argument entgegen.  Nur der Schl√ºssel <code>path</code> ist Pflicht.
Hier sind alle Schl√ºssel:</p><ul>
<li><code>path</code>: der Pfad zu den Daten</li>
<li><code>name</code>: der Pfadname im Nix Store</li>
<li><code>filter</code>: die Funktion; filtert unerw√ºnschte Unterpfade heraus</li>
<li><code>recursive</code>:<ul>
<li><code>false</code>: f√ºgt den Pfad mit einem flachen Hash zum Store hinzu</li>
<li><code>true</code>: f√ºgt den Pfad mit einem Hash der NAR Serialisierung
zum Store hinzu</li>
</ul>
</li>
<li><code>sha256</code>: der zu erwartende Hash f√ºr die Daten in <code>path</code></li>
</ul>
<p>NAR steht f√ºr <em>Nix Archive</em>.  Das ist ein Serialisierungsformat
f√ºr Dateisystemobjekte (i.e. Dateien, Verzeichnisse, Symlinks).
NAR ist vergleichbar mit Archivformaten wie TAR und ZIP.
Allerdings kann es bei diesen Formaten f√ºr ein und dasselbe
Objekt mehrere g√ºltige Serialisierungen geben, zum Beispiel
weil die Reihenfolge der Serialisierung von Verzeichnisinhalten
nicht definiert ist oder weil eine variable Menge an F√ºllbytes
zwischen Segmenten der Serialisierung zul√§ssig ist oder weil
auch Zeitstempel mit in die Serialisierung aufgenommen werden.
Die Beziehung zwischen einem serialisierten Objekt und den Bytes
seiner Serialisierung hat somit keinen Abbildungscharakter.
Das macht diese Archivformate unbrauchbar wenn der Hash der
Serialisierung als Hash f√ºr das serialisierte Objekt geeignet
sein soll.  NAR ist speziell daf√ºr entwickelt worden,
Dateisystemobjekte f√ºr das Hashing zu serialisieren und
l√§sst keinen Implementierungsspielraum, der die Serialisierung
eines Dateisystemobjektes in verschiedene Bytefolgen gestatten
w√ºrde. (Quelle: <a href="https://edolstra.github.io/pubs/phd-thesis.pdf">https://edolstra.github.io/pubs/phd-thesis.pdf</a>)</p><h3 id="builtinspathexists">builtins.pathExists</h3>
<p>Pr√ºft, ob ein Pfad im lokalen Dateisystem existiert:</p><pre><code>nix-repl&gt; builtins.pathExists /home/aramis
true

nix-repl&gt; builtins.pathExists /home/foo
false
</code></pre>
<p>Kann auch Strings verarbeiten:</p><pre><code>nix-repl&gt; builtins.pathExists &quot;/&quot;
true
</code></pre>
<p>Oben hatte ich ein paar Prozeduren aufgelistet, die Nix <em>impure</em>
machen.  Diese hier (und die nachfolgenden) h√§tte man auch mit
auflisten k√∂nnen.</p><p>Pr√ºft, ob ein Pfad im lokalen Dateisystem existiert:</p><pre><code>nix-repl&gt; builtins.pathExists /home/aramis
true

nix-repl&gt; builtins.pathExists /home/foo
false
</code></pre>
<p>Kann auch Strings verarbeiten:</p><pre><code>nix-repl&gt; builtins.pathExists &quot;/&quot;
true
</code></pre>
<p>Oben hatte ich ein paar Prozeduren aufgelistet, die Nix <em>impure</em>
machen.  Diese hier (und die nachfolgenden) h√§tte man auch mit
auflisten k√∂nnen.</p><h3 id="builtinsreaddir">builtins.readDir</h3>
<p>Liefert f√ºr einen Verzeichnispfad ein Set mit den
Verzeichnisinhalten als Schl√ºssel und den jeweiligen Dateitypen
als Werte:</p><pre><code>nix-repl&gt; builtins.readDir /home
{ aramis = &quot;directory&quot;; }
</code></pre>
<p>Die m√∂glichen Werte f√ºr den Dateityp sind  <code>&quot;regular&quot;</code>,
<code>&quot;directory&quot;</code>, <code>&quot;symlink&quot;</code> und <code>&quot;unknown&quot;</code>.</p><p>Liefert f√ºr einen Verzeichnispfad ein Set mit den
Verzeichnisinhalten als Schl√ºssel und den jeweiligen Dateitypen
als Werte:</p><pre><code>nix-repl&gt; builtins.readDir /home
{ aramis = &quot;directory&quot;; }
</code></pre>
<p>Die m√∂glichen Werte f√ºr den Dateityp sind  <code>&quot;regular&quot;</code>,
<code>&quot;directory&quot;</code>, <code>&quot;symlink&quot;</code> und <code>&quot;unknown&quot;</code>.</p><h3 id="builtinsreadfile">builtins.readFile</h3>
<p>Liefert den Inhalt einer Datei als String:</p><pre><code>$ echo hallo &gt; greeting.txt

$ nix repl
Welcome to Nix 2.10.3. Type :? for help.

nix-repl&gt; builtins.readFile ./greeting.txt
&quot;hallo\n&quot;
</code></pre>
<p>Liefert den Inhalt einer Datei als String:</p><pre><code>$ echo hallo &gt; greeting.txt

$ nix repl
Welcome to Nix 2.10.3. Type :? for help.

nix-repl&gt; builtins.readFile ./greeting.txt
&quot;hallo\n&quot;
</code></pre>
<h3 id="builtinsreplacestrings">builtins.replaceStrings</h3>
<p>Ersetzt alle Vorkommen eines Teilstrings:</p><pre><code>nix-repl&gt; builtins.replaceStrings [ &quot;o&quot; ] [ &quot;x&quot; ] &quot;foobar&quot;
&quot;fxxbar&quot;

nix-repl&gt; builtins.replaceStrings [ &quot;o&quot; &quot;a&quot; ] [ &quot;x&quot; &quot;y&quot; ] &quot;foobar&quot;
&quot;fxxbyr&quot;
</code></pre>
<p>Ersetzt alle Vorkommen eines Teilstrings:</p><pre><code>nix-repl&gt; builtins.replaceStrings [ &quot;o&quot; ] [ &quot;x&quot; ] &quot;foobar&quot;
&quot;fxxbar&quot;

nix-repl&gt; builtins.replaceStrings [ &quot;o&quot; &quot;a&quot; ] [ &quot;x&quot; &quot;y&quot; ] &quot;foobar&quot;
&quot;fxxbyr&quot;
</code></pre>
<h3 id="builtinssort">builtins.sort</h3>
<p>Sortiert eine Liste anhand einer Vergleichsfunktion:</p><pre><code>nix-repl&gt; builtins.sort
...         ( a : b : a &lt; b )
...         [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ]
[ 1 1 2 3 3 3 4 5 5 5 6 7 8 9 9 9 ]

nix-repl&gt; builtins.sort
...         ( a : b : a &gt; b )
...         [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ]
[ 9 9 9 8 7 6 5 5 5 4 3 3 3 2 1 1 ]
</code></pre>
<p>Sortiert eine Liste anhand einer Vergleichsfunktion:</p><pre><code>nix-repl&gt; builtins.sort ( a : b : a &lt; b ) [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ]
[ 1 1 2 3 3 3 4 5 5 5 6 7 8 9 9 9 ]

nix-repl&gt; builtins.sort ( a : b : a &gt; b ) [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ]
[ 9 9 9 8 7 6 5 5 5 4 3 3 3 2 1 1 ]
</code></pre>
<h3 id="builtinssplit">builtins.split</h3>
<p>Zerteilt einen String anhand eines regul√§ren Ausdrucks in
eine Liste.  Alles, was auf den regul√§ren Ausdruck passt,
wird als Trennzeichen behandelt.  Der regul√§re Ausdruck kann
RegEx-Gruppen enthalten.  An jeder Trennstelle wird eine Liste mit
den √úbereinstimmungen f√ºr die RegEx-Gruppen an dieser Stelle in
die Ergebnisliste aufgenommen.  Ohne RegEx-Gruppen werden an den
Trennstellen entsprechend leere Listen eingef√ºgt:</p><pre><code>nix-repl&gt; :p builtins.split &quot;a&quot; &quot;bacadaeafagahai&quot;
[ &quot;b&quot; [ ] &quot;c&quot; [ ] &quot;d&quot; [ ] &quot;e&quot; [ ] &quot;f&quot; [ ] &quot;g&quot; [ ] &quot;h&quot; [ ] &quot;i&quot; ]

nix-repl&gt; builtins.split &quot;a&quot; &quot;bcde&quot;
[ &quot;bcde&quot; ]
</code></pre>
<p>Siehe <a href="#a05994c6afa9711449ac4d8bfdd8b0eb9c1e4996"><code>builtins.match</code></a>
f√ºr mehr zu RegEx-Gruppen.</p><p>Zerteilt einen String anhand eines regul√§ren Ausdrucks in
eine Liste.  Alles, was auf den regul√§ren Ausdruck passt,
wird als Trennzeichen behandelt.  Der regul√§re Ausdruck kann
RegEx-Gruppen enthalten.  An jeder Trennstelle wird eine Liste mit
den √úbereinstimmungen f√ºr die RegEx-Gruppen an dieser Stelle in
die Ergebnisliste aufgenommen.  Ohne RegEx-Gruppen werden an den
Trennstellen entsprechend leere Listen eingef√ºgt:</p><pre><code>nix-repl&gt; :p builtins.split &quot;a&quot; &quot;bacadaeafagahai&quot;
[ &quot;b&quot; [ ] &quot;c&quot; [ ] &quot;d&quot; [ ] &quot;e&quot; [ ] &quot;f&quot; [ ] &quot;g&quot; [ ] &quot;h&quot; [ ] &quot;i&quot; ]

nix-repl&gt; builtins.split &quot;a&quot; &quot;bcde&quot;
[ &quot;bcde&quot; ]
</code></pre>
<p>Siehe <a href="#builtinsmatch"><code>builtins.match</code></a> f√ºr mehr zu RegEx-Gruppen.</p><h3 id="builtinssplitversion">builtins.splitVersion</h3>
<p>Teilt einen String, der eine (Software) Version darstellt, in seine
Bestandteile auf.  Ich bin mir nicht 100%ig sicher, aber ich denke,
die Trennstellen sind Punkte <code>.</code>, Bindestriche <code>-</code> und √úberg√§nge
zwischen Ziffern und Buchstaben:</p><pre><code>nix-repl&gt; builtins.splitVersion &quot;a.b-c123e&quot;
[ &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;123&quot; &quot;e&quot; ]
</code></pre>
<p>Teilt einen String, der eine (Software) Version darstellt, in seine
Bestandteile auf.  Ich bin mir nicht 100%ig sicher, aber ich denke,
die Trennstellen sind Punkte <code>.</code>, Bindestriche <code>-</code> und √úberg√§nge
zwischen Ziffern und Buchstaben:</p><pre><code>nix-repl&gt; builtins.splitVersion &quot;a.b-c123e&quot;
[ &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;123&quot; &quot;e&quot; ]
</code></pre>
<h3 id="builtinsstoredir">builtins.storeDir</h3>
<p>Undokumentiert.  Liefert den Pfad zum Nix Store als String:</p><pre><code>nix-repl&gt; builtins.storeDir
&quot;/nix/store&quot;
</code></pre>
<p>Undokumentiert.  Liefert den Pfad zum Nix Store als String:</p><pre><code>nix-repl&gt; builtins.storeDir
&quot;/nix/store&quot;
</code></pre>
<h3 id="builtinsstorepath">builtins.storePath</h3>
<p>Alles, was ein Programm ben√∂tigt, um gebaut zu werden, soll sich
im Nix Store befinden.  Entsprechend werden die Abh√§ngigkeiten,
die in Ableitungen (Derivations) deklariert sind, zun√§chst zum Nix
Store hinzugef√ºgt.  Das geschieht normalerweise auch dann, wenn
sich etwas schon im Nix Store befindet.  Mit <code>builtins.storePath</code>
kann man das vermeiden.</p><p>Alles, was ein Programm ben√∂tigt, um gebaut zu werden, soll sich
im Nix Store befinden.  Entsprechend werden die Abh√§ngigkeiten,
die in Ableitungen (Derivations) deklariert sind, zun√§chst zum Nix
Store hinzugef√ºgt.  Das geschieht normalerweise auch dann, wenn
sich etwas schon im Nix Store befindet.  Mit <code>builtins.storePath</code>
kann man das vermeiden.</p><h3 id="builtinsstringlength">builtins.stringLength</h3>
<p>Liefert die L√§nge eines Strings:</p><pre><code>nix-repl&gt; builtins.stringLength &quot;asdf&quot;
4
</code></pre>
<p>Liefert die L√§nge eines Strings:</p><pre><code>nix-repl&gt; builtins.stringLength &quot;asdf&quot;
4
</code></pre>
<h3 id="builtinssub">builtins.sub</h3>
<p>Die Funktion hinter dem <code>-</code> Operator:</p><pre><code>nix-repl&gt; builtins.sub 7 5
2
</code></pre>
<p>Die Funktion hinter dem <code>-</code> Operator:</p><pre><code>nix-repl&gt; builtins.sub 7 5
2
</code></pre>
<h3 id="builtinssubstring">builtins.substring</h3>
<p>Selbsterkl√§rend:</p><pre><code>nix-repl&gt; builtins.substring 0 3 &quot;nixos&quot;
&quot;nix&quot;
</code></pre>
<p>Selbsterkl√§rend:</p><pre><code>nix-repl&gt; builtins.substring 0 3 &quot;nixos&quot;
&quot;nix&quot;
</code></pre>
<h3 id="builtinstail">builtins.tail</h3>
<p>Liefert eine Liste ohne das erste Element:</p><pre><code>nix-repl&gt; builtins.tail [ 1 2 3 ]
[ 2 3 ]

nix-repl&gt; builtins.tail []
error: &#39;tail&#39; called on an empty list
</code></pre>
<p>Liefert eine Liste ohne das erste Element:</p><pre><code>nix-repl&gt; builtins.tail [ 1 2 3 ]
[ 2 3 ]

nix-repl&gt; builtins.tail []
error: &#39;tail&#39; called on an empty list
</code></pre>
<h3 id="builtinstofile-1">builtins.toFile</h3>
<p>Schreibt einen String in eine Datei im Nix Store und gibt den Pfad
dieser Datei zur√ºck:</p><pre><code>nix-repl&gt; builtins.toFile &quot;greeting&quot; &quot;hallo&quot;
&quot;/nix/store/8fday1j2s9rpc28yirwbjp59a1wr3rx3-greeting&quot;
</code></pre>
<p>Die Datei kann dann beispielsweise als Input f√ºr Derivationen
verwendet werden.  Damit lassen sich beispielsweise Build Skripte
inline unterbringen.</p><h3 id="builtinstojson">builtins.toJSON</h3>
<p>√úbersetzt einen Nix Ausdruck in sein Json √Ñquivalent, aber mit
ein paar effektvollen Besonderheiten.  Strings, Integers, Floats,
Bools, null und Listen werden einfach in ihr Json √Ñquivalent
√ºbersetzt.  Nix Sets werden zu Json Objekten.  Davon ausgenommen
sind Derivationen: die werden in den entsprechenden Ausgabepfad
√ºbersetzt (als Json String).  Nix Paths werden in den Nix Store
kopiert und zu ihrem Zielpfad evaluiert (als Json String).</p><pre><code>nix-repl&gt; builtins.toJSON /home/aramis/todo.txt
&quot;\&quot;/nix/store/dmj65s7zfyzzypymaihy8yd1mrdz27pm-todo.txt\&quot;&quot;

nix-repl&gt; builtins.toJSON 123
&quot;123&quot;

nix-repl&gt; builtins.toJSON &quot;123&quot;
&quot;\&quot;123\&quot;&quot;

nix-repl&gt; builtins.toJSON []
&quot;[]&quot;

nix-repl&gt; builtins.toJSON {}
&quot;{}&quot;
</code></pre>
<p>Ich frage mich, wie hier unterschieden wird zwischen Derivationen
und anderen Sets.</p><h3 id="builtinstopath">builtins.toPath</h3>
<p>DEPRECATED.</p><p>Man soll stattdessen f√ºr absolute Pfade <code>/. + &quot;/path&quot;</code> und f√ºr
relative Pfade <code>./. + &quot;/path&quot;</code> verwenden.</p><h3 id="builtinstoxml">builtins.toXML</h3>
<p>√úbersetzt einen Nix Ausdruck in eine XML Darstellung:</p><pre><code>nix-repl&gt; builtins.toXML 123
&quot;&quot;&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;
&lt;expr&gt;
  &lt;int value=\&quot;123\&quot; /&gt;
&lt;/expr&gt;
&quot;&quot;&quot;

nix-repl&gt; builtins.toXML &quot;123&quot;
&quot;&quot;&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;
&lt;expr&gt;
  &lt;string value=\&quot;123\&quot; /&gt;
&lt;/expr&gt;
&quot;&quot;&quot;

nix-repl&gt; builtins.toXML []
&quot;&quot;&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;
&lt;expr&gt;
  &lt;list&gt;
  &lt;/list&gt;
&lt;/expr&gt;
&quot;&quot;&quot;

nix-repl&gt; builtins.toXML {}
&quot;&quot;&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;
&lt;expr&gt;
  &lt;attrs&gt;
  &lt;/attrs&gt;
&lt;/expr&gt;
&quot;&quot;&quot;
</code></pre>
<p>Das ist daf√ºr da, mit einem Build Script auf eine strukturiertere
Weise Daten auszutauschen als es allein mit Umgebungsvariablen
m√∂glich ist.</p><p>Irgendwie verursacht XML in mir so etwas wie PTSD.</p><h3 id="builtinstraceverbose">builtins.traceVerbose</h3>
<p>Wenn die Flag <code>--trace-verbose</code> aktiv ist, entspricht
ein Aufruf von <code>builtins.trace</code> einem Aufruf von
<a href="#cea058c12c239c26bf1984ea9ae775625dd569ac"><code>builtins.trace</code></a>:</p><pre><code>$ nix repl --trace-verbose
Welcome to Nix 2.10.3. Type :? for help.

nix-repl&gt; builtins.traceVerbose [ 1 2 3 ] &quot;foo&quot;
trace: [ 1 2 3 ]
&quot;foo&quot;
</code></pre>
<p>Ohne die Flag wertet <code>builtins.traceVerbose e1 e2</code> einfach nur zu
<code>e2</code> aus:</p><pre><code>$ nix repl
Welcome to Nix 2.10.3. Type :? for help.

nix-repl&gt; builtins.traceVerbose [ 1 2 3 ] &quot;foo&quot;
&quot;foo&quot;
</code></pre>
<h3 id="builtinstryeval">builtins.tryEval</h3>
<p>Darauf gehe ich im Abschnitt
<a href="#e5969e35d6245cb82705919ad4a5065f5e4329ff">Fehler</a> ein.</p><h3 id="builtinstypeof">builtins.typeOf</h3>
<p>Liefert einen String, der den Datentyp eines Ausdrucks bezeichnet.
Die Datentypen sind <code>&quot;int&quot;</code>, <code>&quot;bool&quot;</code>, <code>&quot;string&quot;</code>, <code>&quot;path&quot;</code>,
<code>&quot;null&quot;</code>, <code>&quot;set&quot;</code>, <code>&quot;list&quot;</code>, <code>&quot;lambda&quot;</code> und <code>&quot;float&quot;</code>:</p><pre><code>nix-repl&gt; builtins.typeOf 0
&quot;int&quot;

nix-repl&gt; builtins.typeOf false
&quot;bool&quot;

nix-repl&gt; builtins.typeOf &quot;&quot;
&quot;string&quot;

nix-repl&gt; builtins.typeOf /.
&quot;path&quot;

nix-repl&gt; builtins.typeOf null
&quot;null&quot;

nix-repl&gt; builtins.typeOf {}
&quot;set&quot;

nix-repl&gt; builtins.typeOf []
&quot;list&quot;

nix-repl&gt; builtins.typeOf ( x : x )
&quot;lambda&quot;

nix-repl&gt; builtins.typeOf 0.0
&quot;float&quot;
</code></pre>
<h3 id="builtinsunsafediscardoutputdependency">builtins.unsafeDiscardOutputDependency</h3>
<p>Undokumentiert.</p><h3 id="builtinsunsafediscardstringcontext">builtins.unsafeDiscardStringContext</h3>
<p>Undokumentiert.</p><h3 id="builtinsunsafegetattrpos">builtins.unsafeGetAttrPos</h3>
<p>Undokumentiert.</p><h3 id="builtinszipattrswith">builtins.zipAttrsWith</h3>
<p>Das ist wieder so eine Funktion, die etwas ausf√ºhrlicher beschrieben
werden muss.</p><p>Sie nimmt eine zweiwertige Funktion <code>f</code> und eine Liste von
Sets entgegen.  Aus den Sets werden zun√§chst die Werte f√ºr die
jeweiligen Schl√ºssel in Listen gesammelt.  Aus den Schl√ºsseln und
den zugeh√∂rigen Listen wird ein Set erstellt.  Auf dieses Set wird
<code>builtins.mapAttrs f</code> angewendet.</p><p>Schauen wir uns das zun√§chst mit einer neutralen Funktion <code>f</code> an:</p><pre><code>nix-repl&gt; :p builtins.zipAttrsWith
...             ( k : v : v )
...             [ { x = 1 ; y = 2 ; }
...               { x = 3 ; y = 4 ; z = 5 ; }
...             ]
{ x = [ 1 3 ]; y = [ 2 4 ]; z = [ 5 ]; }
</code></pre>
<p>Ich denke, hier sieht man ganz gut, was vor sich geht: alle
Schl√ºssel werden eingesammelt und f√ºr jeden Schl√ºssel werden
die zugeh√∂rigen Werte in Listen akkumuliert.  Diese Listen
sind naturgem√§√ü nichtleer (sonst g√§be es keinen zugeh√∂rigen
Schl√ºssel).</p><p>Wir k√∂nnen dann mit <code>f</code> auf diesen Listen operieren.  Beispielsweise
k√∂nnen wir z√§hlen, wie oft jeder Schl√ºssel vorkommt:</p><pre><code>nix-repl&gt; :p builtins.zipAttrsWith
...             ( k : v : builtins.length v )
...             [ { x = 1 ; y = 2 ; }
...               { x = 3 ; y = 4 ; z = 5 ; }
...             ]
{ x = 2; y = 2; z = 1; }
</code></pre>
<p>Oder wir finden den jeweils gr√∂√üten Wert f√ºr jeden Schl√ºssel.
Daf√ºr bauen wir uns zun√§chst eine <code>max</code> Funktion f√ºr nichtnegative
Zahlen:</p><pre><code>nix-repl&gt; max = ls :
...         builtins.foldl&#39;
...             ( a : b : if a &gt; b then a else b )
...             0
...             ls

nix-repl&gt; max [ 1 2 3 4 5 4 3 2 1 ]
5
</code></pre>
<p>Damit k√∂nnen wir die gr√∂√üten Schl√ºssel finden:</p><pre><code>nix-repl&gt; :p builtins.zipAttrsWith
...             ( k : v : max v )
...             [ { x = 1 ; y = 2 ; }
...               { x = 3 ; y = 4 ; z = 5 ; }
...             ]
{ x = 3; y = 4; z = 5; }
</code></pre>
<hr>
<p>Damit ist meine erste Erkundung der Nix Expression Language
abgeschlossen.  Vielleicht gibt es hier und da noch einen
unbeleuchteten Aspekt, aber im gro√üen und ganzen habe ich
einen guten √úberblick und ein gutes Gef√ºhl f√ºr die Sprache.
Syntaktisch erinnert sie mich weniger an Haskell aber vielleicht
ein bisschen an OCaml und an Coqs Gallina Sprache.  Semantisch sind
wir eher im Erlang/Ruby/JavaScript-Land: dynamische Typisierung,
polymorphe Listen usw.</p><p>Damit kann ich Nix (die Sprache) zun√§chst abhaken.  Als n√§chstes
arbeite ich G. Gonzalez‚Äô Vortrag <em>Nix: under the hood</em> durch,
um den Nix Store und die Nix CLI-Befehle besser kennenzulernen.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Digital Gardening</title>
        <author>
            <name>Aram√≠s Concepci√≥n Dur√°n</name>
        </author>
        <link href="https://nojs.de/digital-gardening/"/>
        <id>https://nojs.de/digital-gardening/</id>

        <updated>2022-11-30T09:13:00+01:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>Online kursierte vor einiger Zeit unter dem Schlagwort <em>Digital
Gardening</em> eine alternative Vision f√ºr das Web jenseits des
sequentiellen Publizierens √† la Twitter, Instagram, Weblog und so
weiter: statt fertige, datierte Inhalte online zu stellen und Hot
Takes in den Socials zu posten, k√∂nnen wir im Web Wissensammlungen
anfertigen.  Allgemein oder thematisch, lose oder strukturiert,
allein oder kollaborativ ‚Äî die M√∂glichkeiten sind zahlreich und
es gibt dabei keinen Zwang zur Tagesaktualit√§t und Reichweite.</p><p>Die Idee ist genaugenommen keine neue.  Solche Inhalte haben fr√ºher
einen gro√üen Teil des Web ausgemacht.  Dann haben Google, Facebook
usw. das Web √ºbernommen und daraus eine Einkaufspromenade gemacht.
Aber jetzt scheint eine neue Generation die alten Freiheitsgrade
wiederzuentdecken.  Neben dem urspr√ºnglichen World Wide Web m√ºsste
eine Genealogie des Digital Gardening mindestens auch die folgenden
Wegsteine enthalten.</p><p><strong>Niklas Luhmanns Zettelkasten.</strong>  Luhmann hat Hypertext
handschritlich auf nummerierten Karteikarten so produktiv gemacht
wie kein zweiter und auf dieser Basis eine umfassende Theorie
der Gesellschaft erarbeitet.  Luhmanns Lebenswerk zeigt, dass
textvermitteltes Denken effektiv und effizient ist, wenn verf√ºgbare
und bew√§hrte Werkzeuge mit Disziplin, Kontinuit√§t und Geschick
eingesetzt werden.</p><p><strong>ToDo Apps und Note Taking Apps.</strong>  Evernote, Org Mode, Roam
Research, Obsidian, Logseq: beim Einsatz solcher Anwendungen muss
man aufpassen: es bedarf einer echten Aufgabe, eines konkreten
Ziels oder irgendeiner anderen Substanz, an der sich die ToDos und
Notes ausrichten.  Sonst bleibt das ganze Note Taking und ToDoing
rein mastorbatorisch.  Es ist nicht schwer, in diese Falle zu
tappen, der Software die Schuld daf√ºr zu geben und gleich die
n√§chste auszuprobieren.  So dreht man sich nur im Kreis ohne je
sinnstiftende Arbeit zu verrichten.</p><p><strong>Digital Humanities.</strong>  Dagegen sind die Wikis, digitalen Archive
und Online-Editionen der Digitial Humanities echte Bem√ºhungen,
einen digitalen Bestand an Texten und anderen medialen Artefakten
aufzubauen, hypertextuell zu verflechten und f√ºr die Wissenschaften
produktiv zu machen oder der breiteren √ñffentlichkeit zur Verf√ºgung
zu stellen.</p><p><strong>Engelbarts Dynamic Knowledge Repository.</strong>  Neben der Computermaus
geht auf Douglas Engelbart die Vorstellung zur√ºck, dass der
Computer ‚Äì wenn wir ihn richtig einsetzen ‚Äì unsere kollektive
Intelligenz exponentiell steigern wird.  Zentral ist dabei die Idee
eines Wissensspeichers, der nicht nur einen statischen Wissensvorrat
enth√§lt, sondern durch eine dialoghafte Interaktion zwischen Mensch
und Computer zu einem Katalysator f√ºr das Denken wird.</p><p>F√ºr die meisten von uns wird Digital Gardening bescheidener und
pers√∂nlicher sein, so auch f√ºr mich: wenn ich etwas, lerne,
lese, konstruiere, ein Problem bearbeite usw.: dann fertige ich
dazu gern Notizen an und versuche, sie so zu verlinken, dass ich
sie im passenden Arbeitskontext wiederfinden kann.  Die Datenbasis
daf√ºr sind Textdateien in einem Git-versionierten Verzeichnis.
In diesem Garten gedeihen vielf√§ltige Gew√§chse: Stichwortlisten,
Linksammlungen, Protokolle, HowTos, Zusammenfassungen, Taxonomien,
und manchmal auch Texte wie dieser.</p><p><strong>Links zum Thema</strong></p><ul>
<li><a href="https://maggieappleton.com/garden-history">A Brief History of Digital Gardens</a></li>
<li><a href="https://stackingthebricks.com/how-blogs-broke-the-web/">How the Blog Broke the Web</a></li>
<li><a href="https://www.youtube.com/watch?v=ckv_CjyKyZY">The Garden and the Stream: a Technopastoral</a></li>
<li><a href="https://www.theatlantic.com/magazine/archive/1945/07/as-we-may-think/303881/">As We May Think</a></li>
</ul>

            ]]>
        </content>
    </entry>
</feed>
