<!DOCTYPE html><html lang="de"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JSON-Serialisierung von LINQ-Expressions - Aramís Concepción Durán</title><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://nojs.de/json-serialisierung-von-linq-expressions/"><link rel="alternate" type="application/atom+xml" href="https://nojs.de/feed.xml" title="Aramís Concepción Durán - RSS"><link rel="alternate" type="application/json" href="https://nojs.de/feed.json" title="Aramís Concepción Durán - JSON"><meta property="og:title" content="JSON-Serialisierung von LINQ-Expressions"><meta property="og:site_name" content="Aramís Concepción Durán"><meta property="og:description" content=""><meta property="og:url" content="https://nojs.de/json-serialisierung-von-linq-expressions/"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://nojs.de/media/website/59de3f1dd701ffa954c008012966b9d97d6911b5.png" type="image/x-icon"><link rel="stylesheet" href="https://nojs.de/assets/css/style.css?v=11bee19e86e8eda2cf9a60efd975666d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://nojs.de/json-serialisierung-von-linq-expressions/"},"headline":"JSON-Serialisierung von LINQ-Expressions","datePublished":"2025-05-11T10:35+02:00","dateModified":"2025-05-11T21:10+02:00","description":"","author":{"@type":"Person","name":"Aramís Concepción Durán","url":"https://nojs.de/authors/aramis-concepcion-duran/"},"publisher":{"@type":"Organization","name":"Aramís Concepción Durán"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://nojs.de/">Aramís Concepción Durán</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>JSON-Serialisierung von LINQ-Expressions</h1><div class="feed__meta content__meta"><time datetime="2025-05-11T10:35" class="feed__date">2025-05-11</time></div></div></header></div><div class="entry-wrapper content__entry"><p>Ich sehe hin und wieder C# Code, der via <a href="https://www.nuget.org/packages/mongodb.driver">MongoDB.Driver</a> Daten aus MongoDB-Collections aggregiert, aufgerufen über eine Web-API und eine vorgeschaltete Connector-Klasse mit statischen Wrapper-Methoden für die Bedienung der API-Endpunkte.</p><p>Wenn die Daten nicht nur paginiert sondern auch gefiltert werden sollen, stellt sich natürlich die Frage, wie man auf dem Hinweg das Filterkriterium kodiert und serialisiert. Bisher habe ich die folgende Antwort gesehen: ad-hoc ein DTO zusammenstricken, das jeweils eine Property enthält für die konkreten Filteroptionen, die jetzt (oder vielleicht später) benötigt werden. Ein Gedanke dabei ist sicherlich, dass man dieses Datentransferobjekt im Nachhinein erweitern kann sobald neue Filteranforderungen auftauchen.</p><p>Für die Posts in einem Blog könnte das so aussehen:</p><pre><code>Class PostsRequest
{
    string? Author { get; set; }
    DateTime? MinCreated { get; set; }
    List&lt;string&gt;? Tags { get; set; }
}
</code></pre><p>Der Controller-Code nimmt dieses Objekt entgegen und konstruiert daraus einen Filter für die Aggregation der Daten:</p><ol><li>Erzeuge einen leeren Filter.</li><li>Wenn <code>r.Author is not null</code>, füge <code>x =&gt; x.Author == r.Author</code> hinzu.</li><li>Wenn <code>r.MinCreated is not null</code>, füge <code>x =&gt; x.Created &gt;= r.MinCreated</code> hinzu.</li><li>Wenn <code>r.Tags.IsNotNullOrEmpty()</code>, füge <code>x.Tags.Contains(r.Tags)</code> hinzu (oder so ähnlich).</li></ol><p>Aber was ist wenn ich mehrere Authoren angeben möchte? Dann muss <code>PostsRequest</code> entsprechend angepasst und <code>Author</code> von <code>string?</code> auf <code>List&lt;string&gt;?</code> umgestellt werden. Der Server-Code, der den eigentlichen Filter konstruiert, muss dafür ebenfalls angepasst werden. Bekomme ich dann die Posts jeweils aller angegebenen Authoren? Oder nur die Posts, die von allen angegebenen Authoren gemeinsam verfasst wurden? Oder beides? Hoffentlich ist <code>PostsRequest</code> entsprechend dokumentiert. Hoffentlich passt die Dokumentation zur tatsächlichen Implementierung des Filters. Hoffentlich hat niemand im Nachhinein den Filter verändert und dabei vergessen, auch die Dokumentation anzupassen. Was ist wenn ich alle obigen Fälle benötige? Füge ich dann Properties für alle Fälle zu <code>PostsRequest</code> hinzu? Oder eine Art Steuer-Property, die festlegt, wie <code>r.Author</code> vom Server-Code zu interpretieren ist? Was ist wenn ich <code>MaxCreated</code> benötige? Oder <code>MinCreated</code> aber nicht inklusiv sondern exklusiv? Was ist wenn ich ein noch komplexeres Filterkriterium benötige?</p><p>Dieser Ansatz ist die reine Hölle. Er verkompliziert und verengt eine Sache, die eigentlich eine sehr simple und allgemeine Lösung haben sollte: ich gebe der Connector-Methode ein Prädikat <code>Func&lt;Post, bool&gt;</code> und sie holt mir Einträge vom Typ <code>Post</code> aus der Datenbank, die auf dieses Prädikat passen!</p><p>Damit verschwindet die ganze Sperrigkeit des <code>PostsRequest</code> Ansatzes, weil ich als Aufrufer der Connector-Methode selbst mein Filterprädikat angebe, und zwar in der allgemeinen Form <code>Func&lt;Post,bool&gt;</code>, ohne durch die unpassende Struktur und Semantik eines Request-Datentyps eingeschränkt zu sein; ohne raten zu müssen, was der eigentliche Filter-Code macht, der sich hinter der API auf dem Server versteckt; ohne dass der serverseitige Filter-Code immer wieder angepasst werden muss.</p><p>Die Sache hat natürlich einen Haken, der wahrscheinlich auch der Grund dafür sein wird, dass ich stattdessen Request-DTOs sehe: Wie serialisiert man eigentlich eine <code>Func&lt;Post, bool&gt;</code> um sie via HTTP an eine Web-API zu übertragen und auf der Gegenseite korrekt wieder zu deserialisieren? 🤔</p><p>Es gibt dafür tatsächlich eine Lösung. Die <code>FilterDefinitionBuilder</code> Klasse in <code>MongoDB.Driver</code> exponiert eine <code>Where</code> Methode:</p><pre><code>public FilterDefinition&lt;T&gt; Where(Expression&lt;Func&lt;T, bool&gt;&gt; expression)
</code></pre><p>Damit können wir aus einer <code>Expression&lt;Func&lt;Post, bool&gt;&gt;</code> eine <code>FilterDefinition&lt;Post&gt;</code> erzeugen, die der MongoDB-Treiber in seiner Aggregation verwenden kann. Dabei repräsentiert <code>Expression&lt;Func&lt;Post, bool&gt;&gt;</code> einen AST für den unkompilierten Code einer Funktion <code>Func&lt;Post, bool&gt;</code>. Ein AST bringt uns der Serialisierung schon ein ganzes Stück näher. Allerdings kommt das ASP.NET Model Binding mit diesem Datentyp nicht zurecht.</p><p>Immerhin müssen wir den Serializer nicht selbst schreiben. Sascha Kiefer war so freundlich, dafür das NuGet-Paket <a href="https://www.nuget.org/packages/Serialize.Linq">Serialize.Linq</a> bereitzustellen. Wir müssen lediglich im Connector-Code unsere Expression serialisieren bevor wie sie übertragen, bzw. im Controller-Code händisch den <code>Request.Body</code> auslesen und deserialisieren:</p><pre><code>// Connector

Expression&lt;Func&lt;T, bool&gt;&gt; expression = x =&gt; pred(x);

ExpressionSerializer expressionSerializer =
    new Serialize.Linq.Serializers.ExpressionSerializer(
        new Serialize.Linq.Serializers.JsonSerializer()
    );

var expressionPayload =
    expressionSerializer.SerializeText(expression);

// Controller

string expressionPayload =
    await new StreamReader(Request.Body).ReadToEndAsync();

ExpressionSerializer expressionSerializer =
    new Serialize.Linq.Serializers.ExpressionSerializer(
        new Serialize.Linq.Serializers.JsonSerializer()
    );

var expression =
    (Expression&lt;Func&lt;T, bool&gt;&gt;)
    expressionSerializer.DeserializeText(expressionPayload);
</code></pre><p>Damit spart man sich einen großen Haufen sperrigen Behelfs-Boilerplate-Code für DTOs und serverseitige Filterkonstruktion. Gleichzeitig behält man alle Freiheitsgrade eines allgemeinen logischen Prädikates.</p><p>Allerdings muss man dabei ein bisschen aufpassen: der MongoDB-Treiber unterstützt keine beliebigen Expressions. Er unterstützt alle Logik, die man braucht, um ein Filterprädikat zu formulieren, aber keinen beliebigen C#-Code, der sich prinzipiell nicht nach MongoDB übersetzen lässt, wie z.B. <code>DateTime.Now</code> oder <code>Guid.NewGuid()</code> oder Inline-Funktionen.</p></div><footer class="content__footer"><div class="entry-wrapper"><div class="content__actions"></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://nojs.de/tschuessi-mc-post/" class="content__nav-link" rel="prev"><div><span>Previous</span> Tschüssi, MC Post!</div></a></div></div></div></nav></footer></article></main><footer class="footer"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://nojs.de/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://nojs.de/assets/js/scripts.min.js?v=ffcbea6c02c8178d10092962b235a5b0"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>