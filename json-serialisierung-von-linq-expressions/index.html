<!DOCTYPE html><html lang="de"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JSON-Serialisierung von LINQ-Expressions - Aram칤s Concepci칩n Dur치n</title><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://nojs.de/json-serialisierung-von-linq-expressions/"><link rel="alternate" type="application/atom+xml" href="https://nojs.de/feed.xml" title="Aram칤s Concepci칩n Dur치n - RSS"><link rel="alternate" type="application/json" href="https://nojs.de/feed.json" title="Aram칤s Concepci칩n Dur치n - JSON"><meta property="og:title" content="JSON-Serialisierung von LINQ-Expressions"><meta property="og:site_name" content="Aram칤s Concepci칩n Dur치n"><meta property="og:description" content=""><meta property="og:url" content="https://nojs.de/json-serialisierung-von-linq-expressions/"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://nojs.de/media/website/59de3f1dd701ffa954c008012966b9d97d6911b5.png" type="image/x-icon"><link rel="stylesheet" href="https://nojs.de/assets/css/style.css?v=11bee19e86e8eda2cf9a60efd975666d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://nojs.de/json-serialisierung-von-linq-expressions/"},"headline":"JSON-Serialisierung von LINQ-Expressions","datePublished":"2025-05-11T10:35+02:00","dateModified":"2025-05-11T21:10+02:00","description":"","author":{"@type":"Person","name":"Aram칤s Concepci칩n Dur치n","url":"https://nojs.de/authors/aramis-concepcion-duran/"},"publisher":{"@type":"Organization","name":"Aram칤s Concepci칩n Dur치n"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://nojs.de/">Aram칤s Concepci칩n Dur치n</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>JSON-Serialisierung von LINQ-Expressions</h1><div class="feed__meta content__meta"><time datetime="2025-05-11T10:35" class="feed__date">2025-05-11</time></div></div></header></div><div class="entry-wrapper content__entry"><p>Ich sehe hin und wieder C# Code, der via <a href="https://www.nuget.org/packages/mongodb.driver">MongoDB.Driver</a> Daten aus MongoDB-Collections aggregiert, aufgerufen 칲ber eine Web-API und eine vorgeschaltete Connector-Klasse mit statischen Wrapper-Methoden f칲r die Bedienung der API-Endpunkte.</p><p>Wenn die Daten nicht nur paginiert sondern auch gefiltert werden sollen, stellt sich nat칲rlich die Frage, wie man auf dem Hinweg das Filterkriterium kodiert und serialisiert. Bisher habe ich die folgende Antwort gesehen: ad-hoc ein DTO zusammenstricken, das jeweils eine Property enth칛lt f칲r die konkreten Filteroptionen, die jetzt (oder vielleicht sp칛ter) ben칬tigt werden. Ein Gedanke dabei ist sicherlich, dass man dieses Datentransferobjekt im Nachhinein erweitern kann sobald neue Filteranforderungen auftauchen.</p><p>F칲r die Posts in einem Blog k칬nnte das so aussehen:</p><pre><code>Class PostsRequest
{
    string? Author { get; set; }
    DateTime? MinCreated { get; set; }
    List&lt;string&gt;? Tags { get; set; }
}
</code></pre><p>Der Controller-Code nimmt dieses Objekt entgegen und konstruiert daraus einen Filter f칲r die Aggregation der Daten:</p><ol><li>Erzeuge einen leeren Filter.</li><li>Wenn <code>r.Author is not null</code>, f칲ge <code>x =&gt; x.Author == r.Author</code> hinzu.</li><li>Wenn <code>r.MinCreated is not null</code>, f칲ge <code>x =&gt; x.Created &gt;= r.MinCreated</code> hinzu.</li><li>Wenn <code>r.Tags.IsNotNullOrEmpty()</code>, f칲ge <code>x.Tags.Contains(r.Tags)</code> hinzu (oder so 칛hnlich).</li></ol><p>Aber was ist wenn ich mehrere Authoren angeben m칬chte? Dann muss <code>PostsRequest</code> entsprechend angepasst und <code>Author</code> von <code>string?</code> auf <code>List&lt;string&gt;?</code> umgestellt werden. Der Server-Code, der den eigentlichen Filter konstruiert, muss daf칲r ebenfalls angepasst werden. Bekomme ich dann die Posts jeweils aller angegebenen Authoren? Oder nur die Posts, die von allen angegebenen Authoren gemeinsam verfasst wurden? Oder beides? Hoffentlich ist <code>PostsRequest</code> entsprechend dokumentiert. Hoffentlich passt die Dokumentation zur tats칛chlichen Implementierung des Filters. Hoffentlich hat niemand im Nachhinein den Filter ver칛ndert und dabei vergessen, auch die Dokumentation anzupassen. Was ist wenn ich alle obigen F칛lle ben칬tige? F칲ge ich dann Properties f칲r alle F칛lle zu <code>PostsRequest</code> hinzu? Oder eine Art Steuer-Property, die festlegt, wie <code>r.Author</code> vom Server-Code zu interpretieren ist? Was ist wenn ich <code>MaxCreated</code> ben칬tige? Oder <code>MinCreated</code> aber nicht inklusiv sondern exklusiv? Was ist wenn ich ein noch komplexeres Filterkriterium ben칬tige?</p><p>Dieser Ansatz ist die reine H칬lle. Er verkompliziert und verengt eine Sache, die eigentlich eine sehr simple und allgemeine L칬sung haben sollte: ich gebe der Connector-Methode ein Pr칛dikat <code>Func&lt;Post, bool&gt;</code> und sie holt mir Eintr칛ge vom Typ <code>Post</code> aus der Datenbank, die auf dieses Pr칛dikat passen!</p><p>Damit verschwindet die ganze Sperrigkeit des <code>PostsRequest</code> Ansatzes, weil ich als Aufrufer der Connector-Methode selbst mein Filterpr칛dikat angebe, und zwar in der allgemeinen Form <code>Func&lt;Post,bool&gt;</code>, ohne durch die unpassende Struktur und Semantik eines Request-Datentyps eingeschr칛nkt zu sein; ohne raten zu m칲ssen, was der eigentliche Filter-Code macht, der sich hinter der API auf dem Server versteckt; ohne dass der serverseitige Filter-Code immer wieder angepasst werden muss.</p><p>Die Sache hat nat칲rlich einen Haken, der wahrscheinlich auch der Grund daf칲r sein wird, dass ich stattdessen Request-DTOs sehe: Wie serialisiert man eigentlich eine <code>Func&lt;Post, bool&gt;</code> um sie via HTTP an eine Web-API zu 칲bertragen und auf der Gegenseite korrekt wieder zu deserialisieren? 游뱂</p><p>Es gibt daf칲r tats칛chlich eine L칬sung. Die <code>FilterDefinitionBuilder</code> Klasse in <code>MongoDB.Driver</code> exponiert eine <code>Where</code> Methode:</p><pre><code>public FilterDefinition&lt;T&gt; Where(Expression&lt;Func&lt;T, bool&gt;&gt; expression)
</code></pre><p>Damit k칬nnen wir aus einer <code>Expression&lt;Func&lt;Post, bool&gt;&gt;</code> eine <code>FilterDefinition&lt;Post&gt;</code> erzeugen, die der MongoDB-Treiber in seiner Aggregation verwenden kann. Dabei repr칛sentiert <code>Expression&lt;Func&lt;Post, bool&gt;&gt;</code> einen AST f칲r den unkompilierten Code einer Funktion <code>Func&lt;Post, bool&gt;</code>. Ein AST bringt uns der Serialisierung schon ein ganzes St칲ck n칛her. Allerdings kommt das ASP.NET Model Binding mit diesem Datentyp nicht zurecht.</p><p>Immerhin m칲ssen wir den Serializer nicht selbst schreiben. Sascha Kiefer war so freundlich, daf칲r das NuGet-Paket <a href="https://www.nuget.org/packages/Serialize.Linq">Serialize.Linq</a> bereitzustellen. Wir m칲ssen lediglich im Connector-Code unsere Expression serialisieren bevor wie sie 칲bertragen, bzw. im Controller-Code h칛ndisch den <code>Request.Body</code> auslesen und deserialisieren:</p><pre><code>// Connector

Expression&lt;Func&lt;T, bool&gt;&gt; expression = x =&gt; pred(x);

ExpressionSerializer expressionSerializer =
    new Serialize.Linq.Serializers.ExpressionSerializer(
        new Serialize.Linq.Serializers.JsonSerializer()
    );

var expressionPayload =
    expressionSerializer.SerializeText(expression);

// Controller

string expressionPayload =
    await new StreamReader(Request.Body).ReadToEndAsync();

ExpressionSerializer expressionSerializer =
    new Serialize.Linq.Serializers.ExpressionSerializer(
        new Serialize.Linq.Serializers.JsonSerializer()
    );

var expression =
    (Expression&lt;Func&lt;T, bool&gt;&gt;)
    expressionSerializer.DeserializeText(expressionPayload);
</code></pre><p>Damit spart man sich einen gro른n Haufen sperrigen Behelfs-Boilerplate-Code f칲r DTOs und serverseitige Filterkonstruktion. Gleichzeitig beh칛lt man alle Freiheitsgrade eines allgemeinen logischen Pr칛dikates.</p><p>Allerdings muss man dabei ein bisschen aufpassen: der MongoDB-Treiber unterst칲tzt keine beliebigen Expressions. Er unterst칲tzt alle Logik, die man braucht, um ein Filterpr칛dikat zu formulieren, aber keinen beliebigen C#-Code, der sich prinzipiell nicht nach MongoDB 칲bersetzen l칛sst, wie z.B. <code>DateTime.Now</code> oder <code>Guid.NewGuid()</code> oder Inline-Funktionen.</p></div><footer class="content__footer"><div class="entry-wrapper"><div class="content__actions"></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://nojs.de/tschuessi-mc-post/" class="content__nav-link" rel="prev"><div><span>Previous</span> Tsch칲ssi, MC Post!</div></a></div></div></div></nav></footer></article></main><footer class="footer"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://nojs.de/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://nojs.de/assets/js/scripts.min.js?v=ffcbea6c02c8178d10092962b235a5b0"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>